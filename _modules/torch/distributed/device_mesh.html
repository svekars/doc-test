
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>torch.distributed.device_mesh &#8212; PyTorch main documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=949a1ff5" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/jit.css?v=8de1ea5d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=3ccf5357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom2.css?v=189c4a6a" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=53c08c8d"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=940804e7"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/torch/distributed/device_mesh';</script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="main (2.7.0a0+git74cfb4f )" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Learn
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Get Started</span>
                  <p>Run PyTorch locally or get started quickly with one of the supported cloud platforms</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tutorials</span>
                  <p>Whats new in PyTorch tutorials</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Learn the Basics</span>
                  <p>Familiarize yourself with PyTorch concepts and modules</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Recipes</span>
                  <p>Bite-size, ready-to-deploy PyTorch code examples</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                  <p>Master PyTorch basics with our engaging YouTube tutorial series</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Ecosystem
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tools</span>
                  <p>Learn about the tools and frameworks in the PyTorch Ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="" target="_blank">
                  <span class=dropdown-title>Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contributor Awards - 2024</span>
                  <p>Award winners announced at this year's PyTorch Conference</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">About PyTorch Edge</span>
                  <p>Build innovative and privacy-aware AI experiences for edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch</span>
                  <p>End-to-end solution for enabling on-device inference capabilities across mobile and edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch Docs</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch</span>
                  <p>Explore the documentation for comprehensive guidance on how to use PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Domains</span>
                  <p>Read the PyTorch Domains documentation to learn more about domain-specific libraries</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Blogs & News
              lnhetrlnle</a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Blog</span>
                  <p>Catch up on the latest technical news and happenings</p>
                </a>
                 <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Blog</span>
                  <p>Stories from the PyTorch ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Videos</span>
                  <p>Learn about the latest PyTorch tutorials, new, and more </p>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Newsletter</span>
                  <p>Stay up-to-date with the latest updates</p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                About
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn more about the PyTorch Foundation</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contact Us</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown">
              <a href="" data-cta="join">
                Become a Member
              </a>
            </div>
          </li>
          <li>
           <div class="main-menu-item">
             <a href="" class="github-icon">
             </a>
           </div>
          </li>
          <!--- TODO: This block adds the search icon to the nav bar. We will enable it later.
          <li>
            <div class="main-menu-item">
             <a href="" class="search-icon">
             </a>
            </div>
          </li>
          --->
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>


  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
    <div class="navbar-header-items__start" style="display: flex; align-items: center; justify-content: flex-start;">
    <div class="navbar-item">
      <a class="nav-link nav-internal" href="/index.html">Home</a></div>
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/pytorch-logo-dark-unstable.png" class="logo__image only-light" alt="PyTorch main documentation - Home"/>
    <img src="../../../_static/pytorch-logo-dark-unstable.png" class="logo__image only-dark pst-js-only" alt="PyTorch main documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../python-api/index.html">
    Python API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notes/index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../lang-bindings/index.html">
    Language Bindings
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../python-api/index.html">
    Python API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notes/index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../lang-bindings/index.html">
    Language Bindings
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    
    <li class="breadcrumb-item"><a href="../../torch.html" class="nav-link">torch</a></li>
    
    
    <li class="breadcrumb-item"><a href="../distributed.html" class="nav-link">torch.distributed</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">torch.distributed.device_mesh</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for torch.distributed.device_mesh</h1><div class="highlight"><pre>
<span></span><span class="c1"># mypy: allow-untyped-defs</span>
<span class="c1"># Copyright (c) Meta Platforms, Inc. and affiliates</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">threading</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.distributed</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_available</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.utils._typing_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">not_none</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;init_device_mesh&quot;</span><span class="p">,</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">]</span>


<span class="k">if</span> <span class="ow">not</span> <span class="n">is_available</span><span class="p">():</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

    <span class="c1"># We need to create the stubs when distributed is not available.</span>
    <span class="c1"># Otherwise, we would fail the doc tests (```./.ci/pytorch/docs-test.sh```),</span>
    <span class="c1"># since it would try to import ``torch.distributed.device_mesh`` or</span>
    <span class="c1"># ``torch.distributed.init_device_mesh`` but cannot find them.</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">_DeviceMeshStub</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_device_mesh_stub</span><span class="p">():</span>
        <span class="k">pass</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;torch.distributed.device_mesh&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">DeviceMesh</span> <span class="o">=</span> <span class="n">_DeviceMeshStub</span>  <span class="c1"># type: ignore[attr-defined]</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span>
        <span class="s2">&quot;torch.distributed.device_mesh&quot;</span>
    <span class="p">]</span><span class="o">.</span><span class="n">init_device_mesh</span> <span class="o">=</span> <span class="n">_init_device_mesh_stub</span>  <span class="c1"># type: ignore[attr-defined]</span>


<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">torch._C._distributed_c10d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Backend</span> <span class="k">as</span> <span class="n">C10dBackend</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">torch.distributed.distributed_c10d</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
        <span class="n">_find_pg_by_ranks_and_tag</span><span class="p">,</span>
        <span class="n">_get_default_group</span><span class="p">,</span>
        <span class="n">_get_group_tag</span><span class="p">,</span>
        <span class="n">get_backend</span><span class="p">,</span>
        <span class="n">get_process_group_ranks</span><span class="p">,</span>
        <span class="n">get_rank</span><span class="p">,</span>
        <span class="n">get_world_size</span><span class="p">,</span>
        <span class="n">init_process_group</span><span class="p">,</span>
        <span class="n">is_initialized</span><span class="p">,</span>
        <span class="n">new_group</span><span class="p">,</span>
        <span class="n">ProcessGroup</span><span class="p">,</span>
        <span class="n">split_group</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="c1"># only import numpy typing when type checking</span>
    <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ArrayLike</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;DeviceMesh requires numpy &gt;= 1.21 to be installed for type checking&quot;</span>
            <span class="p">)</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">_MeshEnv</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">local</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DeviceMesh</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_to_root_mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">DeviceMesh</span><span class="p">,</span> <span class="n">DeviceMesh</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_group_options</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">C10dBackend</span><span class="o">.</span><span class="n">Options</span><span class="p">]]</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">DeviceMesh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">DeviceMesh</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Record flatten mesh name to its mesh dim index in root mesh.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flatten_name_to_root_dims</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span>
                <span class="n">DeviceMesh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
            <span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_current_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No device mesh is currently active!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">create_sub_mesh</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">device_mesh</span><span class="p">:</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">,</span>
            <span class="n">submesh_dim_names</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
            <span class="n">submesh_dims</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
            <span class="c1"># Get the submesh dim size from the submesh_dims.</span>
            <span class="c1"># For example, if we have a 3D mesh with mesh_shape (2, 2, 2) mesh_dim_names (&quot;dp&quot;, &quot;cp&quot;, &quot;tp&quot;) and we want</span>
            <span class="c1"># to slice out mesh[&quot;dp_cp&quot;], then submesh_dims = [(0, 1), (2,)] and submesh_dim_size = [2 * 2, 2] = [4, 2].</span>
            <span class="c1"># If we want to slice out mesh[&quot;dp&quot;, &quot;cp&quot;], then submesh_dims = [(0,), (1,)] and submesh_dim_size = [2, 2].</span>
            <span class="n">slice_dim_size</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">reduce</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">y</span><span class="p">),</span>
                    <span class="n">mesh_dim</span><span class="p">,</span>
                    <span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">mesh_dim</span> <span class="ow">in</span> <span class="n">submesh_dims</span>
            <span class="p">]</span>

            <span class="n">mesh_tensor</span> <span class="o">=</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh</span>
            <span class="c1"># slice_dim_idx could be differnt from submesh_dims, as we may need to flatten out some dims.</span>
            <span class="n">slice_dim_idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">slice_dim_group_info</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># keep track of the number of dims that have been flattened so we can get the correct slice_dim_idx in the</span>
            <span class="c1"># flattened mesh tensor.</span>
            <span class="n">num_dims_flatten</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">mesh_dim_indices</span><span class="p">,</span> <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">submesh_dims</span><span class="p">,</span> <span class="n">submesh_dim_names</span><span class="p">):</span>
                <span class="c1"># Currently, this only allows slicing out a contiguous flattened dim.</span>
                <span class="c1"># TODO: we need to handle reconstructing a non-contiguous flattened dim.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_dim_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># We need to move the start_dim and end_dim to the left if some dims are already flattened.</span>
                    <span class="n">mesh_tensor</span> <span class="o">=</span> <span class="n">mesh_tensor</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span>
                        <span class="n">start_dim</span><span class="o">=</span><span class="n">mesh_dim_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_dims_flatten</span><span class="p">,</span>
                        <span class="n">end_dim</span><span class="o">=</span><span class="n">mesh_dim_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_dims_flatten</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="c1"># If some dims are already flattened, we need to adjust the slice_dim_idx accordingly.</span>
                    <span class="c1"># For example, if the submesh_dims = [(0, 1), (2,), (3, 4)] with 0-1 flattened and 3-4 flattened,</span>
                    <span class="c1"># then the final slice_dim_idx should be [0, 1, 2].</span>
                    <span class="n">slice_dim_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_dim_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_dims_flatten</span><span class="p">)</span>
                    <span class="n">num_dims_flatten</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_dim_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">slice_dim_group_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span><span class="p">[</span><span class="n">device_mesh</span><span class="p">][</span>
                            <span class="n">mesh_dim_name</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">_dim_group_infos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slice_dim_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_dim_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_dims_flatten</span><span class="p">)</span>
                    <span class="n">slice_dim_group_info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">device_mesh</span><span class="o">.</span><span class="n">_dim_group_infos</span><span class="p">[</span><span class="n">mesh_dim_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="p">)</span>

            <span class="c1"># mesh_tensor has already been flattened if needed. So mesh_tensor.ndim &lt;= device_mesh.mesh.ndim now.</span>
            <span class="n">mesh_dims_remained_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">mesh_tensor</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">slice_dim_idx</span><span class="p">:</span>
                <span class="n">mesh_dims_remained_idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

            <span class="c1"># pg_ranks_by_dim is the size of [number of local ranks of the outermost submesh dimension, *slice_dim_idx]</span>
            <span class="c1"># This means on each local rank of the outermost slice mesh dim, we have a tensor of submesh size with</span>
            <span class="c1"># the pg ranks of the submesh. From this, we can extract the submesh mesh tensor contains the current rank.</span>
            <span class="n">pg_ranks_by_dim</span> <span class="o">=</span> <span class="n">mesh_tensor</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
                <span class="o">*</span><span class="n">mesh_dims_remained_idx</span><span class="p">,</span> <span class="o">*</span><span class="n">slice_dim_idx</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">slice_dim_size</span><span class="p">)</span>

            <span class="n">cur_rank</span> <span class="o">=</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">get_rank</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">mesh_nd</span> <span class="ow">in</span> <span class="n">pg_ranks_by_dim</span><span class="p">:</span>
                <span class="n">submesh</span> <span class="o">=</span> <span class="n">DeviceMesh</span><span class="p">(</span>
                    <span class="n">device_mesh</span><span class="o">.</span><span class="n">device_type</span><span class="p">,</span>
                    <span class="n">mesh_nd</span><span class="p">,</span>
                    <span class="n">mesh_dim_names</span><span class="o">=</span><span class="n">submesh_dim_names</span><span class="p">,</span>
                    <span class="n">_init_backend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">cur_rank</span> <span class="ow">in</span> <span class="n">mesh_nd</span><span class="p">:</span>
                    <span class="n">res_submesh</span> <span class="o">=</span> <span class="n">submesh</span>

            <span class="n">res_submesh</span><span class="o">.</span><span class="n">_dim_group_infos</span> <span class="o">=</span> <span class="n">slice_dim_group_info</span>  <span class="c1"># type: ignore[possibly-undefined]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_to_root_mapping</span><span class="p">[</span><span class="n">res_submesh</span><span class="p">]</span> <span class="o">=</span> <span class="n">device_mesh</span>

            <span class="k">return</span> <span class="n">res_submesh</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">create_flatten_mesh</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">device_mesh</span><span class="p">:</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">,</span> <span class="n">mesh_dim_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
            <span class="n">root_mesh</span> <span class="o">=</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">get_root_mesh</span><span class="p">(</span><span class="n">device_mesh</span><span class="p">)</span>

            <span class="n">flatten_dims_in_root</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">not_none</span><span class="p">(</span><span class="n">root_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">flattened_mesh_dim_name</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">flattened_mesh_dim_name</span> <span class="ow">in</span> <span class="n">not_none</span><span class="p">(</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh_dim_name</span><span class="p">:</span>
                <span class="n">mesh_dim_name</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">not_none</span><span class="p">(</span><span class="n">root_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">)[</span><span class="n">dim</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">flatten_dims_in_root</span>
                    <span class="p">]</span>
                <span class="p">)</span>

            <span class="c1"># Check whether the mesh_dim_name for flattened mesh is valid.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flatten_name_to_root_dims</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">root_mesh</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">invalid_dim_names</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">not_none</span><span class="p">(</span><span class="n">root_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">)),</span>
                <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten_name_to_root_dims</span><span class="p">[</span><span class="n">root_mesh</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="n">invalid_dim_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mesh_dim_name</span><span class="si">}</span><span class="s2"> already exists for submesh of the </span><span class="si">{</span><span class="n">root_mesh</span><span class="si">}</span><span class="s2">. &quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;The mesh_dim_names of submesh and flattened mesh are </span><span class="si">{</span><span class="n">invalid_dim_names</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Please specify another valid mesh_dim_name.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Quick return if the flatten mesh has been created before.</span>
            <span class="c1"># TODO: If we decide to restrict flatten initialization once, we should remove</span>
            <span class="c1"># this check and throw an error if the flatten mesh is already created before.</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">root_mesh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span>
                <span class="ow">and</span> <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span><span class="p">[</span><span class="n">root_mesh</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span><span class="p">[</span><span class="n">root_mesh</span><span class="p">][</span><span class="n">mesh_dim_name</span><span class="p">]</span>

            <span class="n">flattened_mesh_dim_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">size</span><span class="p">())</span>

            <span class="n">remained_dims_in_root</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">root_mesh</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">flatten_dim_in_root</span> <span class="ow">in</span> <span class="n">flatten_dims_in_root</span><span class="p">:</span>
                <span class="n">remained_dims_in_root</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">flatten_dim_in_root</span><span class="p">)</span>

            <span class="n">pg_ranks_by_dim</span> <span class="o">=</span> <span class="n">root_mesh</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
                <span class="o">*</span><span class="n">remained_dims_in_root</span><span class="p">,</span> <span class="o">*</span><span class="n">flatten_dims_in_root</span>
            <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">flattened_mesh_dim_size</span><span class="p">)</span>

            <span class="n">cur_rank</span> <span class="o">=</span> <span class="n">root_mesh</span><span class="o">.</span><span class="n">get_rank</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">mesh_nd</span> <span class="ow">in</span> <span class="n">pg_ranks_by_dim</span><span class="p">:</span>
                <span class="c1"># need to init backend here since the flattened pg doesn&#39;t exist in root mesh.</span>
                <span class="n">flattened_mesh</span> <span class="o">=</span> <span class="n">DeviceMesh</span><span class="p">(</span>
                    <span class="n">root_mesh</span><span class="o">.</span><span class="n">device_type</span><span class="p">,</span>
                    <span class="n">mesh_nd</span><span class="p">,</span>
                    <span class="n">mesh_dim_names</span><span class="o">=</span><span class="p">(</span><span class="n">mesh_dim_name</span><span class="p">,),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">cur_rank</span> <span class="ow">in</span> <span class="n">mesh_nd</span><span class="p">:</span>
                    <span class="n">res_flattened_mesh</span> <span class="o">=</span> <span class="n">flattened_mesh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_to_root_mapping</span><span class="p">[</span><span class="n">res_flattened_mesh</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_mesh</span>  <span class="c1"># type: ignore[possibly-undefined]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">root_mesh</span><span class="p">,</span> <span class="p">{})[</span><span class="n">mesh_dim_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">res_flattened_mesh</span>  <span class="c1"># type: ignore[possibly-undefined]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flatten_name_to_root_dims</span><span class="p">[</span><span class="n">root_mesh</span><span class="p">][</span><span class="n">mesh_dim_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_dims_in_root</span><span class="p">)</span>  <span class="c1"># type: ignore[possibly-undefined]</span>

            <span class="k">return</span> <span class="n">res_flattened_mesh</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_root_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_mesh</span><span class="p">:</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
            <span class="c1"># If a mesh could not be found in the child_to_root_mapping, it is a root mesh itself.</span>
            <span class="c1"># A root mesh is not created through slicing.</span>
            <span class="c1"># We considers the root mesh of a root mesh is itself.</span>
            <span class="n">root_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_to_root_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">device_mesh</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">device_mesh</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">root_mesh</span> <span class="k">else</span> <span class="n">root_mesh</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_root_mesh_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_mesh</span><span class="p">:</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the index of the mesh dim in the root mesh.</span>
<span class="sd">            The device_mesh passed in needs to be sliced out from the root mesh</span>
<span class="sd">            or submesh of the root mesh.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">root_mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_root_mesh</span><span class="p">(</span><span class="n">device_mesh</span><span class="p">)</span>
            <span class="n">child_mesh_dim_names</span> <span class="o">=</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span>
            <span class="k">if</span> <span class="n">root_mesh</span> <span class="ow">and</span> <span class="n">child_mesh_dim_names</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">child_mesh_dim_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="p">),</span> <span class="s2">&quot;The submesh can only be a 1D mesh.&quot;</span>
                <span class="n">child_mesh_dim_name</span> <span class="o">=</span> <span class="n">child_mesh_dim_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mesh_dim_by_name</span><span class="p">(</span><span class="n">root_mesh</span><span class="p">,</span> <span class="n">child_mesh_dim_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">num_devices_per_host</span><span class="p">(</span><span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_device_handle</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span><span class="o">.</span><span class="n">device_count</span><span class="p">()</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">num_hosts</span><span class="p">(</span><span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="c1"># ProcessGroup can&#39;t tell us this info so we have to infer it, assume</span>
            <span class="c1"># homogeneous hardware for now</span>
            <span class="k">return</span> <span class="n">get_world_size</span><span class="p">()</span> <span class="o">//</span> <span class="n">_MeshEnv</span><span class="o">.</span><span class="n">num_devices_per_host</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_mesh_dim_by_name</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">device_mesh</span><span class="p">:</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">,</span> <span class="n">mesh_dim_name</span><span class="p">:</span> <span class="nb">str</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s2">&quot;No `mesh_dim_names` found.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">mesh_dim_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Mesh dimension &#39;</span><span class="si">{</span><span class="n">mesh_dim_name</span><span class="si">}</span><span class="s2">&#39; does not exist.&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Available mesh dimensions are: mesh_dim_names=</span><span class="si">{</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">not_none</span><span class="p">(</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mesh_dim_name</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_set_mesh_dim_group_options</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
            <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">pg_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">C10dBackend</span><span class="o">.</span><span class="n">Options</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_group_options</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">pg_options</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_slice_mesh_dims</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">device_mesh</span><span class="p">,</span> <span class="n">mesh_dim_names</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Validate whether the mesh_dim_names is valid for slicing the given device_mesh.</span>
<span class="sd">            If valid, return dim indexes of the slice mesh in the device mesh.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">device_mesh</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_root_mesh</span><span class="p">(</span><span class="n">device_mesh</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot create a submesh from a submesh.&quot;</span><span class="p">)</span>

            <span class="c1"># The slice mesh_dim_names should consist either the device_mesh&#39;s mesh_dim_names</span>
            <span class="c1"># or its flattened mesh&#39;s mesh_dim_names.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flatten_name_to_root_dims</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">device_mesh</span><span class="p">,</span> <span class="p">{})</span>
            <span class="n">flatten_name_to_root_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten_name_to_root_dims</span><span class="p">[</span><span class="n">device_mesh</span><span class="p">]</span>
            <span class="n">valid_mesh_dim_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="o">*</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">,</span>
                <span class="o">*</span><span class="n">flatten_name_to_root_dims</span><span class="p">,</span>
            <span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="n">valid_mesh_dim_names</span>
                <span class="k">for</span> <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="n">mesh_dim_names</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid mesh_dim_names </span><span class="si">{</span><span class="n">mesh_dim_names</span><span class="si">}</span><span class="s2"> specified. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Valid mesh_dim_names are </span><span class="si">{</span><span class="n">valid_mesh_dim_names</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Validate the order of the slice mesh dim indices.</span>
            <span class="c1"># This needs to be in ascending order.</span>
            <span class="n">curr_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">slice_mesh_dims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="n">mesh_dim_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mesh_dim_name</span> <span class="ow">in</span> <span class="n">flatten_name_to_root_dims</span><span class="p">:</span>
                    <span class="n">mesh_indices</span> <span class="o">=</span> <span class="n">flatten_name_to_root_dims</span><span class="p">[</span><span class="n">mesh_dim_name</span><span class="p">]</span>
                    <span class="c1"># TODO: this doesn&#39;t allow non-contiguous slicing with flatten dim yet. next_idx</span>
                    <span class="c1"># should be mesh_indices[0] once we support non-contiguous slicing with flatten dim.</span>
                    <span class="n">next_idx</span> <span class="o">=</span> <span class="n">mesh_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">slice_mesh_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_indices</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">next_idx</span> <span class="o">=</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mesh_dim_name</span><span class="p">)</span>
                    <span class="n">slice_mesh_dims</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">next_idx</span><span class="p">,))</span>
                <span class="k">if</span> <span class="n">next_idx</span> <span class="o">&lt;=</span> <span class="n">curr_idx</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Invalid mesh_dim_names </span><span class="si">{</span><span class="n">mesh_dim_names</span><span class="si">}</span><span class="s2"> specified. &quot;</span><span class="p">,</span>
                        <span class="sa">f</span><span class="s2">&quot;Found mesh dim indices to slice: </span><span class="si">{</span><span class="n">slice_mesh_dims</span><span class="si">}</span><span class="s2">. &quot;</span><span class="p">,</span>
                        <span class="s2">&quot;Mesh dim indices should be in ascending order.&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="n">curr_idx</span> <span class="o">=</span> <span class="n">next_idx</span>

            <span class="k">return</span> <span class="n">slice_mesh_dims</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_all_submeshes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">device_mesh</span><span class="p">:</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">,</span> <span class="n">mesh_dim_name</span><span class="p">:</span> <span class="nb">str</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s2">&quot;DeviceMesh&quot;</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return all the submeshes of a given mesh dimension of the device mesh.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">mesh_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mesh_dim_by_name</span><span class="p">(</span><span class="n">device_mesh</span><span class="p">,</span> <span class="n">mesh_dim_name</span><span class="p">)</span>
            <span class="n">pg_ranks_by_dim</span> <span class="o">=</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">swapdims</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mesh_dim</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">mesh_dim</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">cur_rank</span> <span class="o">=</span> <span class="n">device_mesh</span><span class="o">.</span><span class="n">get_rank</span><span class="p">()</span>
            <span class="n">res_submeshes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mesh_1d</span> <span class="ow">in</span> <span class="n">pg_ranks_by_dim</span><span class="p">:</span>
                <span class="n">submesh</span> <span class="o">=</span> <span class="n">DeviceMesh</span><span class="p">(</span>
                    <span class="n">device_mesh</span><span class="o">.</span><span class="n">device_type</span><span class="p">,</span>
                    <span class="n">mesh_1d</span><span class="p">,</span>
                    <span class="n">mesh_dim_names</span><span class="o">=</span><span class="p">(</span><span class="n">mesh_dim_name</span><span class="p">,),</span>
                    <span class="n">_init_backend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">submesh</span><span class="o">.</span><span class="n">_dim_group_infos</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">[</span><span class="n">device_mesh</span><span class="o">.</span><span class="n">_dim_group_infos</span><span class="p">[</span><span class="n">mesh_dim</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">cur_rank</span> <span class="ow">in</span> <span class="n">mesh_1d</span>
                    <span class="k">else</span> <span class="p">[]</span>
                <span class="p">)</span>
                <span class="n">res_submeshes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">submesh</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">res_submeshes</span>

    <span class="n">_mesh_resources</span><span class="p">:</span> <span class="n">_MeshEnv</span> <span class="o">=</span> <span class="n">_MeshEnv</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_device_handle</span><span class="p">(</span><span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the module corresponding to the device_type which is cuda or cuda-like device.</span>
<span class="sd">        For example, when the device_type is cuda, the module `torch.cuda` is returned.</span>
<span class="sd">        Return None when there is no corresponding module for device_type, otherwise</span>
<span class="sd">        return the corresponding module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">torch</span><span class="p">,</span> <span class="n">device_type</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<div class="viewcode-block" id="DeviceMesh">
<a class="viewcode-back" href="../../../python-api/distributed.html#torch.distributed.device_mesh.DeviceMesh">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">DeviceMesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DeviceMesh represents a mesh of devices, where layout of devices could be</span>
<span class="sd">        represented as a n-d dimension array, and each value of the n-d dimensional</span>
<span class="sd">        array is the global id of the default process group ranks.</span>

<span class="sd">        DeviceMesh could be used to describe the layout of devices across the cluster,</span>
<span class="sd">        and serves as a proxy for communication among the device lists within the cluster.</span>

<span class="sd">        DeviceMesh can be used as a context manager.</span>

<span class="sd">        .. note::</span>
<span class="sd">            DeviceMesh follows SPMD programming model, which means the same PyTorch Python program</span>
<span class="sd">            is running on all processes/ranks in the cluster. Therefore, users need to make sure the</span>
<span class="sd">            `mesh` array (which describes the layout of devices) should be identical across all ranks.</span>
<span class="sd">            Inconsistent `mesh` will lead to silent hang.</span>

<span class="sd">        Args:</span>
<span class="sd">            device_type (str): The device type of the mesh. Currently supports: &quot;cpu&quot;, &quot;cuda/cuda-like&quot;.</span>
<span class="sd">            mesh (ndarray): A multi-dimensional array or an integer tensor describing the layout</span>
<span class="sd">                of devices, where the IDs are global IDs of the default process group.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DeviceMesh: A :class:`DeviceMesh` object representing the device layout.</span>

<span class="sd">        The following program runs on each process/rank in an SPMD manner. In this example, we have 2</span>
<span class="sd">        hosts with 4 GPUs each.</span>
<span class="sd">        A reduction over the first dimension of mesh will reduce across</span>
<span class="sd">        columns (0, 4), .. and (3, 7), a reduction over the second dimension</span>
<span class="sd">        of mesh reduces across rows (0, 1, 2, 3) and (4, 5, 6, 7).</span>

<span class="sd">        Example::</span>
<span class="sd">            &gt;&gt;&gt; # xdoctest: +SKIP(&quot;no rank&quot;)</span>
<span class="sd">            &gt;&gt;&gt; from torch.distributed.device_mesh import DeviceMesh</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; # Initialize device mesh as (2, 4) to represent the topology</span>
<span class="sd">            &gt;&gt;&gt; # of cross-host(dim 0), and within-host (dim 1).</span>
<span class="sd">            &gt;&gt;&gt; mesh = DeviceMesh(device_type=&quot;cuda&quot;, mesh=[[0, 1, 2, 3],[4, 5, 6, 7]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span>
        <span class="n">mesh</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
        <span class="n">mesh_dim_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">mesh</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">],</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">mesh_dim_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">_init_backend</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">device_type</span> <span class="o">=</span> <span class="n">device_type</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mesh</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`mesh` must be a CPU tensor, got </span><span class="si">{</span><span class="n">mesh</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">)</span> <span class="k">if</span> <span class="n">mesh_dim_names</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="c1"># private field to pre-generate DeviceMesh&#39;s hash</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_mesh_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_thread_id</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Skip process group initialization if xla device or init backend is False</span>
            <span class="c1"># TODO(yeounoh) implement DeviceMesh backend and register XLA backend.</span>
            <span class="k">if</span> <span class="n">device_type</span> <span class="o">!=</span> <span class="s2">&quot;xla&quot;</span><span class="p">:</span>
                <span class="c1"># always try to create default (world) pg, even if it is not initialized</span>
                <span class="c1"># already. The world pg is used for device mesh identity (rank) on each</span>
                <span class="c1"># process (we need to know if the current global rank is in the mesh or not).</span>
                <span class="k">if</span> <span class="n">_init_backend</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_default_group</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_init_process_groups</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">is_initialized</span><span class="p">()</span> <span class="ow">and</span> <span class="n">get_backend</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;threaded&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_thread_id</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">get_ident</span><span class="p">()</span>

                <span class="c1"># calculate the coordinates of the current global rank on the mesh</span>
                <span class="n">rank_coords</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">==</span> <span class="n">get_rank</span><span class="p">())</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="k">assert</span> <span class="n">rank_coords</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_on_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">rank_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">rank_coords</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_or_create_default_group</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">default_initialized</span> <span class="o">=</span> <span class="n">is_initialized</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">default_initialized</span><span class="p">:</span>
                <span class="n">init_process_group</span><span class="p">()</span>

            <span class="n">world_size</span> <span class="o">=</span> <span class="n">get_world_size</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">world_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Mesh should not be bigger than default world size </span><span class="si">{</span><span class="n">world_size</span><span class="si">}</span><span class="s2">, but found </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span><span class="si">}</span><span class="s2"> ranks!&quot;</span>
                <span class="p">)</span>

            <span class="n">device_handle</span> <span class="o">=</span> <span class="n">_get_device_handle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device_type</span><span class="p">)</span>
            <span class="c1"># TODO: if user want to pass pg_options, offer a way to do it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">default_initialized</span> <span class="ow">and</span> <span class="n">device_handle</span><span class="p">:</span>
                <span class="c1"># automatically set the current cuda/cuda-like device base on num of gpu devices available in each host</span>
                <span class="c1"># NOTE: This device selection would only work for homogeneous hardware.</span>
                <span class="n">num_devices_per_host</span> <span class="o">=</span> <span class="n">device_handle</span><span class="o">.</span><span class="n">device_count</span><span class="p">()</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">world_size</span> <span class="o">&gt;</span> <span class="n">num_devices_per_host</span>
                    <span class="ow">and</span> <span class="n">world_size</span> <span class="o">%</span> <span class="n">num_devices_per_host</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;DeviceMesh only support homogeneous hardware, but found &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">world_size</span><span class="si">}</span><span class="s2"> ranks and </span><span class="si">{</span><span class="n">num_devices_per_host</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">device_type</span><span class="si">}</span><span class="s2"> devices!&quot;</span>
                    <span class="p">)</span>
                <span class="n">device_handle</span><span class="o">.</span><span class="n">set_device</span><span class="p">(</span><span class="n">get_rank</span><span class="p">()</span> <span class="o">%</span> <span class="n">num_devices_per_host</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_get_default_group</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_init_process_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># tag/ranks/group_name associated with each mesh dimension, each</span>
            <span class="c1"># mesh dimension should have one sub-group per rank</span>
            <span class="c1">#</span>
            <span class="c1"># TODO(yifu): remove tag and ranks once we fully migrate to native</span>
            <span class="c1"># functional collectives. See details in:</span>
            <span class="c1"># https://github.com/pytorch/pytorch/issues/93173#issuecomment-1907095208</span>
            <span class="n">dim_group_infos</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">default_group</span> <span class="o">=</span> <span class="n">_get_default_group</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="o">==</span> <span class="n">get_world_size</span><span class="p">():</span>
                <span class="c1"># Append the default pg to the first dim groups only if the default pg is compatible with `self.device_type`.</span>
                <span class="c1"># Otherwise, create new pg.</span>
                <span class="n">ranks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">get_world_size</span><span class="p">()))</span>
                <span class="n">dim_group</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">new_group</span><span class="p">(</span>
                        <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;cpu:gloo,cuda:nccl&quot;</span><span class="p">,</span>
                        <span class="n">ranks</span><span class="o">=</span><span class="n">ranks</span><span class="p">,</span>
                        <span class="n">group_desc</span><span class="o">=</span><span class="s2">&quot;mesh_default&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
                    <span class="ow">and</span> <span class="n">get_backend</span><span class="p">(</span><span class="n">default_group</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;gloo&quot;</span>
                    <span class="k">else</span> <span class="n">default_group</span>
                <span class="p">)</span>
                <span class="n">dim_group_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="n">_get_group_tag</span><span class="p">(</span><span class="n">dim_group</span><span class="p">),</span>
                        <span class="n">ranks</span><span class="p">,</span>
                        <span class="n">dim_group</span><span class="o">.</span><span class="n">group_name</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># create sub pgs base on the mesh argument specified</span>
                <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
                    <span class="c1"># swap the current dim to the last dim</span>
                    <span class="c1"># then reshape to flatten out other dims</span>
                    <span class="n">pg_ranks_by_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">swapdims</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># Respect dim group options specified via _MeshEnv.set_dim_group_options().</span>
                    <span class="c1"># Inherit from the parent group if no options are specified for the group.</span>
                    <span class="k">if</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">mesh_dim_group_options</span><span class="p">:</span>
                        <span class="p">(</span>
                            <span class="n">backend</span><span class="p">,</span>
                            <span class="n">pg_options</span><span class="p">,</span>
                        <span class="p">)</span> <span class="o">=</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">mesh_dim_group_options</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">backend</span><span class="p">,</span> <span class="n">pg_options</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

                    <span class="c1"># If we have a 2D mesh with mesh_dim_names (&quot;dp&quot;, &quot;tp&quot;), the group description</span>
                    <span class="c1"># of the subgroups would be `mesh_dim_dp` and `mesh_name_tp`.</span>
                    <span class="c1"># If the mesh doesn&#39;t not have a mesh_dim_names, then the group description of the</span>
                    <span class="c1"># subgroup would be `mesh_dim_0` and `mesh_dim_1`.</span>
                    <span class="n">group_desc</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;mesh_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span>
                        <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;mesh_dim_</span><span class="si">{</span><span class="n">dim</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                    <span class="c1"># If bound_device_id exists, it means the nccl communicator has been eagerly initialized</span>
                    <span class="c1"># so that we can use `split_group` to create subgroups through `ncclCommSplit`.</span>
                    <span class="c1"># In this case, we only need to make one API call (`split_group``) for the subgroup creation</span>
                    <span class="c1"># for each mesh dimension. In a 2 * 4 mesh, we only need to make 2 API calls per ranks to create</span>
                    <span class="c1"># all the subgroups.</span>
                    <span class="c1"># Otherwise, we need to make more than one API call (`new_group`) for subgroup creations. The</span>
                    <span class="c1"># numbers of API calls are equal to the number of subgroups for each mesh dimension. In a 2 * 4</span>
                    <span class="c1"># mesh, we need to make 2 + 4 = 6 API calls per ranks to create all the subgroups.</span>
                    <span class="n">dim_group</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">has_split_group</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">bound_device_id</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span>
                            <span class="n">default_group</span><span class="p">,</span> <span class="s2">&quot;bound_device_id&quot;</span><span class="p">,</span> <span class="kc">None</span>
                        <span class="p">)</span>
                    <span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
                        <span class="n">dim_group</span> <span class="o">=</span> <span class="n">split_group</span><span class="p">(</span>
                            <span class="n">parent_pg</span><span class="o">=</span><span class="n">default_group</span><span class="p">,</span>
                            <span class="n">pg_options</span><span class="o">=</span><span class="n">pg_options</span><span class="p">,</span>
                            <span class="n">split_ranks</span><span class="o">=</span><span class="n">pg_ranks_by_dim</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                            <span class="n">group_desc</span><span class="o">=</span><span class="n">group_desc</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">has_split_group</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># If the subgroup has been already created through `split_group`, we simply loop over `pg_ranks_by_dim`</span>
                    <span class="c1"># and append the `(group_tag, subgroup_ranks, and group_name)` tuple to the `dim_group_infos` list when</span>
                    <span class="c1"># the current rank is in the subgroup.</span>
                    <span class="c1"># Otherwise, we use `new_group` instead of `split_group` to create subgroups by looping over `pg_ranks_by_dim`</span>
                    <span class="c1"># along with appending information to the `dim_group_infos` list whenever necessary.</span>
                    <span class="k">for</span> <span class="n">dim_mesh</span> <span class="ow">in</span> <span class="n">pg_ranks_by_dim</span><span class="p">:</span>
                        <span class="n">subgroup_ranks</span> <span class="o">=</span> <span class="n">dim_mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                        <span class="c1"># We temporarily revert the re-use subgroup, since it breaks two internal tests.</span>
                        <span class="c1"># Temporarily reverting to resolve test timeout while root-causing.</span>
                        <span class="c1"># TODO: Add two tests to cover internal tests scenarios and re-enable reuse subgroup if exists.</span>
                        <span class="k">if</span> <span class="n">bound_device_id</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">has_split_group</span><span class="p">:</span>
                            <span class="n">dim_group</span> <span class="o">=</span> <span class="n">new_group</span><span class="p">(</span>
                                <span class="n">ranks</span><span class="o">=</span><span class="n">subgroup_ranks</span><span class="p">,</span>
                                <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
                                <span class="n">pg_options</span><span class="o">=</span><span class="n">pg_options</span><span class="p">,</span>
                                <span class="n">group_desc</span><span class="o">=</span><span class="n">group_desc</span><span class="p">,</span>
                            <span class="p">)</span>

                        <span class="c1"># only add to dim_groups if the current rank in the subgroup</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">()</span> <span class="ow">in</span> <span class="n">subgroup_ranks</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dim_group_infos</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dim</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Each device mesh dimension should get only one process group, but got </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">get_rank</span><span class="p">()</span><span class="si">}</span><span class="s2"> &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;in </span><span class="si">{</span><span class="n">subgroup_ranks</span><span class="si">}</span><span class="s2">!&quot;</span>
                                <span class="p">)</span>
                            <span class="n">dim_group_infos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                <span class="p">(</span>
                                    <span class="n">_get_group_tag</span><span class="p">(</span><span class="n">not_none</span><span class="p">(</span><span class="n">dim_group</span><span class="p">)),</span>
                                    <span class="n">subgroup_ranks</span><span class="p">,</span>
                                    <span class="n">dim_group</span><span class="o">.</span><span class="n">group_name</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim_group_infos</span> <span class="o">=</span> <span class="n">dim_group_infos</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
            <span class="c1"># set this mesh as the current mesh in mesh env</span>
            <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">mesh_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># pyre-fixme[2]: Parameter must be annotated.</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_traceback</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># pop this mesh from mesh env</span>
            <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">mesh_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">device_mesh_repr</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DeviceMesh(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">device_type</span><span class="si">}</span><span class="s2">&#39;, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span>
                <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;DeviceMesh(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">device_type</span><span class="si">}</span><span class="s2">&#39;, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2">, mesh_dim_names=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">device_mesh_repr</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># lazily compute hash</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_hash&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_mesh_list</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">device_type</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_thread_id</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DeviceMesh</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_flatten_mesh_list</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_flatten_mesh_list</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">device_type</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">device_type</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">mesh_dim_names</span>
                    <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_thread_id</span>
                <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim_names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Slice the current DeviceMesh based on the mesh_dim_names given to create a submesh.</span>
<span class="sd">            The submesh created consists of the dimensions and the communicators indicated by</span>
<span class="sd">            ``mesh_dim_names``</span>

<span class="sd">            Args:</span>
<span class="sd">                mesh_dim_names (Union[str, Tuple[str]]): the name or the tuple of names of the</span>
<span class="sd">                mesh dimension of the DeviceMesh to create the submesh for.</span>
<span class="sd">            Returns:</span>
<span class="sd">                A :class:`DeviceMesh` object</span>

<span class="sd">            The following program runs on each process/rank in an SPMD manner in a world size of 8.</span>
<span class="sd">            In the first example:</span>
<span class="sd">                Calling mesh_2d[&quot;tp&quot;] on rank 0, 1, 2, 3 returns a 1D submesh of DeviceMesh:([0, 1, 2, 3]).</span>
<span class="sd">                Calling mesh_2d[&quot;tp&quot;] on rank 4, 5, 6, 7 returns a 1D submesh of  DeviceMesh:([4, 5, 6, 7]).</span>
<span class="sd">                Calling mesh_2d[&quot;dp&quot;] on rank 0, 4 returns a 1D submesh of  DeviceMesh:([0, 4]).</span>
<span class="sd">                Calling mesh_2d[&quot;dp&quot;] on rank 1, 5 returns a 1D submesh of  DeviceMesh:([1, 5]).</span>
<span class="sd">                Calling mesh_2d[&quot;dp&quot;] on rank 2, 6 returns a 1D submesh of  DeviceMesh:([2, 6]).</span>
<span class="sd">                Calling mesh_2d[&quot;dp&quot;] on rank 3, 7 returns a 1D submesh of  DeviceMesh:([3, 7]).</span>

<span class="sd">            In the second example:</span>
<span class="sd">                Calling mesh_3d[&quot;dp&quot;, &quot;cp&quot;] on rank 0, 1, 4, 5 returns a 2D submesh of DeviceMesh:([[0, 1], [4, 5]]).</span>
<span class="sd">                Calling mesh_3d[&quot;dp&quot;, &quot;cp&quot;] on rank 2, 3, 6, 7 returns a 2D submesh of DeviceMesh:([[2, 3], [6, 7]]).</span>
<span class="sd">                Calling mesh_3d[&quot;cp&quot;, &quot;dp&quot;] on rank 0, 1, 4, 5 returns a 2D submesh of DeviceMesh:([[0, 4], [1, 5]]).</span>
<span class="sd">                Calling mesh_3d[&quot;cp&quot;, &quot;dp&quot;] on rank 2, 3, 6, 7 returns a 2D submesh of DeviceMesh:([[2, 6], [3, 7]]).</span>

<span class="sd">            Example::</span>
<span class="sd">                &gt;&gt;&gt; # xdoctest: +SKIP(&quot;no rank&quot;)</span>
<span class="sd">                &gt;&gt;&gt; from torch.distributed.device_mesh import DeviceMesh</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; # Initialize a 2D device mesh as (2, 4) to represent the topology</span>
<span class="sd">                &gt;&gt;&gt; # of cross-host(dim 0), and within-host (dim 1).</span>
<span class="sd">                &gt;&gt;&gt; mesh_2d = init_device_mesh(device_type=&quot;cuda&quot;, (2,4), mesh_dim_names=(&quot;dp&quot;, &quot;tp&quot;))</span>
<span class="sd">                &gt;&gt;&gt; tp_mesh = mesh_2d[&quot;tp&quot;]</span>
<span class="sd">                &gt;&gt;&gt; dp_mesh = mesh_2d[&quot;dp&quot;]</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; # Initialize a 3D mesh.</span>
<span class="sd">                &gt;&gt;&gt; mesh_3d = init_device_mesh(device_type=&quot;cuda&quot;, (2,2,2), mesh_dim_names=(&quot;dp&quot;, &quot;pp&quot;, &quot;cp&quot;))</span>
<span class="sd">                &gt;&gt;&gt; # The order of the mesh_dim_names provided deteremines the order of dimensions in the submesh.</span>
<span class="sd">                &gt;&gt;&gt; dp_cp_mesh = mesh_3d[&quot;dp&quot;, &quot;cp&quot;]</span>
<span class="sd">                &gt;&gt;&gt; cp_dp_mesh = mesh_3d[&quot;cp&quot;, &quot;dp&quot;]</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot slice a DeviceMesh without mesh_dim_names!&quot;</span><span class="p">)</span>

            <span class="n">mesh_dim_names</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">,)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">mesh_dim_names</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">mesh_dim_names</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_mesh_dims</span> <span class="o">=</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">_get_slice_mesh_dims</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim_names</span>
                <span class="p">)</span>
                <span class="c1"># When using FakeTensorMode to trace the model, `create_sub_mesh()` will</span>
                <span class="c1"># fail as it will require a real tensor to manipulate.</span>
                <span class="c1"># `unset_fake_temporarily()` will allow us to materialize the tensors</span>
                <span class="c1"># within `_mesh_resources`, which should not affect modling.</span>
                <span class="c1">#</span>
                <span class="c1"># Note that this should be orthogonal to torch.compile(). But whether</span>
                <span class="c1"># we can compile device_mesh `slicing` (no graph break) is not verified</span>
                <span class="c1"># yet and need a follow-up,</span>
                <span class="c1"># TODO: compiler + device_mesh slicing.</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">_subclasses</span><span class="o">.</span><span class="n">fake_tensor</span><span class="o">.</span><span class="n">unset_fake_temporarily</span><span class="p">():</span>
                    <span class="n">submesh</span> <span class="o">=</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">create_sub_mesh</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim_names</span><span class="p">,</span> <span class="n">slice_mesh_dims</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">submesh</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ProcessGroup</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the single ProcessGroup specified by mesh_dim, or, if mesh_dim is not specified and the</span>
<span class="sd">            DeviceMesh is 1-dimensional, returns the only ProcessGroup in the mesh.</span>

<span class="sd">            Args:</span>
<span class="sd">                mesh_dim (str/int, optional): it can be the name of the mesh dimension or the index</span>
<span class="sd">                of the mesh dimension. Default is None.</span>

<span class="sd">            Returns:</span>
<span class="sd">                A :class:`ProcessGroup` object.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_dim_group_infos&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;DeviceMesh process groups not initialized!&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mesh_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Found the DeviceMesh have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Optional kwarg `mesh_dim` needs to be specified when device_mesh.ndim &gt; 1.&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;If you want to get the list of all the ProcessGroups in the DeviceMesh,&quot;</span>
                    <span class="s2">&quot;please use `get_all_groups()` instead.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Quick return if the current device_mesh is a 1D mesh.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mesh_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">not_none</span><span class="p">(</span>
                    <span class="n">_find_pg_by_ranks_and_tag</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_group_infos</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>
                <span class="p">)</span>

            <span class="n">root_mesh</span> <span class="o">=</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">get_root_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">root_to_flatten_mapping</span> <span class="o">=</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">root_to_flatten_mapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">root_mesh</span><span class="p">,</span> <span class="kc">None</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">root_to_flatten_mapping</span> <span class="ow">and</span> <span class="n">mesh_dim</span> <span class="ow">in</span> <span class="n">root_to_flatten_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">dim_group_infos</span> <span class="o">=</span> <span class="n">root_to_flatten_mapping</span><span class="p">[</span><span class="n">mesh_dim</span><span class="p">]</span><span class="o">.</span><span class="n">_dim_group_infos</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># type: ignore[index]</span>
                <span class="k">return</span> <span class="n">not_none</span><span class="p">(</span><span class="n">_find_pg_by_ranks_and_tag</span><span class="p">(</span><span class="o">*</span><span class="n">dim_group_infos</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh_dim</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">get_mesh_dim_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh_dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                    <span class="k">else</span> <span class="n">mesh_dim</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">not_none</span><span class="p">(</span>
                    <span class="n">_find_pg_by_ranks_and_tag</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_dim_group_infos</span><span class="p">[</span><span class="n">mesh_dim</span><span class="p">][:</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># type: ignore[index]</span>
                <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_all_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">ProcessGroup</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a list of ProcessGroups for all mesh dimensions.</span>

<span class="sd">            Returns:</span>
<span class="sd">                A list of :class:`ProcessGroup` object.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">from_group</span><span class="p">(</span>
            <span class="n">group</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ProcessGroup</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">ProcessGroup</span><span class="p">]],</span>
            <span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">mesh</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;ArrayLike&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span>
            <span class="n">mesh_dim_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Constructs a :class:`DeviceMesh` with ``device_type`` from an</span>
<span class="sd">            existing :class:`ProcessGroup`.</span>

<span class="sd">            The constructed device mesh has number of dimensions equal to the</span>
<span class="sd">            number of groups passed. If more than one group is passed, then the</span>
<span class="sd">            ``mesh`` argument is required.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">ProcessGroup</span><span class="p">):</span>
                <span class="n">group_ranks</span> <span class="o">=</span> <span class="n">get_process_group_ranks</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">!=</span> <span class="n">group_ranks</span>
                <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="n">mesh</span> <span class="o">!=</span> <span class="n">group_ranks</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Invalid mesh </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="si">}</span><span class="s2"> for ProcessGroup with ranks </span><span class="si">{</span><span class="n">group_ranks</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">group_ranks</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
                <span class="n">device_mesh</span> <span class="o">=</span> <span class="n">DeviceMesh</span><span class="p">(</span>
                    <span class="n">device_type</span><span class="p">,</span>
                    <span class="n">mesh</span><span class="p">,</span>
                    <span class="n">mesh_dim_names</span><span class="o">=</span><span class="n">mesh_dim_names</span><span class="p">,</span>
                    <span class="n">_init_backend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">device_mesh</span><span class="o">.</span><span class="n">_dim_group_infos</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">_get_group_tag</span><span class="p">(</span><span class="n">group</span><span class="p">),</span> <span class="n">group_ranks</span><span class="p">,</span> <span class="n">group</span><span class="o">.</span><span class="n">group_name</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="k">return</span> <span class="n">device_mesh</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expects at least one ProcessGroup to be passed&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must pass mesh if passing multiple ProcessGroups&quot;</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
                <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Expects mesh with ndim equal to number of ProcessGroups but got &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;mesh </span><span class="si">{</span><span class="n">mesh</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="si">}</span><span class="s2"> ProcessGroups&quot;</span>
                <span class="p">)</span>
            <span class="n">device_mesh</span> <span class="o">=</span> <span class="n">DeviceMesh</span><span class="p">(</span>
                <span class="n">device_type</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">mesh_dim_names</span><span class="o">=</span><span class="n">mesh_dim_names</span><span class="p">,</span> <span class="n">_init_backend</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="n">device_mesh</span><span class="o">.</span><span class="n">_dim_group_infos</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">_get_group_tag</span><span class="p">(</span><span class="n">group</span><span class="p">),</span>
                    <span class="n">get_process_group_ranks</span><span class="p">(</span><span class="n">group</span><span class="p">),</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">group_name</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="n">device_mesh</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span> <span class="k">if</span> <span class="n">mesh_dim</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">mesh_dim</span><span class="p">)</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span>

        <span class="nd">@property</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the current global rank.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">get_rank</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_local_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the local rank of the given mesh_dim of the DeviceMesh.</span>

<span class="sd">            Args:</span>
<span class="sd">                mesh_dim (str/int, optional): it can be the name of the mesh dimension or the index</span>
<span class="sd">                of the mesh dimension. Default is None.</span>

<span class="sd">            Returns:</span>
<span class="sd">                An integer denotes the local rank.</span>

<span class="sd">            The following program runs on each process/rank in an SPMD manner. In this example, we have 2</span>
<span class="sd">            hosts with 4 GPUs each.</span>
<span class="sd">            Calling mesh_2d.get_local_rank(mesh_dim=0) on rank 0, 1, 2, 3 would return 0.</span>
<span class="sd">            Calling mesh_2d.get_local_rank(mesh_dim=0) on rank 4, 5, 6, 7 would return 1.</span>
<span class="sd">            Calling mesh_2d.get_local_rank(mesh_dim=1) on rank 0, 4 would return 0.</span>
<span class="sd">            Calling mesh_2d.get_local_rank(mesh_dim=1) on rank 1, 5 would return 1.</span>
<span class="sd">            Calling mesh_2d.get_local_rank(mesh_dim=1) on rank 2, 6 would return 2.</span>
<span class="sd">            Calling mesh_2d.get_local_rank(mesh_dim=1) on rank 3, 7 would return 3.</span>

<span class="sd">            Example::</span>
<span class="sd">                &gt;&gt;&gt; # xdoctest: +SKIP(&quot;no rank&quot;)</span>
<span class="sd">                &gt;&gt;&gt; from torch.distributed.device_mesh import DeviceMesh</span>
<span class="sd">                &gt;&gt;&gt;</span>
<span class="sd">                &gt;&gt;&gt; # Initialize device mesh as (2, 4) to represent the topology</span>
<span class="sd">                &gt;&gt;&gt; # of cross-host(dim 0), and within-host (dim 1).</span>
<span class="sd">                &gt;&gt;&gt; mesh = DeviceMesh(device_type=&quot;cuda&quot;, mesh=[[0, 1, 2, 3],[4, 5, 6, 7]])</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">mesh_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Found the DeviceMesh have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;Optional kwarg `mesh_dim` needs to be specified when device_mesh.ndim &gt; 1.&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">mesh_dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mesh_dim</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">mesh_dim_group</span> <span class="o">=</span> <span class="n">not_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">mesh_dim</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">mesh_dim_group</span><span class="p">,</span> <span class="n">ProcessGroup</span>
            <span class="p">),</span> <span class="s2">&quot;We expect ProcessGroup before calling `get_rank`!&quot;</span>
            <span class="k">return</span> <span class="n">not_none</span><span class="p">(</span><span class="n">get_rank</span><span class="p">(</span><span class="n">mesh_dim_group</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return the relative indices of this rank relative to all</span>
<span class="sd">            dimensions of the mesh. If this rank is not part of the mesh, return None.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_on_dim</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coordinate_on_dim</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;DeviceMesh&quot;</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a 1D DeviceMesh by flattening the current DeviceMesh.</span>

<span class="sd">            If no mesh_dim_name is provided, the default is a string concatentaing the mesh_dim_names of the</span>
<span class="sd">            given submesh with each mesh_dim_name separated by &quot;_&quot;. For example, if we have a 3D mesh</span>
<span class="sd">            DeviceMesh([[[0, 1], [2, 3]], [[4, 5], [6, 7]]], mesh_dim_names=(&quot;dp&quot;, &quot;cp&quot;, &quot;tp&quot;)), calling</span>
<span class="sd">            mesh_3d[&quot;dp&quot;, &quot;cp&quot;]._flatten() will create a 1D submesh DeviceMesh([0, 1, 2, 3], mesh_dim_names=(&quot;dp_cp&quot;,))</span>
<span class="sd">            on rank 0, 1, 2, 3 and a 1D submesh DeviceMesh([4, 5, 6, 7], mesh_dim_names=(&quot;dp_cp&quot;,)) on rank 4, 5, 6, 7.</span>

<span class="sd">            After the flattened dimension is created, to access the flattened dimesnion in mesh_3d, one can use the</span>
<span class="sd">            existing slicing method to obtain the flattened mesh through calling mesh_3d[&quot;dp_cp&quot;].</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_dim_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Cannot flatten a DeviceMesh without mesh_dim_names!&quot;</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">_mesh_resources</span><span class="o">.</span><span class="n">create_flatten_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_dim_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="init_device_mesh">
<a class="viewcode-back" href="../../../python-api/distributed.html#torch.distributed.device_mesh.init_device_mesh">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_device_mesh</span><span class="p">(</span>
        <span class="n">device_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">mesh_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">mesh_dim_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DeviceMesh</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a `DeviceMesh` based on `device_type`, `mesh_shape`, and `mesh_dim_names` parameters.</span>

<span class="sd">        This creates a DeviceMesh with an n-dimensional array layout, where `n` is the length of `mesh_shape`.</span>
<span class="sd">        If `mesh_dim_names` is provided, each dimension is labeled as `mesh_dim_names[i]`.</span>

<span class="sd">        .. note::</span>
<span class="sd">            `init_device_mesh` follows SPMD programming model, meaning the same PyTorch Python program</span>
<span class="sd">            runs on all processes/ranks in the cluster. Ensure `mesh_shape` (the dimensions of the nD array</span>
<span class="sd">            describing device layout) is identical across all ranks. Inconsistent `mesh_shape` may lead to hanging.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If no process group is found, init_device_mesh will initialize distributed process group/groups</span>
<span class="sd">            required for distributed communications behind the scene.</span>

<span class="sd">        Args:</span>
<span class="sd">            device_type (str): The device type of the mesh. Currently supports: &quot;cpu&quot;, &quot;cuda/cuda-like&quot;.</span>
<span class="sd">                Passing in a device type with a GPU index, such as &quot;cuda:0&quot;, is not allowed.</span>
<span class="sd">            mesh_shape (Tuple[int]): A tuple defining the dimensions of the multi-dimensional array</span>
<span class="sd">                describing the layout of devices.</span>
<span class="sd">            mesh_dim_names (Tuple[str], optional): A tuple of mesh dimension names to assign to each dimension</span>
<span class="sd">                of the multi-dimensional array describing the layout of devices. Its length must match the length</span>
<span class="sd">                of `mesh_shape`. Each string in `mesh_dim_names` must be unique.</span>

<span class="sd">        Returns:</span>
<span class="sd">            DeviceMesh: A :class:`DeviceMesh` object representing the device layout.</span>

<span class="sd">        Example::</span>
<span class="sd">            &gt;&gt;&gt; # xdoctest: +SKIP(&quot;no rank&quot;)</span>
<span class="sd">            &gt;&gt;&gt; from torch.distributed.device_mesh import init_device_mesh</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; mesh_1d = init_device_mesh(&quot;cuda&quot;, mesh_shape=(8,))</span>
<span class="sd">            &gt;&gt;&gt; mesh_2d = init_device_mesh(&quot;cuda&quot;, mesh_shape=(2, 8), mesh_dim_names=(&quot;dp&quot;, &quot;tp&quot;))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mesh_dim_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Each mesh_dim_name must be unique.&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Found repeated mesh_dim_name in mesh_dim_names </span><span class="si">{</span><span class="n">mesh_dim_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;mesh_shape and mesh_dim_names should have same length!&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;Found len(mesh_dim_names): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_dim_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> and len(mesh_shape):</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># assume valid device types are all letters</span>
        <span class="k">if</span> <span class="n">device_type</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">device_type</span><span class="o">.</span><span class="n">isalpha</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Device type with index is not supported but got </span><span class="si">{</span><span class="n">device_type</span><span class="si">}</span><span class="s2">. &quot;</span><span class="p">,</span>
                <span class="s2">&quot;If you maintained a &#39;torch.device&#39; object, it&#39;s recommended to pass in &#39;device.type&#39;.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Always initialize the mesh&#39;s tensor on CPU, regardless of what the</span>
        <span class="c1"># external device type has been set to be (e.g. meta)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">):</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">mesh_shape</span><span class="p">)</span>
        <span class="n">device_mesh</span> <span class="o">=</span> <span class="n">DeviceMesh</span><span class="p">(</span>
            <span class="n">device_type</span><span class="o">=</span><span class="n">device_type</span><span class="p">,</span>
            <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span>
            <span class="n">mesh_dim_names</span><span class="o">=</span><span class="n">mesh_dim_names</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">device_mesh</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>



  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright PyTorch Contributors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>