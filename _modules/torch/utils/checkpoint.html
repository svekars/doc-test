
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>torch.utils.checkpoint &#8212; PyTorch main documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=949a1ff5" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/jit.css?v=8de1ea5d" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=3ccf5357" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom2.css?v=baa440dc" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=a8da1a53"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=940804e7"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs"></script>
    <script type="module">import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";import elkLayouts from "https://cdn.jsdelivr.net/npm/@mermaid-js/layout-elk@0.1.4/dist/mermaid-layout-elk.esm.min.mjs";mermaid.registerLayoutLoaders(elkLayouts);mermaid.initialize({startOnLoad:false});</script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7.9.0/dist/d3.min.js"></script>
    <script type="module">
import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11.2.0/dist/mermaid.esm.min.mjs";
window.addEventListener("load", () => mermaid.run());
</script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/torch/utils/checkpoint';</script>
    <script src="../../../_static/js/star-rating.js?v=8861fcb6"></script>
    <script src="../../../_static/js/send-feedback.js?v=5646bf45"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="main (2.6.0 )" />
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script type="text/javascript" src="../../../_static/js/send-feedback.js"></script>
<script type="text/javascript" src="../../../_static/js/star-rating.js"></script>
<script type="text/javascript" src="../../../_static/js/cookie-banner.js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-TEST12345"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-TEST12345');
    </script>

  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
<body data-feedback-url="https://github.com/pytorch/pytorch">
  <div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Learn
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Get Started</span>
                  <p>Run PyTorch locally or get started quickly with one of the supported cloud platforms</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tutorials</span>
                  <p>Whats new in PyTorch tutorials</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Learn the Basics</span>
                  <p>Familiarize yourself with PyTorch concepts and modules</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Recipes</span>
                  <p>Bite-size, ready-to-deploy PyTorch code examples</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                  <p>Master PyTorch basics with our engaging YouTube tutorial series</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Ecosystem
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tools</span>
                  <p>Learn about the tools and frameworks in the PyTorch Ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="" target="_blank">
                  <span class=dropdown-title>Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contributor Awards - 2024</span>
                  <p>Award winners announced at this year's PyTorch Conference</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">About PyTorch Edge</span>
                  <p>Build innovative and privacy-aware AI experiences for edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch</span>
                  <p>End-to-end solution for enabling on-device inference capabilities across mobile and edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch Docs</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch</span>
                  <p>Explore the documentation for comprehensive guidance on how to use PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Domains</span>
                  <p>Read the PyTorch Domains documentation to learn more about domain-specific libraries</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Blogs & News
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Blog</span>
                  <p>Catch up on the latest technical news and happenings</p>
                </a>
                 <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Blog</span>
                  <p>Stories from the PyTorch ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Videos</span>
                  <p>Learn about the latest PyTorch tutorials, new, and more </p>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Newsletter</span>
                  <p>Stay up-to-date with the latest updates</p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                About
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn more about the PyTorch Foundation</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contact Us</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown">
              <a href="" data-cta="join">
                Become a Member
              </a>
            </div>
          </li>
          <li>
           <div class="main-menu-item">
             <a href="" class="github-icon">
             </a>
           </div>
          </li>
          <!--- TODO: This block adds the search icon to the nav bar. We will enable it later.
          <li>
            <div class="main-menu-item">
             <a href="" class="search-icon">
             </a>
            </div>
          </li>
          --->
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Home</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../python-api/index.html">
    Python API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notes/index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://pytorch.org/tutorials/">
    Tutorials
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../python-api/index.html">
    Python API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notes/index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://pytorch.org/tutorials/">
    Tutorials
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-3"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-3"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-3"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-3">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    
    <li class="breadcrumb-item"><a href="../../torch.html" class="nav-link">torch</a></li>
    
    
    <li class="breadcrumb-item"><a href="../utils.html" class="nav-link">torch.utils</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">torch.utils.checkpoint</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-value="1">★</span>
        
        <span class="star" data-value="2">★</span>
        
        <span class="star" data-value="3">★</span>
        
        <span class="star" data-value="4">★</span>
        
        <span class="star" data-value="5">★</span>
        
    </div>
</div>
</div>
      
    </div>
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for torch.utils.checkpoint</h1><div class="highlight"><pre>
<span></span><span class="c1"># mypy: allow-untyped-decorators</span>
<span class="c1"># mypy: allow-untyped-defs</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">platform</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uuid</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">weakref</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>  <span class="c1"># noqa: F403</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">enum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">weakref</span><span class="w"> </span><span class="kn">import</span> <span class="n">ReferenceType</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.fx.traceback</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">fx_traceback</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch._functorch._aot_autograd.functional_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">is_fun</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.utils._pytree</span><span class="w"> </span><span class="kn">import</span> <span class="n">tree_map</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.testing._internal.logging_tensor</span><span class="w"> </span><span class="kn">import</span> <span class="n">capture_logs</span><span class="p">,</span> <span class="n">LoggingTensorMode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.utils._python_dispatch</span><span class="w"> </span><span class="kn">import</span> <span class="n">TorchDispatchMode</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;checkpoint&quot;</span><span class="p">,</span>
    <span class="s2">&quot;checkpoint_sequential&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CheckpointError&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CheckpointFunction&quot;</span><span class="p">,</span>
    <span class="s2">&quot;check_backward_validity&quot;</span><span class="p">,</span>
    <span class="s2">&quot;detach_variable&quot;</span><span class="p">,</span>
    <span class="s2">&quot;get_device_states&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_device_states&quot;</span><span class="p">,</span>
    <span class="s2">&quot;noop_context_fn&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_checkpoint_early_stop&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DefaultDeviceType&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_checkpoint_debug_enabled&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CheckpointPolicy&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SelectiveCheckpointContext&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_selective_checkpoint_contexts&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SAC_IGNORED_OPS&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_DEFAULT_DETERMINISM_MODE</span> <span class="o">=</span> <span class="s2">&quot;default&quot;</span>

<span class="n">_checkpoint_debug_enabled</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="set_checkpoint_debug_enabled">
<a class="viewcode-back" href="../../../python-api/checkpoint.html#torch.utils.checkpoint.set_checkpoint_debug_enabled">[docs]</a>
<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_checkpoint_debug_enabled</span><span class="p">(</span><span class="n">enabled</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Context manager that sets whether checkpoint should print additional debug</span>
<span class="sd">    information when running. See the ``debug`` flag for</span>
<span class="sd">    :func:`~torch.utils.checkpoint.checkpoint` for more information. Note that</span>
<span class="sd">    when set, this context manager overrides the value of ``debug`` passed to</span>
<span class="sd">    checkpoint. To defer to the local setting, pass ``None`` to this context.</span>

<span class="sd">    Args:</span>
<span class="sd">        enabled (bool): Whether checkpoint should print debug information.</span>
<span class="sd">            Default is &#39;None&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_checkpoint_debug_enabled</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">_checkpoint_debug_enabled</span>
        <span class="n">_checkpoint_debug_enabled</span> <span class="o">=</span> <span class="n">enabled</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">_checkpoint_debug_enabled</span> <span class="o">=</span> <span class="n">prev</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">detach_variable</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
            <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">requires_grad</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;Only tuple of tensors is supported. Got Unsupported input type: &quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">check_backward_validity</span><span class="p">(</span><span class="n">inputs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">requires_grad</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;None of the inputs have requires_grad=True. Gradients will be None&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_device_module</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">device</span> <span class="o">==</span> <span class="s2">&quot;meta&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;meta&quot;</span><span class="p">)</span>
    <span class="n">device_module</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">torch</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">device_module</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DefaultDeviceType</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that manages the default device type for checkpointing.</span>

<span class="sd">    If no non-CPU tensors are present, the default device type will</span>
<span class="sd">    be used. The default value is &#39;cuda&#39;. The device type is used in</span>
<span class="sd">    the checkpointing process when determining which device states</span>
<span class="sd">    to save and restore for recomputation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_default_device_type</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_device_type</span><span class="p">(</span><span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the default device type for checkpointing.</span>

<span class="sd">        Args:</span>
<span class="sd">            device (str): The device type to be set as default. Default is &#39;cuda&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DefaultDeviceType</span><span class="o">.</span><span class="n">_default_device_type</span> <span class="o">=</span> <span class="n">device</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_device_type</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the current default device type for checkpointing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The current default device type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DefaultDeviceType</span><span class="o">.</span><span class="n">_default_device_type</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_infer_device_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">device_types</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_device_types</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">device_types</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;cpu&quot;</span><span class="p">:</span>
            <span class="n">device_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
    <span class="n">tree_map</span><span class="p">(</span><span class="n">add_device_types</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="n">device_types_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">device_types</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_types_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Tensor arguments, excluding CPU tensors, are detected on at least two types of devices. &quot;</span>
            <span class="s2">&quot;Device state will only be saved for devices of a single device type, and the remaining &quot;</span>
            <span class="s2">&quot;devices will be ignored. Consequently, if any checkpointed functions involve randomness, &quot;</span>
            <span class="s2">&quot;this may result in incorrect gradients. (Note that if CUDA devices are among the devices &quot;</span>
            <span class="s2">&quot;detected, it will be prioritized; otherwise, the first device encountered will be selected.)&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Device types: </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">device_types_set</span><span class="p">)</span><span class="si">}</span><span class="s2"> first device type: </span><span class="si">{</span><span class="n">device_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">device_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DefaultDeviceType</span><span class="o">.</span><span class="n">get_device_type</span><span class="p">()</span>
    <span class="k">elif</span> <span class="s2">&quot;cuda&quot;</span> <span class="ow">in</span> <span class="n">device_types_set</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;cuda&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">device_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="c1"># We can&#39;t know if the run_fn will internally move some args to different devices,</span>
<span class="c1"># which would require logic to preserve rng states for those devices as well.</span>
<span class="c1"># We could paranoically stash and restore ALL the rng states for all visible devices,</span>
<span class="c1"># but that seems very wasteful for most cases.  Compromise:  Stash the RNG state for</span>
<span class="c1"># the device of all Tensor args.</span>
<span class="c1">#</span>
<span class="c1"># To consider:  maybe get_device_states and set_device_states should reside in torch/random.py?</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_device_states</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]:</span>
    <span class="c1"># This will not error out if &quot;arg&quot; is a CPU tensor or a non-tensor type because</span>
    <span class="c1"># the conditionals short-circuit.</span>
    <span class="n">fwd_device_ids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_device_ids</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">fwd_device_ids</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="s2">&quot;meta&quot;</span><span class="p">}:</span>
            <span class="n">fwd_device_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="o">.</span><span class="n">get_device</span><span class="p">())</span>
    <span class="n">tree_map</span><span class="p">(</span><span class="n">add_device_ids</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="n">fwd_device_states</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">device_module</span> <span class="o">=</span> <span class="n">_get_device_module</span><span class="p">(</span><span class="n">_infer_device_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">device_id</span> <span class="ow">in</span> <span class="n">fwd_device_ids</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">device_module</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device_id</span><span class="p">):</span>
            <span class="n">fwd_device_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">device_module</span><span class="o">.</span><span class="n">get_rng_state</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">fwd_device_ids</span><span class="p">,</span> <span class="n">fwd_device_states</span>


<span class="k">def</span><span class="w"> </span><span class="nf">set_device_states</span><span class="p">(</span><span class="n">devices</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">device_type</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sets random number generator states for the specified devices.</span>

<span class="sd">    Args:</span>
<span class="sd">        devices: Device ids to set states for.</span>
<span class="sd">        states: States to set.</span>
<span class="sd">        device_type: ``device_type`` of the devices to set states for. Default</span>
<span class="sd">            is the device returned by a call to ``DefaultDeviceType.get_device_type()``,</span>
<span class="sd">            which is ``cuda`` if not changed by calling ``DefaultDeviceType::set_device_type()``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">device_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">device_type</span> <span class="o">=</span> <span class="n">DefaultDeviceType</span><span class="o">.</span><span class="n">get_device_type</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">device_type</span> <span class="o">==</span> <span class="s2">&quot;meta&quot;</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">device_module</span> <span class="o">=</span> <span class="n">_get_device_module</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">device</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">devices</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">device_module</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="n">device</span><span class="p">):</span>
            <span class="n">device_module</span><span class="o">.</span><span class="n">set_rng_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_autocast_kwargs</span><span class="p">(</span><span class="n">device_type</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">is_autocast_available</span><span class="p">(</span><span class="n">device_type</span><span class="p">):</span>
        <span class="n">device_autocast_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;enabled&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_autocast_enabled</span><span class="p">(</span><span class="n">device_type</span><span class="p">),</span>
            <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">get_autocast_dtype</span><span class="p">(</span><span class="n">device_type</span><span class="p">),</span>
            <span class="s2">&quot;cache_enabled&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_autocast_cache_enabled</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">device_autocast_kwargs</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">cpu_autocast_kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;enabled&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_autocast_enabled</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">),</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">get_autocast_dtype</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">),</span>
        <span class="s2">&quot;cache_enabled&quot;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_autocast_cache_enabled</span><span class="p">(),</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">device_autocast_kwargs</span><span class="p">,</span> <span class="n">cpu_autocast_kwargs</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CheckpointFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">run_function</span><span class="p">,</span> <span class="n">preserve_rng_state</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">check_backward_validity</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">run_function</span> <span class="o">=</span> <span class="n">run_function</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">preserve_rng_state</span> <span class="o">=</span> <span class="n">preserve_rng_state</span>
        <span class="c1"># Accommodates the (remote) possibility that autocast is enabled for cpu AND gpu.</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span> <span class="o">=</span> <span class="n">_infer_device_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">device_autocast_kwargs</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">cpu_autocast_kwargs</span> <span class="o">=</span> <span class="n">_get_autocast_kwargs</span><span class="p">(</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">preserve_rng_state</span><span class="p">:</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">fwd_cpu_state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">get_rng_state</span><span class="p">()</span>
            <span class="c1"># Don&#39;t eagerly initialize the cuda context by accident.</span>
            <span class="c1"># (If the user intends that the context is initialized later, within their</span>
            <span class="c1"># run_function, we SHOULD actually stash the cuda state here.  Unfortunately,</span>
            <span class="c1"># we have no way to anticipate this will happen before we run the function.)</span>
            <span class="n">ctx</span><span class="o">.</span><span class="n">had_device_in_fwd</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">device_module</span> <span class="o">=</span> <span class="n">_get_device_module</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">device_module</span><span class="p">,</span> <span class="s2">&quot;_initialized&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">had_device_in_fwd</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">fwd_devices</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">fwd_device_states</span> <span class="o">=</span> <span class="n">get_device_states</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Save non-tensor inputs in ctx, keep a placeholder None for tensors</span>
        <span class="c1"># to be filled out during the backward.</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">tensor_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tensor_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                <span class="n">tensor_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">tensor_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ctx</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="o">*</span><span class="n">tensor_inputs</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="n">run_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">outputs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">_is_checkpoint_valid</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;When use_reentrant=True, torch.utils.checkpoint is incompatible&quot;</span>
                <span class="s2">&quot; with .grad() or passing an `inputs` parameter to .backward().&quot;</span>
                <span class="s2">&quot; To resolve this error, you can either set use_reentrant=False,&quot;</span>
                <span class="s2">&quot; or call .backward() without passing the `inputs` argument.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Copy the list to avoid modifying original list.</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">tensor_indices</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">tensor_indices</span>
        <span class="n">tensors</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span>

        <span class="c1"># Fill in inputs with appropriate saved tensors.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_indices</span><span class="p">):</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Stash the surrounding rng state, and mimic the state that was</span>
        <span class="c1"># present at this time during forward.  Restore the surrounding state</span>
        <span class="c1"># when we&#39;re done.</span>
        <span class="n">rng_devices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">preserve_rng_state</span> <span class="ow">and</span> <span class="n">ctx</span><span class="o">.</span><span class="n">had_device_in_fwd</span><span class="p">:</span>
            <span class="n">rng_devices</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">fwd_devices</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">fork_rng</span><span class="p">(</span>
            <span class="n">devices</span><span class="o">=</span><span class="n">rng_devices</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="n">ctx</span><span class="o">.</span><span class="n">preserve_rng_state</span><span class="p">,</span> <span class="n">device_type</span><span class="o">=</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">preserve_rng_state</span><span class="p">:</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">set_rng_state</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">fwd_cpu_state</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">had_device_in_fwd</span><span class="p">:</span>
                    <span class="n">set_device_states</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">fwd_devices</span><span class="p">,</span> <span class="n">ctx</span><span class="o">.</span><span class="n">fwd_device_states</span><span class="p">,</span> <span class="n">device_type</span><span class="o">=</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span><span class="p">)</span>
            <span class="n">detached_inputs</span> <span class="o">=</span> <span class="n">detach_variable</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>

            <span class="n">device_autocast_ctx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">(</span>
                <span class="n">device_type</span><span class="o">=</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_autocast_kwargs</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">is_autocast_available</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">device_type</span><span class="p">)</span> <span class="k">else</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">nullcontext</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">enable_grad</span><span class="p">(),</span> <span class="n">device_autocast_ctx</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">ctx</span><span class="o">.</span><span class="n">cpu_autocast_kwargs</span><span class="p">):</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">run_function</span><span class="p">(</span><span class="o">*</span><span class="n">detached_inputs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

        <span class="c1"># run backward() with only tensor that requires grad</span>
        <span class="n">outputs_with_grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">args_with_grad</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outputs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_tensor</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">:</span>
                <span class="n">outputs_with_grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">args_with_grad</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputs_with_grad</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;none of output has requires_grad=True,&quot;</span>
                <span class="s2">&quot; this checkpoint() is not necessary&quot;</span>
            <span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">outputs_with_grad</span><span class="p">,</span> <span class="n">args_with_grad</span><span class="p">)</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">inp</span><span class="o">.</span><span class="n">grad</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">detached_inputs</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">+</span> <span class="n">grads</span>


<span class="k">def</span><span class="w"> </span><span class="nf">noop_context_fn</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">nullcontext</span><span class="p">(),</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">nullcontext</span><span class="p">()</span>

<span class="c1"># TorchDynamo does not step inside utils.checkpoint function.  The flow</span>
<span class="c1"># looks likes this</span>
<span class="c1">#  1) TorchDynamo tries to wrap utils.checkpoint in a HigherOrderOp by</span>
<span class="c1">#     speculatively checking if the forward function is safe to trace.</span>
<span class="c1">#  2) If yes, then Dynamo-generated Fx graph has the wrapped higher</span>
<span class="c1">#     order op. As a result, TorchDynamo does not look inside utils.checkpoint.</span>
<span class="c1">#  3) If not, then TorchDynamo falls back to eager by performing a graph</span>
<span class="c1">#     break. And here, the following disable wrapper ensures that</span>
<span class="c1">#     TorchDynamo does not trigger again on the frames created by</span>
<span class="c1">#     utils.checkpoint innards.</span>
<div class="viewcode-block" id="checkpoint">
<a class="viewcode-back" href="../../../python-api/checkpoint.html#torch.utils.checkpoint.checkpoint">[docs]</a>
<span class="nd">@torch</span><span class="o">.</span><span class="n">_disable_dynamo</span>
<span class="k">def</span><span class="w"> </span><span class="nf">checkpoint</span><span class="p">(</span>
    <span class="n">function</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">use_reentrant</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">context_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ContextManager</span><span class="p">,</span> <span class="n">ContextManager</span><span class="p">]]</span> <span class="o">=</span> <span class="n">noop_context_fn</span><span class="p">,</span>
    <span class="n">determinism_check</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">_DEFAULT_DETERMINISM_MODE</span><span class="p">,</span>
    <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checkpoint a model or part of the model.</span>

<span class="sd">    Activation checkpointing is a technique that trades compute for memory.</span>
<span class="sd">    Instead of keeping tensors needed for backward alive until they are used in</span>
<span class="sd">    gradient computation during backward, forward computation in checkpointed</span>
<span class="sd">    regions omits saving tensors for backward and recomputes them during the</span>
<span class="sd">    backward pass. Activation checkpointing can be applied to any part of a</span>
<span class="sd">    model.</span>

<span class="sd">    There are currently two checkpointing implementations available, determined</span>
<span class="sd">    by the :attr:`use_reentrant` parameter. It is recommended that you use</span>
<span class="sd">    ``use_reentrant=False``. Please refer the note below for a discussion of</span>
<span class="sd">    their differences.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        If the :attr:`function` invocation during the backward pass differs</span>
<span class="sd">        from the forward pass, e.g., due to a global variable, the checkpointed</span>
<span class="sd">        version may not be equivalent, potentially causing an</span>
<span class="sd">        error being raised or leading to silently incorrect gradients.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        The ``use_reentrant`` parameter should be passed explicitly. In version</span>
<span class="sd">        2.4 we will raise an exception if ``use_reentrant`` is not passed.</span>
<span class="sd">        If you are using the ``use_reentrant=True`` variant, please refer to the</span>
<span class="sd">        note below for important considerations and potential limitations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The reentrant variant of checkpoint (``use_reentrant=True``) and</span>
<span class="sd">        the non-reentrant variant of checkpoint (``use_reentrant=False``)</span>
<span class="sd">        differ in the following ways:</span>

<span class="sd">        * Non-reentrant checkpoint stops recomputation as soon as all needed</span>
<span class="sd">          intermediate activations have been recomputed. This feature is enabled</span>
<span class="sd">          by default, but can be disabled with :func:`set_checkpoint_early_stop`.</span>
<span class="sd">          Reentrant checkpoint always recomputes :attr:`function` in its</span>
<span class="sd">          entirety during the backward pass.</span>

<span class="sd">        * The reentrant variant does not record the autograd graph during the</span>
<span class="sd">          forward pass, as it runs with the forward pass under</span>
<span class="sd">          :func:`torch.no_grad`. The non-reentrant version does record the</span>
<span class="sd">          autograd graph, allowing one to perform backward on the graph within</span>
<span class="sd">          checkpointed regions.</span>

<span class="sd">        * The reentrant checkpoint only supports the</span>
<span class="sd">          :func:`torch.autograd.backward` API for the backward pass without its</span>
<span class="sd">          `inputs` argument, while the non-reentrant version supports all ways</span>
<span class="sd">          of performing the backward pass.</span>

<span class="sd">        * At least one input and output must have ``requires_grad=True`` for the</span>
<span class="sd">          reentrant variant. If this condition is unmet, the checkpointed part</span>
<span class="sd">          of the model will not have gradients. The non-reentrant version does</span>
<span class="sd">          not have this requirement.</span>

<span class="sd">        * The reentrant version does not consider tensors in nested structures</span>
<span class="sd">          (e.g., custom objects, lists, dicts, etc) as participating in</span>
<span class="sd">          autograd, while the non-reentrant version does.</span>

<span class="sd">        * The reentrant checkpoint does not support checkpointed regions with</span>
<span class="sd">          detached tensors from the computational graph, whereas the</span>
<span class="sd">          non-reentrant version does. For the reentrant variant, if the</span>
<span class="sd">          checkpointed segment contains tensors detached using ``detach()`` or</span>
<span class="sd">          with :func:`torch.no_grad`, the backward pass will raise an error.</span>
<span class="sd">          This is because ``checkpoint`` makes all the outputs require gradients</span>
<span class="sd">          and this causes issues when a tensor is defined to have no gradient in</span>
<span class="sd">          the model. To avoid this, detach the tensors outside of the</span>
<span class="sd">          ``checkpoint`` function.</span>

<span class="sd">    Args:</span>
<span class="sd">        function: describes what to run in the forward pass of the model or</span>
<span class="sd">            part of the model. It should also know how to handle the inputs</span>
<span class="sd">            passed as the tuple. For example, in LSTM, if user passes</span>
<span class="sd">            ``(activation, hidden)``, :attr:`function` should correctly use the</span>
<span class="sd">            first input as ``activation`` and the second input as ``hidden``</span>
<span class="sd">        preserve_rng_state(bool, optional):  Omit stashing and restoring</span>
<span class="sd">            the RNG state during each checkpoint. Note that under torch.compile,</span>
<span class="sd">            this flag doesn&#39;t take effect and we always preserve RNG state.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        use_reentrant(bool):</span>
<span class="sd">            specify whether to use the activation checkpoint variant that</span>
<span class="sd">            requires reentrant autograd. This parameter should be passed</span>
<span class="sd">            explicitly. In version 2.5 we will raise an exception if</span>
<span class="sd">            ``use_reentrant`` is not passed. If ``use_reentrant=False``,</span>
<span class="sd">            ``checkpoint`` will use an implementation that does not require</span>
<span class="sd">            reentrant autograd. This allows ``checkpoint`` to support additional</span>
<span class="sd">            functionality, such as working as expected with</span>
<span class="sd">            ``torch.autograd.grad`` and support for keyword arguments input into</span>
<span class="sd">            the checkpointed function.</span>
<span class="sd">        context_fn(Callable, optional): A callable returning a tuple of two</span>
<span class="sd">            context managers. The function and its recomputation will be run</span>
<span class="sd">            under the first and second context managers respectively.</span>
<span class="sd">            This argument is only supported if ``use_reentrant=False``.</span>
<span class="sd">        determinism_check(str, optional): A string specifying the determinism</span>
<span class="sd">            check to perform. By default it is set to ``&quot;default&quot;`` which</span>
<span class="sd">            compares the shapes, dtypes, and devices of the recomputed tensors</span>
<span class="sd">            against those the saved tensors. To turn off this check, specify</span>
<span class="sd">            ``&quot;none&quot;``. Currently these are the only two supported values.</span>
<span class="sd">            Please open an issue if you would like to see more determinism</span>
<span class="sd">            checks. This argument is only supported if ``use_reentrant=False``,</span>
<span class="sd">            if ``use_reentrant=True``, the determinism check is always disabled.</span>
<span class="sd">        debug(bool, optional): If ``True``, error messages will also include</span>
<span class="sd">            a trace of the operators ran during the original forward computation</span>
<span class="sd">            as well as the recomputation. This argument is only supported if</span>
<span class="sd">            ``use_reentrant=False``.</span>
<span class="sd">        args: tuple containing inputs to the :attr:`function`</span>

<span class="sd">    Returns:</span>
<span class="sd">        Output of running :attr:`function` on :attr:`*args`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_reentrant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;torch.utils.checkpoint: the use_reentrant parameter should be &quot;</span>
            <span class="s2">&quot;passed explicitly. In version 2.5 we will raise an exception &quot;</span>
            <span class="s2">&quot;if use_reentrant is not passed. use_reentrant=False is &quot;</span>
            <span class="s2">&quot;recommended, but if you need to preserve the current default &quot;</span>
            <span class="s2">&quot;behavior, you can pass use_reentrant=True. Refer to docs for more &quot;</span>
            <span class="s2">&quot;details on the differences between the two variants.&quot;</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">use_reentrant</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Hack to mix *args with **kwargs in a python 2.7-compliant way</span>
    <span class="n">preserve</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;preserve_rng_state&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">use_reentrant</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unexpected keyword arguments: &quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">use_reentrant</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">context_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">noop_context_fn</span> <span class="ow">or</span> <span class="n">debug</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Passing `context_fn` or `debug` is only supported when &quot;</span>
                <span class="s2">&quot;use_reentrant=False.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">CheckpointFunction</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">preserve</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gen</span> <span class="o">=</span> <span class="n">_checkpoint_without_reentrant_generator</span><span class="p">(</span>
            <span class="n">function</span><span class="p">,</span> <span class="n">preserve</span><span class="p">,</span> <span class="n">context_fn</span><span class="p">,</span> <span class="n">determinism_check</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="c1"># Runs pre-forward logic</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Runs post-forward logic</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="checkpoint_sequential">
<a class="viewcode-back" href="../../../python-api/checkpoint.html#torch.utils.checkpoint.checkpoint_sequential">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">checkpoint_sequential</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">segments</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">use_reentrant</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Checkpoint a sequential model to save memory.</span>

<span class="sd">    Sequential models execute a list of modules/functions in order</span>
<span class="sd">    (sequentially). Therefore, we can divide such a model in various segments</span>
<span class="sd">    and checkpoint each segment. All segments except the last will not store</span>
<span class="sd">    the intermediate activations. The inputs of each checkpointed segment will</span>
<span class="sd">    be saved for re-running the segment in the backward pass.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        The ``use_reentrant`` parameter should be passed explicitly. In version</span>
<span class="sd">        2.4 we will raise an exception if ``use_reentrant`` is not passed.</span>
<span class="sd">        If you are using the ``use_reentrant=True` variant, please see</span>
<span class="sd">        :func:`~torch.utils.checkpoint.checkpoint` for</span>
<span class="sd">        the important considerations and limitations of this variant. It is</span>
<span class="sd">        recommended that you use ``use_reentrant=False``.</span>

<span class="sd">    .. warning:</span>
<span class="sd">        Since PyTorch 1.4, it allows only one Tensor as the input and</span>
<span class="sd">        intermediate outputs, just like :class:`torch.nn.Sequential`.</span>

<span class="sd">    Args:</span>
<span class="sd">        functions: A :class:`torch.nn.Sequential` or the list of modules or</span>
<span class="sd">            functions (comprising the model) to run sequentially.</span>
<span class="sd">        segments: Number of chunks to create in the model</span>
<span class="sd">        input: A Tensor that is input to :attr:`functions`</span>
<span class="sd">        preserve_rng_state(bool, optional):  Omit stashing and restoring</span>
<span class="sd">            the RNG state during each checkpoint.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        use_reentrant(bool):</span>
<span class="sd">            specify whether to use the activation checkpoint variant that</span>
<span class="sd">            requires reentrant autograd. This parameter should be passed</span>
<span class="sd">            explicitly. In version 2.5 we will raise an exception if</span>
<span class="sd">            ``use_reentrant`` is not passed. If ``use_reentrant=False``,</span>
<span class="sd">            ``checkpoint`` will use an implementation that does not require</span>
<span class="sd">            reentrant autograd. This allows ``checkpoint`` to support additional</span>
<span class="sd">            functionality, such as working as expected with</span>
<span class="sd">            ``torch.autograd.grad`` and support for keyword arguments input into</span>
<span class="sd">            the checkpointed function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Output of running :attr:`functions` sequentially on :attr:`*inputs`</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +SKIP(&quot;stub&quot;)</span>
<span class="sd">        &gt;&gt;&gt; model = nn.Sequential(...)</span>
<span class="sd">        &gt;&gt;&gt; input_var = checkpoint_sequential(model, chunks, input_var)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">use_reentrant</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;torch.utils.checkpoint.checkpoint_sequential: the use_reentrant &quot;</span>
            <span class="s2">&quot;parameter should be passed explicitly. &quot;</span>
            <span class="s2">&quot;In version 2.5 we will raise an exception if use_reentrant &quot;</span>
            <span class="s2">&quot;is not passed. use_reentrant=False is &quot;</span>
            <span class="s2">&quot;recommended, but if you need to preserve the current default &quot;</span>
            <span class="s2">&quot;behavior, you can pass use_reentrant=True. Refer to docs for more &quot;</span>
            <span class="s2">&quot;details on the differences between the two variants.&quot;</span>
        <span class="p">)</span>
        <span class="n">use_reentrant</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Hack for keyword-only parameter in a python 2.7-compliant way</span>
    <span class="n">preserve</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;preserve_rng_state&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unexpected keyword arguments: &quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run_function</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">functions</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="nb">input</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[</span><span class="n">j</span><span class="p">](</span><span class="nb">input</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">input</span>

        <span class="k">return</span> <span class="n">forward</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">):</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">functions</span><span class="o">.</span><span class="n">children</span><span class="p">())</span>

    <span class="n">segment_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">//</span> <span class="n">segments</span>
    <span class="c1"># the last chunk has to be non-volatile</span>
    <span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">segment_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">segments</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">segment_size</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">segment_size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="nb">input</span> <span class="o">=</span> <span class="n">checkpoint</span><span class="p">(</span>
            <span class="n">run_function</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">functions</span><span class="p">),</span>
            <span class="nb">input</span><span class="p">,</span>
            <span class="n">use_reentrant</span><span class="o">=</span><span class="n">use_reentrant</span><span class="p">,</span>
            <span class="n">preserve_rng_state</span><span class="o">=</span><span class="n">preserve</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">run_function</span><span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">functions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">functions</span><span class="p">)(</span><span class="nb">input</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_internal_assert</span><span class="p">(</span><span class="n">cond</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="s2">&quot;Something went unexpectedly wrong in activation checkpoint. &quot;</span>
            <span class="s2">&quot;Please report this bug by filing an issue to PyTorch.&quot;</span>
        <span class="p">)</span>


<span class="c1"># NOTE [ Nestable Checkpoint ]</span>
<span class="c1">#</span>
<span class="c1"># The semantics of nested checkpoint can be defined by two basic rules.</span>
<span class="c1"># Following the two rules leads to an important implication that is central</span>
<span class="c1"># to motivating the design.</span>
<span class="c1">#</span>
<span class="c1"># Rule 1. Saved tensors are managed by inner-most checkpoint only and hidden</span>
<span class="c1">#         from any outer layers of checkpoint.</span>
<span class="c1">#</span>
<span class="c1"># Rule 2. The inputs of inner checkpoints are treated as tensors saved to its</span>
<span class="c1">#         parent checkpoint.</span>
<span class="c1">#</span>
<span class="c1"># Implication: To recompute any given saved tensor, we need to recompute all of</span>
<span class="c1">#              the checkpoints wrapping it.</span>
<span class="c1">#</span>
<span class="c1"># Why is this implied? To unpack a saved tensor X during backward we need to</span>
<span class="c1"># recompute the inner-most checkpoint (#1), and in order to recompute that</span>
<span class="c1"># checkpoint I need to have its inputs, which are managed by that checkpoint&#39;s</span>
<span class="c1"># parent (#2), which thus also needs to be recomputed first. Continue this line</span>
<span class="c1"># of reasoning and we realize that in order to unpack X, all checkpoints that</span>
<span class="c1"># were active at the time X was saved need to be recomputed. (unless we have</span>
<span class="c1"># already done so in that backward for some other saved tensor).</span>
<span class="c1">#</span>
<span class="c1"># In practice, we use a noop autograd Function to save inputs as saved tensors.</span>
<span class="c1"># During unpack calling ctx.saved_tensor triggers the parent checkpoint to</span>
<span class="c1"># recompute.</span>
<span class="c1">#</span>
<span class="c1"># Rule 3. We should start recomputation as if there are no checkpoints currently</span>
<span class="c1">#         active. Checkpoints encountered during recomputation are still</span>
<span class="c1">#         respected.</span>
<span class="c1">#</span>
<span class="c1"># When we start recomputation, we push the saved variable hook meant for</span>
<span class="c1"># recomputation on the stack. See examples in Rule 6 for more context.</span>
<span class="c1">#</span>
<span class="c1">#                                  * * * *</span>
<span class="c1">#</span>
<span class="c1"># Beyond the basic semantics specific to nested checkpoint, we impose several</span>
<span class="c1"># more constraints that may apply to checkpointing in general.</span>
<span class="c1">#</span>
<span class="c1"># Rule 4. Lifetime of recomputed tensors</span>
<span class="c1">#</span>
<span class="c1">#         Recomputed tensors are considered specific to particular invocations</span>
<span class="c1">#         of backward and are always cleared immediately as they are unpacked</span>
<span class="c1">#         Particularly, we require this to happen even if retain_graph=True.</span>
<span class="c1">#</span>
<span class="c1"># [ Implementation details of Rule 4 ]</span>
<span class="c1">#</span>
<span class="c1"># If we were okay with recomputed tensors staying alive after backward is run</span>
<span class="c1"># with retain_graph=True, we would store recomputed variables as the values of a</span>
<span class="c1"># WeakKeyDictionary and pack strong references to the keys, so that as we</span>
<span class="c1"># backward, those packed keys would be cleared as long as retain_graph=False.</span>
<span class="c1"># Clearing the packed key clears the corresponding entry in the WKD.</span>
<span class="c1">#</span>
<span class="c1"># If we wish recomputed variables to be immediately cleared as we unpack them in</span>
<span class="c1"># the retain_graph=True case, we cannot rely on the packed keys to be cleared by</span>
<span class="c1"># backward automatically. Instead of packing the strong reference to the key</span>
<span class="c1"># directly, we pack a container object, which we manually clear as we unpack.</span>
<span class="c1">#</span>
<span class="c1"># An important detail is that if a second backward happens, the second</span>
<span class="c1"># recomputation needs to reset the container with a newly created key.</span>
<span class="c1">#</span>
<span class="c1"># Rule 5. Stop recomputation as soon as we&#39;ve recomputed the saved tensors we</span>
<span class="c1">#         know we need.</span>
<span class="c1">#</span>
<span class="c1"># [ Implementation details of Rule 5 ]</span>
<span class="c1">#</span>
<span class="c1"># During recomputation, raise an exception if the number of recomputed tensors</span>
<span class="c1"># matches the number of tensors that we expected to recompute. We wrap the</span>
<span class="c1"># recomputation call with a try-catch to catch this specific exception. See</span>
<span class="c1"># Rule #6 below for some examples.</span>
<span class="c1">#</span>
<span class="c1"># Rule 6. We support doing backward inside checkpoint context</span>
<span class="c1">#</span>
<span class="c1"># [ retain_graph is True]</span>
<span class="c1">#</span>
<span class="c1"># def fn(x):</span>
<span class="c1">#   y = x.sin()</span>
<span class="c1">#   z = y.cos()</span>
<span class="c1">#   gx, = torch.autograd.grad(z, x, retains_grad=True)</span>
<span class="c1">#   return gx, z</span>
<span class="c1">#</span>
<span class="c1"># out = checkpoint(fn)(inp)</span>
<span class="c1"># out.backward()</span>
<span class="c1">#</span>
<span class="c1"># Because z is saved by cos while checkpoint is enabled, it would not be</span>
<span class="c1"># actually saved, and so the .grad() call inside must trigger a recomputation.</span>
<span class="c1">#</span>
<span class="c1"># During recomputation the &quot;inner pack hook&quot; has two responsibilities:</span>
<span class="c1">#</span>
<span class="c1"># 1) As usual, populating the WeakKeyDictionary storing recomputed tensors</span>
<span class="c1"># 2) Pack the actual tensor (detached) so that one may perform backward on the</span>
<span class="c1">#    recomputed graph. The tensors saved to this graph will live until the end</span>
<span class="c1">#    of recomputation, or die earlier if someone performs backward with</span>
<span class="c1">#    retain_graph=False.</span>
<span class="c1">#</span>
<span class="c1"># More generally performing backward on the recomputed graph occurs in the</span>
<span class="c1"># following cases:</span>
<span class="c1"># - If backward is performed inside forward,</span>
<span class="c1">#   - During the original forward IF early-stop is disabled</span>
<span class="c1">#   - During the original backward</span>
<span class="c1"># - If there are multiple .grad()/.backward() calls, we would perform backward</span>
<span class="c1">#   on the recomputed graph even if early-stop is enabled (see the example below)</span>
<span class="c1">#</span>
<span class="c1"># [ retain_graph is False ]</span>
<span class="c1">#</span>
<span class="c1"># The example below shows what happens if during recomputation we find that some</span>
<span class="c1"># of the tensors we are trying to recompute have already been cleared.</span>
<span class="c1">#</span>
<span class="c1"># Spoiler: we don&#39;t do anything special, we just skip over them!</span>
<span class="c1">#</span>
<span class="c1"># def fn(x):</span>
<span class="c1">#   y = x.sin()                           # (1)</span>
<span class="c1">#   z = y.cos()                           # (2)</span>
<span class="c1">#   gx, = torch.autograd.grad(z, x)       # (3)</span>
<span class="c1">#   return x.cos() * gx                   # (4)</span>
<span class="c1">#</span>
<span class="c1"># out = checkpoint(fn)(inp)</span>
<span class="c1"># out.backward()                          # (5)</span>
<span class="c1">#</span>
<span class="c1"># 1, 2. Don&#39;t save x and y since we are inside a checkpoint.</span>
<span class="c1"># 3. Trigger a recompute of fn since x and y weren&#39;t saved.</span>
<span class="c1">#    And depending on whether early stop is enabled, either stop at (2) or</span>
<span class="c1">#    continue running the function.</span>
<span class="c1">#    Because we are running backward with retain_graph=False, we clear x and y&#39;s</span>
<span class="c1">#    holders.</span>
<span class="c1"># 4. Don&#39;t save x since we are inside a checkpoint.</span>
<span class="c1"># 5. Calling backward triggers another recompute of fn. During recompute, we see</span>
<span class="c1">#    that x and y have already been cleared in the original graph as indicated</span>
<span class="c1">#    by holder=None. We skip over them. We still save x at (4) (since its holder</span>
<span class="c1">#    is still alive.)</span>

<span class="n">_enable_checkpoint_early_stop</span> <span class="o">=</span> <span class="kc">True</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span><span class="w"> </span><span class="nf">set_checkpoint_early_stop</span><span class="p">(</span><span class="n">enable</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context manager that sets whether checkpoint should stop recomputation early.</span>

<span class="sd">    By default, non-reentrant checkpoint stops recomputation as soon as it</span>
<span class="sd">    has computed all needed Tensors. This context manager can be used to disable</span>
<span class="sd">    that feature if it is problematic for your specific application.</span>

<span class="sd">    This context manager only needs to be active when forward is run. It does</span>
<span class="sd">    not need to be active during backward.</span>

<span class="sd">    Example::</span>

<span class="sd">    &gt;&gt;&gt; # xdoctest: +SKIP(failing)</span>
<span class="sd">    &gt;&gt;&gt; message = &quot;saved tensors default hooks are disabled&quot;</span>
<span class="sd">    &gt;&gt;&gt; with set_checkpoint_early_stop(False):</span>
<span class="sd">    ...     # Any checkpoint under this context manager will respect this</span>
<span class="sd">    ...     # context manager, even if its backward is performed outside.</span>
<span class="sd">    ...     out = checkpoint(fn, inputs)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; out.backward()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_enable_checkpoint_early_stop</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">_enable_checkpoint_early_stop</span>
        <span class="n">_enable_checkpoint_early_stop</span> <span class="o">=</span> <span class="n">enable</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">_enable_checkpoint_early_stop</span> <span class="o">=</span> <span class="n">prev</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_Handle</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_Holder</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handles</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_Handle</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_NoopSaveInputs</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setup_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">output</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Only tensors can be saved with ctx.save_for_backward, everything else</span>
        <span class="c1"># is captured by get_args, which is saved directly on ctx</span>
        <span class="n">tensor_indices</span><span class="p">,</span> <span class="n">tensors</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">idx2saved_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tensor_indices</span><span class="p">)}</span>
        <span class="c1"># args but with tensors replaced with None as placeholders</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_args</span><span class="p">(</span><span class="n">saved_tensors</span><span class="p">):</span>
            <span class="c1"># restore the placeholders with the original tensors grabbed from</span>
            <span class="c1"># ctx.saved_tensors (which may be saved on a parent checkpoint if</span>
            <span class="c1"># this checkpoint is nested, and that would trigger a recursive</span>
            <span class="c1"># unpack!)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">saved_tensors</span><span class="p">[</span><span class="n">idx2saved_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tensor_indices</span> <span class="k">else</span> <span class="n">o</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="c1"># grab the tail since we also saved the dummy to avoid having to explicitly</span>
            <span class="c1"># handle the case where there are no tensor inputs</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">ctx</span><span class="o">.</span><span class="n">get_args</span> <span class="o">=</span> <span class="n">get_args</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="o">*</span><span class="n">tensors</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">grad_outputs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Did not expect to backward on this graph&quot;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_CheckpointFrame</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recompute_fn</span><span class="p">,</span> <span class="n">early_stop</span><span class="p">,</span> <span class="n">unpack_error_cb</span><span class="p">,</span> <span class="n">metadata_fn</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recompute_fn</span> <span class="o">=</span> <span class="n">recompute_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_saver</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weak_holders</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ReferenceType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># We store this as a weakkeydictionary so that in the case of a partial</span>
        <span class="c1"># backward, the entries in the dict are cleared alongside the Holder</span>
        <span class="c1"># which will be removed when the SavedVariable is cleared.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recomputed</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">,</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">[</span><span class="n">_Handle</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">)</span>
        <span class="c1"># We need both recomp_counter and recomputed since they can diverge</span>
        <span class="c1"># https://github.com/pytorch/pytorch/pull/90105#discussion_r1135889885</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recomp_counter</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_recomputed</span><span class="p">:</span> <span class="n">DefaultDict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># See Rule 5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">early_stop</span> <span class="o">=</span> <span class="n">early_stop</span>

        <span class="c1"># Debugging</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata_fn</span> <span class="o">=</span> <span class="n">metadata_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpack_error_cb</span> <span class="o">=</span> <span class="n">unpack_error_cb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_metadatas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward_completed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_saved_mismatch</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_recomputed_tensors_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gid</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_saved_mismatch</span><span class="p">:</span>
            <span class="c1"># TODO: we can probably make this check stricter by checking that</span>
            <span class="c1">#       the metadata of the first tensors still match.</span>
            <span class="k">return</span>
        <span class="c1"># NOTE [ Error handling for checkpoint ]</span>
        <span class="c1">#</span>
        <span class="c1"># At a high level, we need to check that the tensors saved</span>
        <span class="c1"># during original forward matches tensors saved during recompute</span>
        <span class="c1"># This means handling 3 cases:</span>
        <span class="c1">#</span>
        <span class="c1"># 1. During recompute, more tensors were saved.</span>
        <span class="c1">#</span>
        <span class="c1">#    Usually this is hidden due to the StopRecomputationError</span>
        <span class="c1">#    but if early stop is not enabled, or we would have errored</span>
        <span class="c1">#    anyway because there aren&#39;t enough weak_holders. But we</span>
        <span class="c1">#    do want to have a nice error. See the _recomputation_hook</span>
        <span class="c1">#    for details.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weak_holders</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">recomp_counter</span><span class="p">[</span><span class="n">gid</span><span class="p">]:</span>
            <span class="c1"># 2. During recompute, fewer tensors were saved</span>
            <span class="c1">#</span>
            <span class="c1"># We know that everytime we save something do original forward</span>
            <span class="c1"># we append to weak_holder, and every time we save a tensor</span>
            <span class="c1"># during recompute we increment recompute_counter.</span>
            <span class="k">raise</span> <span class="n">CheckpointError</span><span class="p">(</span>
                <span class="s2">&quot;torch.utils.checkpoint: A different number of tensors was saved &quot;</span>
                <span class="s2">&quot;during the original forward and recomputation.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Number of tensors saved during forward: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weak_holders</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Number of tensors saved during recomputation: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">recomp_counter</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># 3. During recompute, the same tensors were saved, but they</span>
        <span class="c1">#    have different metadata</span>
        <span class="n">nb_meta_different</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">weak_holder</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weak_holders</span><span class="p">):</span>
            <span class="n">holder</span> <span class="o">=</span> <span class="n">weak_holder</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">holder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># We&#39;ve seen all holders since we iterate over them in order</span>
            <span class="c1"># For every holder that is still alive now, it must&#39;ve been</span>
            <span class="c1"># alive when we saw it during recompute, therefore, the</span>
            <span class="c1"># gid must be set.</span>
            <span class="n">_internal_assert</span><span class="p">(</span><span class="n">gid</span> <span class="ow">in</span> <span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">)</span>
            <span class="c1"># We know this is the first unpack, so it couldn&#39;t have been set</span>
            <span class="c1"># to None yet.</span>
            <span class="n">_internal_assert</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># We always set these together in the recomputation hook</span>
            <span class="n">_internal_assert</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">])</span>
            <span class="c1"># see pack hook, x_metadata is 1:1 with weak_holders.</span>
            <span class="n">x_meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_metadatas</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">recomputed_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">][</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">x_meta</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_fn</span><span class="p">(</span><span class="n">recomputed_x</span><span class="p">):</span>
                <span class="n">nb_meta_different</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">x_meta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata_fn</span><span class="p">(</span><span class="n">recomputed_x</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nb_meta_different</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mismatched_tensors</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x_meta</span><span class="p">,</span> <span class="n">recomputed_meta</span> <span class="ow">in</span> <span class="n">nb_meta_different</span><span class="p">:</span>
                <span class="n">mismatched_tensors</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;tensor at position </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;saved metadata: </span><span class="si">{</span><span class="n">x_meta</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;recomputed metadata: </span><span class="si">{</span><span class="n">recomputed_meta</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">raise</span> <span class="n">CheckpointError</span><span class="p">(</span>
                <span class="s2">&quot;torch.utils.checkpoint: Recomputed values for the following tensors &quot;</span>
                <span class="s2">&quot;have different metadata than during the forward pass.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">mismatched_tensors</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>


<span class="n">_checkpoint_error_template</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot; </span><span class="se">\</span>
<span class="s2">An error happened while unpacking tensors; dumping logs of latest computation</span>
<span class="s2">because you passed `debug=True` to `torch.utils.checkpoint.checkpoint()`.</span>
<span class="s2">Scroll all the way down for guidance on how to navigate these logs.</span>

<span class="s2">+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+</span>
<span class="s2">|        1. Stack traces of the operators that ran in the original forward     |</span>
<span class="s2">+------------------------------------------------------------------------------+</span>

<span class="si">{forward_traces}</span>
<span class="s2">+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+</span>
<span class="s2">|        2. Stack traces of the operators that ran during recomputation        |</span>
<span class="s2">+------------------------------------------------------------------------------+</span>

<span class="si">{recompute_traces}</span>
<span class="s2">+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+</span>
<span class="s2">|       3. Log of operators in the original forward and recomputation          |</span>
<span class="s2">+------------------------------------------------------------------------------+</span>
<span class="s2">(Scroll up to correlate stack traces with each operation listed below. This</span>
<span class="s2"> helps identify their source in the code.)</span>

<span class="s2">IMPORTANT: Differences in &quot;detach&quot; calls between the original forward and the</span>
<span class="s2">           recomputation are expected. They are introduced by the checkpointing</span>
<span class="s2">           mechanism and can be ignored.</span>

<span class="s2">Operations executed during the original forward:</span>

<span class="si">{forward_ops}</span>

<span class="s2">Operations executed during recomputation:</span>

<span class="si">{recompute_ops}</span>

<span class="s2">+------------------------------------------------------------------------------+</span>
<span class="s2"> ERROR: Detected non-determinism while running activation checkpointing</span>

<span class="s2"> You are seeing this error because you passed `debug=True` to checkpoint and</span>
<span class="s2"> tensors to be saved during the original forward and differ between those saved</span>
<span class="s2"> during recomputation. This can happen if different operators were ran in the</span>
<span class="s2"> original forward and in the recomputation.</span>

<span class="s2"> To identify where the mismatch may be coming from, you can do the following:</span>

<span class="s2"> 1) Compare the operators ran during original forward and recomputation to</span>
<span class="s2">    see where they differ. These operators are printed above in the order they</span>
<span class="s2">    were executed.</span>

<span class="s2"> 2) Review the stack trace for each operator to locate its invocation source.</span>
<span class="s2">    Each operator&#39;s stack trace is printed in their execution order.</span>

<span class="s2"> Note that the logs can be quite long. Here&#39;s how they are structured:</span>
<span class="s2"> (Tip: you can Ctrl-f for these headers)</span>

<span class="s2"> 1. Stack traces of the operators that ran in the original forward</span>
<span class="s2"> 2. Stack traces of the operators that ran during recomputation</span>
<span class="s2"> 3. Log of operators in the original forward and recomputation</span>
<span class="s2"> 4. Error message                                             &lt;--- You are here</span>
<span class="s2">--------------------------------------------------------------------------------</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CheckpointError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_debug_context_and_cb</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">CheckpointError</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]:</span>
    <span class="c1"># This function returns the context_fn and error_cb to be used by the</span>
    <span class="c1"># checkpointing mechanism. error_cb is invoked when an error is detected</span>
    <span class="c1"># during unpack.</span>

    <span class="c1"># record_context_cpp is not support on non-linux non-x86_64 platforms</span>
    <span class="n">cpp_tb</span> <span class="o">=</span> <span class="n">platform</span><span class="o">.</span><span class="n">machine</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;x86_64&#39;</span> <span class="ow">and</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Linux&#39;</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">CaptureLogs</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tbs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_context_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">logging_mode</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">LoggingTensorMode</span><span class="p">(),</span> \
                     <span class="n">capture_logs</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">python_tb</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">script_tb</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cpp_tb</span><span class="o">=</span><span class="n">cpp_tb</span><span class="p">)</span> <span class="k">as</span> <span class="n">logs_and_tb</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tbs</span> <span class="o">=</span> <span class="n">logs_and_tb</span>
                    <span class="k">yield</span> <span class="n">logs_and_tb</span>
            <span class="k">return</span> <span class="n">logging_mode</span><span class="p">()</span>

    <span class="n">capture_logs_fwd</span> <span class="o">=</span> <span class="n">CaptureLogs</span><span class="p">()</span>
    <span class="n">capture_logs_recompute</span> <span class="o">=</span> <span class="n">CaptureLogs</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">unpack_error_cb</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">CheckpointError</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_str_tb</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">capture_logs</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">total_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">capture_logs</span><span class="o">.</span><span class="n">logs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">tb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">capture_logs</span><span class="o">.</span><span class="n">logs</span><span class="p">,</span> <span class="n">capture_logs</span><span class="o">.</span><span class="n">tbs</span><span class="p">)):</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">log</span><span class="si">}</span><span class="s2">   (</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">total_len</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">)</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="n">found_torch_dispatch</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">tb</span><span class="p">:</span>
                    <span class="c1"># Start printing stack trace only after __torch_dispatch__ is found</span>
                    <span class="n">is_torch_dispatch</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;__torch_dispatch__&#39;</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_torch_dispatch</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_torch_dispatch</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="n">is_torch_dispatch</span><span class="p">:</span>
                        <span class="n">found_torch_dispatch</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">continue</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="s1">&#39;line&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">line</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">assert</span> <span class="n">capture_logs_fwd</span><span class="o">.</span><span class="n">logs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">capture_logs_recompute</span><span class="o">.</span><span class="n">logs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="n">CheckpointError</span><span class="p">(</span>
            <span class="n">_checkpoint_error_template</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">forward_traces</span><span class="o">=</span><span class="n">get_str_tb</span><span class="p">(</span><span class="s2">&quot;original&quot;</span><span class="p">,</span> <span class="n">capture_logs_fwd</span><span class="p">),</span>
                <span class="n">recompute_traces</span><span class="o">=</span><span class="n">get_str_tb</span><span class="p">(</span><span class="s2">&quot;recompute&quot;</span><span class="p">,</span> <span class="n">capture_logs_recompute</span><span class="p">),</span>
                <span class="n">forward_ops</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">capture_logs_fwd</span><span class="o">.</span><span class="n">logs</span><span class="p">),</span>
                <span class="n">recompute_ops</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">capture_logs_recompute</span><span class="o">.</span><span class="n">logs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">context_fn</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">capture_logs_fwd</span><span class="o">.</span><span class="n">get_context_manager</span><span class="p">(),</span> <span class="n">capture_logs_recompute</span><span class="o">.</span><span class="n">get_context_manager</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">context_fn</span><span class="p">,</span> <span class="n">unpack_error_cb</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_default_meta_extractor</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="c1"># These properties are fast to check, easy to understand</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;shape&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="s2">&quot;device&quot;</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">device</span>
    <span class="p">}</span>

<span class="n">_allowed_determinism_checks_to_fns</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">_DEFAULT_DETERMINISM_MODE</span><span class="p">:</span> <span class="n">_default_meta_extractor</span><span class="p">,</span>
    <span class="s2">&quot;none&quot;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1"># See Rule 5</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_StopRecomputationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_recomputation_hook</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">saved_tensors_hooks</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_frame_ref</span><span class="p">:</span> <span class="n">ReferenceType</span><span class="p">,</span> <span class="n">gid</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">pack_hook</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">requires_grad</span> <span class="k">else</span> <span class="n">x</span>
            <span class="n">target_frame</span> <span class="o">=</span> <span class="n">target_frame_ref</span><span class="p">()</span>
            <span class="k">assert</span> <span class="n">target_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>  <span class="c1"># appease mypy</span>
            <span class="n">recomp_idx</span> <span class="o">=</span> <span class="n">target_frame</span><span class="o">.</span><span class="n">recomp_counter</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span>
            <span class="n">target_frame</span><span class="o">.</span><span class="n">recomp_counter</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">recomp_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_frame</span><span class="o">.</span><span class="n">weak_holders</span><span class="p">):</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="n">target_frame</span><span class="o">.</span><span class="n">early_stop</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">target_frame</span><span class="o">.</span><span class="n">forward_completed</span><span class="p">:</span>
                    <span class="c1"># We run into this case when early stop is not enabled and do</span>
                    <span class="c1"># grad within checkpoint.</span>
                    <span class="c1"># We need to set this flag, so we don&#39;t error out later when</span>
                    <span class="c1"># we check if the number of tensors saved during forward and</span>
                    <span class="c1"># recomputation match.</span>
                    <span class="n">target_frame</span><span class="o">.</span><span class="n">ignore_saved_mismatch</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">return</span> <span class="n">x</span>
                <span class="k">raise</span> <span class="n">CheckpointError</span><span class="p">(</span>
                    <span class="s2">&quot;torch.utils.checkpoint: trying to save more tensors during &quot;</span>
                    <span class="s2">&quot;recomputation than during the original forward pass.&quot;</span>
                <span class="p">)</span>

            <span class="n">holder</span> <span class="o">=</span> <span class="n">target_frame</span><span class="o">.</span><span class="n">weak_holders</span><span class="p">[</span><span class="n">recomp_idx</span><span class="p">]()</span>

            <span class="c1"># This holder may have been cleared because someone may have called</span>
            <span class="c1"># backward within forward. If so, we don&#39;t need to save.</span>
            <span class="k">if</span> <span class="n">holder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_internal_assert</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">gid</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Handle</span><span class="p">()</span>
                <span class="n">target_frame</span><span class="o">.</span><span class="n">recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">][</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]]</span> <span class="o">=</span> <span class="n">x</span>

            <span class="k">if</span> <span class="n">target_frame</span><span class="o">.</span><span class="n">early_stop</span> <span class="ow">and</span> <span class="n">target_frame</span><span class="o">.</span><span class="n">recomp_counter</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">target_frame</span><span class="o">.</span><span class="n">weak_holders</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="n">_StopRecomputationError</span>
            <span class="c1"># See Rule 6: [ retain_graph is True ] above</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">unpack_hook</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># See Rule 6: [ retain_graph is True ] above for an example of when</span>
            <span class="c1"># the graph created during recomputation could be backwarded.</span>
            <span class="k">return</span> <span class="n">x</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pack_hook</span><span class="p">,</span> <span class="n">unpack_hook</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_checkpoint_hook</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">saved_tensors_hooks</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">pack_hook</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># See Rule 4 above</span>
            <span class="n">holder</span> <span class="o">=</span> <span class="n">_Holder</span><span class="p">()</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">weak_holders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">holder</span><span class="p">))</span>
            <span class="c1"># Save metadata to detect non-determinism</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">metadata_fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">frame</span><span class="o">.</span><span class="n">x_metadatas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">metadata_fn</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">holder</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">unpack_hook</span><span class="p">(</span><span class="n">holder</span><span class="p">):</span>
            <span class="n">gid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_current_graph_task_id</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># generate a temporary id if we trigger unpack outside of a backward call</span>
                <span class="n">gid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">frame</span><span class="o">.</span><span class="n">is_recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">]:</span>
                <span class="n">ctx</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">input_saver</span><span class="o">.</span><span class="n">grad_fn</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">get_args</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">saved_tensors</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">with</span> <span class="n">_recomputation_hook</span><span class="p">(</span>
                        <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">frame</span><span class="p">),</span> <span class="n">gid</span>
                    <span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">autograd</span><span class="o">.</span><span class="n">enable_grad</span><span class="p">():</span>
                        <span class="n">frame</span><span class="o">.</span><span class="n">recompute_fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">_StopRecomputationError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">is_recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">check_recomputed_tensors_match</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>

            <span class="n">_internal_assert</span><span class="p">(</span><span class="n">gid</span> <span class="ow">in</span> <span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CheckpointError</span><span class="p">(</span>
                    <span class="s2">&quot;torch.utils.checkpoint: Unpack is being triggered for a tensor that was already &quot;</span>
                    <span class="s2">&quot;unpacked once. If you are calling ctx.saved_tensors in backward, make sure to do &quot;</span>
                    <span class="s2">&quot;so only once. Otherwise please open an issue with details on your use case.&quot;</span>
                <span class="p">)</span>
            <span class="n">_internal_assert</span><span class="p">(</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="ow">in</span> <span class="n">frame</span><span class="o">.</span><span class="n">recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">])</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">recomputed</span><span class="p">[</span><span class="n">gid</span><span class="p">][</span><span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]]</span>
            <span class="n">holder</span><span class="o">.</span><span class="n">handles</span><span class="p">[</span><span class="n">gid</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">unpack_error_cb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">unpack_hook_with_error_cb</span><span class="p">(</span><span class="n">holder</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">unpack_hook</span><span class="p">(</span><span class="n">holder</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">CheckpointError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">frame</span><span class="o">.</span><span class="n">unpack_error_cb</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pack_hook</span><span class="p">,</span> <span class="n">unpack_hook_with_error_cb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pack_hook</span><span class="p">,</span> <span class="n">unpack_hook</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_compiling</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># Check if we are under AOTAutograd tracing</span>
    <span class="c1"># There should probably be a better way to do this...</span>
    <span class="c1"># TODO: unify _is_compiling across all compile stacks</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_fun</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_VersionWrapper</span><span class="p">:</span>
    <span class="c1"># Check that cached tensors are not mutated.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">_version</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">allow_cache_entry_mutation</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_cache_entry_mutation</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">_version</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="p">:</span>
                <span class="c1"># Can we give user a stack trace of where the mutation happened?</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Tensor cached during selective activation checkpoint has been mutated&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_maybe_detach</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">any_ret_has_alias_info</span><span class="p">):</span>
    <span class="c1"># We detach for two separate reasons:</span>
    <span class="c1"># - For view ops, we need to ensure that when the tensor is returned from</span>
    <span class="c1">#   CachedDispatchMode, as_view sees that the AutogradMeta is nullptr</span>
    <span class="c1"># - Avoid reference cycles</span>
    <span class="c1"># For case 1, it is not enough to check whether x has differentiable dtype</span>
    <span class="c1"># because non-differentiable dtype can have non-nullptr AutogradMeta, e.g.</span>
    <span class="c1"># when the tensor is a view.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">()</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">is_complex</span><span class="p">()</span> <span class="ow">or</span> <span class="n">any_ret_has_alias_info</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">_SetExcludeDispatchKeyGuard</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">DispatchKey</span><span class="o">.</span><span class="n">ADInplaceOrView</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Ensure that view performed beneath autograd properly propagates</span>
            <span class="c1"># version counter. TODO: Use reentrant_dispatch instead of</span>
            <span class="c1"># manually manipulating dispatch keys. Using reentrant_dispatch</span>
            <span class="c1"># would respect inference_mode, though that is not relevant for</span>
            <span class="c1"># this case.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="SelectiveCheckpointContext">
<a class="viewcode-back" href="../../../python-api/checkpoint.html#torch.utils.checkpoint.SelectiveCheckpointContext">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SelectiveCheckpointContext</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Context passed to policy function during selective checkpointing.</span>

<span class="sd">    This class is used to pass relevant metadata to the policy function during</span>
<span class="sd">    selective checkpointing. The metadata includes whether the current invocation</span>
<span class="sd">    of the policy function is during recomputation or not.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +SKIP(stub)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def policy_fn(ctx, op, *args, **kwargs):</span>
<span class="sd">        &gt;&gt;&gt;    print(ctx.is_recompute)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; context_fn = functools.partial(create_selective_checkpoint_contexts, policy_fn)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; out = torch.utils.checkpoint.checkpoint(</span>
<span class="sd">        &gt;&gt;&gt;     fn, x, y,</span>
<span class="sd">        &gt;&gt;&gt;     use_reentrant=False,</span>
<span class="sd">        &gt;&gt;&gt;     context_fn=context_fn,</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">is_recompute</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_recompute</span> <span class="o">=</span> <span class="n">is_recompute</span></div>



<div class="viewcode-block" id="CheckpointPolicy">
<a class="viewcode-back" href="../../../python-api/checkpoint.html#torch.utils.checkpoint.CheckpointPolicy">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CheckpointPolicy</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Enum for specifying the policy for checkpointing during backpropagation.</span>

<span class="sd">    The following policies are supported:</span>

<span class="sd">    - ``{MUST,PREFER}_SAVE``: The operation&#39;s output will be saved during the forward</span>
<span class="sd">      pass and will not be recomputed during the backward pass</span>
<span class="sd">    - ``{MUST,PREFER}_RECOMPUTE``: The operation&#39;s output will not be saved during the</span>
<span class="sd">      forward pass and will be recomputed during the backward pass</span>

<span class="sd">    Use ``MUST_*`` over ``PREFER_*`` to indicate that the policy should not be overridden</span>
<span class="sd">    by other subsystems like `torch.compile`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        A policy function that always returns ``PREFER_RECOMPUTE`` is</span>
<span class="sd">        equivalent to vanilla checkpointing.</span>

<span class="sd">        A policy function that returns ``PREFER_SAVE`` every op is</span>
<span class="sd">        NOT equivalent to not using checkpointing. Using such a policy would</span>
<span class="sd">        save additional tensors not limited to ones that are actually needed for</span>
<span class="sd">        gradient computation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MUST_SAVE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">PREFER_SAVE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">MUST_RECOMPUTE</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">PREFER_RECOMPUTE</span> <span class="o">=</span> <span class="mi">3</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_policy_from_bool</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="c1"># For backward compatability</span>
    <span class="k">return</span> <span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">MUST_SAVE</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">PREFER_RECOMPUTE</span>


<span class="n">SAC_IGNORED_OPS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># AC inserts different number of detach during forward and recompute.</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">aten</span><span class="o">.</span><span class="n">detach</span><span class="o">.</span><span class="n">default</span><span class="p">,</span>
    <span class="c1"># AC&#39;s determinism check invokes additional metadata ops during forward.</span>
    <span class="c1"># With subclasses involved, these metadata ops become dispatchable, this</span>
    <span class="c1"># can result in incorrectness if these ops are selected cached.</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">prim</span><span class="o">.</span><span class="n">device</span><span class="o">.</span><span class="n">default</span><span class="p">,</span>
<span class="p">}</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">_subclasses</span><span class="o">.</span><span class="n">functional_tensor</span><span class="o">.</span><span class="n">FunctionalTensor</span><span class="o">.</span><span class="n">metadata_fns</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_CachingTorchDispatchMode</span><span class="p">(</span><span class="n">TorchDispatchMode</span><span class="p">):</span>
    <span class="c1"># Used together with _CachedTorchDispatchMode to implement SAC.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy_fn</span><span class="p">,</span> <span class="n">storage</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">policy_fn</span> <span class="o">=</span> <span class="n">policy_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">storage</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__torch_dispatch__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">SAC_IGNORED_OPS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">kwargs</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy_fn</span><span class="p">(</span><span class="n">SelectiveCheckpointContext</span><span class="p">(</span><span class="n">is_recompute</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                                <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">policy</span> <span class="o">=</span> <span class="n">_policy_from_bool</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span>

        <span class="n">is_compiling</span> <span class="o">=</span> <span class="n">_is_compiling</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_compiling</span><span class="p">:</span>
            <span class="c1"># Overwrite each node&#39;s &quot;recompute&quot; tag to add in the user annotation.</span>
            <span class="n">fx_traceback</span><span class="o">.</span><span class="n">current_meta</span><span class="p">[</span><span class="s2">&quot;recompute&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">policy</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">any_ret_has_alias_info</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">alias_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">ret</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">_schema</span><span class="o">.</span><span class="n">returns</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">policy</span> <span class="ow">in</span> <span class="p">(</span><span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">MUST_SAVE</span><span class="p">,</span> <span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">PREFER_SAVE</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_compiling</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_VersionWrapper</span><span class="p">(</span><span class="n">_maybe_detach</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">any_ret_has_alias_info</span><span class="p">)),</span> <span class="n">out</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">out</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_CachedTorchDispatchMode</span><span class="p">(</span><span class="n">TorchDispatchMode</span><span class="p">):</span>
    <span class="c1"># Used together with _CachedTorchDispatchMode to implement SAC.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy_fn</span><span class="p">,</span> <span class="n">storage</span><span class="p">,</span> <span class="n">allow_cache_entry_mutation</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">policy_fn</span> <span class="o">=</span> <span class="n">policy_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">storage</span> <span class="o">=</span> <span class="n">storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_cache_entry_mutation</span> <span class="o">=</span> <span class="n">allow_cache_entry_mutation</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__torch_dispatch__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">SAC_IGNORED_OPS</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">kwargs</span>
        <span class="n">policy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">policy_fn</span><span class="p">(</span><span class="n">SelectiveCheckpointContext</span><span class="p">(</span><span class="n">is_recompute</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                                <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">policy</span> <span class="o">=</span> <span class="n">_policy_from_bool</span><span class="p">(</span><span class="n">policy</span><span class="p">)</span>

        <span class="n">is_compiling</span> <span class="o">=</span> <span class="n">_is_compiling</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">policy</span> <span class="ow">in</span> <span class="p">(</span><span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">MUST_SAVE</span><span class="p">,</span> <span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">PREFER_SAVE</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_compiling</span><span class="p">:</span>
            <span class="n">storage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">storage</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">storage</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> encountered during backward, but not found in storage&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;Trying to backward an extra time. You are only allowed to backward once &quot;</span>
                    <span class="s2">&quot;on any region computed under selective activation checkpoint.&quot;</span>
                <span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">get_val</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_cache_entry_mutation</span><span class="p">),</span> <span class="n">storage</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="create_selective_checkpoint_contexts">
<a class="viewcode-back" href="../../../python-api/checkpoint.html#torch.utils.checkpoint.create_selective_checkpoint_contexts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_selective_checkpoint_contexts</span><span class="p">(</span><span class="n">policy_fn_or_list</span><span class="p">,</span> <span class="n">allow_cache_entry_mutation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper to avoid recomputing certain ops during activation checkpointing.</span>

<span class="sd">    Use this with `torch.utils.checkpoint.checkpoint` to control which</span>
<span class="sd">    operations are recomputed during the backward pass.</span>

<span class="sd">    Args:</span>
<span class="sd">        policy_fn_or_list (Callable or List):</span>
<span class="sd">          - If a policy function is provided, it should accept a</span>
<span class="sd">            :class:`SelectiveCheckpointContext`, the :class:`OpOverload`, args and</span>
<span class="sd">            kwargs to the op, and return a :class:`CheckpointPolicy` enum value</span>
<span class="sd">            indicating whether the execution of the op should be recomputed or not.</span>
<span class="sd">          - If a list of operations is provided, it is equivalent to a policy</span>
<span class="sd">            returning `CheckpointPolicy.MUST_SAVE` for the specified</span>
<span class="sd">            operations and `CheckpointPolicy.PREFER_RECOMPUTE` for all other</span>
<span class="sd">            operations.</span>
<span class="sd">        allow_cache_entry_mutation (bool, optional): By default, an error is</span>
<span class="sd">            raised if any tensors cached by selective activation checkpoint are</span>
<span class="sd">            mutated in order to ensure correctness. If set to `True`, this check</span>
<span class="sd">            is disabled.</span>
<span class="sd">    Returns:</span>
<span class="sd">        A tuple of two context managers.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +REQUIRES(LINUX)</span>
<span class="sd">        &gt;&gt;&gt; import functools</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; x = torch.rand(10, 10, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; y = torch.rand(10, 10, requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; ops_to_save = [</span>
<span class="sd">        &gt;&gt;&gt;    torch.ops.aten.mm.default,</span>
<span class="sd">        &gt;&gt;&gt; ]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def policy_fn(ctx, op, *args, **kwargs):</span>
<span class="sd">        &gt;&gt;&gt;    if op in ops_to_save:</span>
<span class="sd">        &gt;&gt;&gt;        return CheckpointPolicy.MUST_SAVE</span>
<span class="sd">        &gt;&gt;&gt;    else:</span>
<span class="sd">        &gt;&gt;&gt;        return CheckpointPolicy.PREFER_RECOMPUTE</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; context_fn = functools.partial(create_selective_checkpoint_contexts, policy_fn)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # or equivalently</span>
<span class="sd">        &gt;&gt;&gt; context_fn = functools.partial(create_selective_checkpoint_contexts, ops_to_save)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def fn(x, y):</span>
<span class="sd">        &gt;&gt;&gt;     return torch.sigmoid(torch.matmul(torch.matmul(x, y), y)) * y</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; out = torch.utils.checkpoint.checkpoint(</span>
<span class="sd">        &gt;&gt;&gt;     fn, x, y,</span>
<span class="sd">        &gt;&gt;&gt;     use_reentrant=False,</span>
<span class="sd">        &gt;&gt;&gt;     context_fn=context_fn,</span>
<span class="sd">        &gt;&gt;&gt; )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NB: If grad_mode is disabled, checkpoint would not run forward under</span>
    <span class="c1">#     context_fn anyway, so proceed as usual.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy_fn_or_list</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">policy_fn_or_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">OpOverload</span><span class="p">):</span>
                <span class="n">_extra_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Please update the OpOverloadPacket to a specific OpOverload.&quot;</span>
                    <span class="s2">&quot;For example, if you have `torch.ops.aten.mm`, change it to `torch.ops.aten.mm.default`.&quot;</span>
                <span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">_ops</span><span class="o">.</span><span class="n">OpOverloadPacket</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Expected op in `op_list` to be an OpOverload but got: </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">_extra_msg</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">policy_fn</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">policy_fn_or_list</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">MUST_SAVE</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">CheckpointPolicy</span><span class="o">.</span><span class="n">PREFER_RECOMPUTE</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">policy_fn_or_list</span><span class="p">):</span>
        <span class="n">policy_fn</span> <span class="o">=</span> <span class="n">policy_fn_or_list</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;policy_fn_or_list must be either a function or a list of ops.&quot;</span><span class="p">)</span>

    <span class="n">storage</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">_CachingTorchDispatchMode</span><span class="p">(</span><span class="n">policy_fn</span><span class="p">,</span> <span class="n">storage</span><span class="p">),</span>
        <span class="n">_CachedTorchDispatchMode</span><span class="p">(</span><span class="n">policy_fn</span><span class="p">,</span> <span class="n">storage</span><span class="p">,</span> <span class="n">allow_cache_entry_mutation</span><span class="p">),</span>
    <span class="p">)</span></div>


<span class="c1"># NB: this helper wraps fn before calling checkpoint_impl. kwargs and</span>
<span class="c1">#     saving/restoring of global state is handled here.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_checkpoint_without_reentrant_generator</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">,</span>
    <span class="n">preserve_rng_state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">context_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">ContextManager</span><span class="p">,</span> <span class="n">ContextManager</span><span class="p">]]</span> <span class="o">=</span> <span class="n">noop_context_fn</span><span class="p">,</span>
    <span class="n">determinism_check</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">_DEFAULT_DETERMINISM_MODE</span><span class="p">,</span>
    <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checkpointing without reentrant autograd.</span>

<span class="sd">    Args:</span>
<span class="sd">        fn: describes what to run in the forward pass of the model or</span>
<span class="sd">            part of the model. It should also know how to handle the inputs</span>
<span class="sd">            passed as the tuple. For example, in LSTM, if user passes</span>
<span class="sd">            ``(activation, hidden)``, :attr:`function` should correctly use the</span>
<span class="sd">            first input as ``activation`` and the second input as ``hidden``</span>
<span class="sd">        preserve_rng_state(bool, optional):  Omit stashing and restoring</span>
<span class="sd">            the RNG state during each checkpoint.</span>
<span class="sd">            Default: ``True``</span>
<span class="sd">        context_fn(Callable, optional): A callable returning a tuple of two</span>
<span class="sd">            context managers. The function and its recomputation will be run</span>
<span class="sd">            under the first and second context managers respectively.</span>
<span class="sd">        determinism_check(str, optional): A string specifying the determinism</span>
<span class="sd">            check to perform. By default it is set to ``&quot;default&quot;`` which</span>
<span class="sd">            compares the shapes, dtypes, and devices of the recomputed tensors</span>
<span class="sd">            against those the saved tensors. To turn off this check, specify</span>
<span class="sd">            ``&quot;none&quot;``. Currently these are the only two supported values.</span>
<span class="sd">            Please open an issue if you would like to see more determinism</span>
<span class="sd">            checks.</span>
<span class="sd">        debug(bool, optional): If ``True``, error messages will also include</span>
<span class="sd">            a trace of the operators ran during the original forward computation</span>
<span class="sd">            as well as the recomputation.</span>
<span class="sd">        *args: Arguments to pass in to the given ``function``.</span>
<span class="sd">        **kwargs: Keyword arguments to pass into the given ``function``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unpack_error_cb</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">_checkpoint_debug_enabled</span> <span class="k">if</span> <span class="n">_checkpoint_debug_enabled</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">debug</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">context_fn</span> <span class="o">!=</span> <span class="n">noop_context_fn</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;debug=True is incompatible with non-default context_fn&quot;</span>
            <span class="p">)</span>
        <span class="n">context_fn</span><span class="p">,</span> <span class="n">unpack_error_cb</span> <span class="o">=</span> <span class="n">_get_debug_context_and_cb</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">determinism_check</span> <span class="ow">in</span> <span class="n">_allowed_determinism_checks_to_fns</span><span class="p">:</span>
        <span class="n">metadata_fn</span> <span class="o">=</span> <span class="n">_allowed_determinism_checks_to_fns</span><span class="p">[</span><span class="n">determinism_check</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;determinism_check should be one of </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">_allowed_determinism_checks_to_fns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">determinism_check</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">device_type</span> <span class="o">=</span> <span class="n">_infer_device_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="n">device_module</span> <span class="o">=</span> <span class="n">_get_device_module</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span>
    <span class="n">forward_context</span><span class="p">,</span> <span class="n">recompute_context</span> <span class="o">=</span> <span class="n">context_fn</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">_is_compiling</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">and</span> <span class="n">context_fn</span> <span class="o">!=</span> <span class="n">noop_context_fn</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">forward_context</span><span class="p">,</span> <span class="n">TorchDispatchMode</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">recompute_context</span><span class="p">,</span> <span class="n">TorchDispatchMode</span><span class="p">)</span>
        <span class="p">),</span> \
            <span class="s2">&quot;In torch.compile mode, `context_fn` arg passed to `torch.utils.checkpoint` &quot;</span> <span class="o">+</span> \
            <span class="s2">&quot;must generate a tuple of two `TorchDispatchMode`s.&quot;</span>
    <span class="c1"># Accommodates the (remote) possibility that autocast is enabled for cpu AND gpu.</span>
    <span class="n">device_autocast_kwargs</span><span class="p">,</span> <span class="n">cpu_autocast_kwargs</span> <span class="o">=</span> <span class="n">_get_autocast_kwargs</span><span class="p">(</span><span class="n">device_type</span><span class="o">=</span><span class="n">device_type</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">preserve_rng_state</span><span class="p">:</span>
        <span class="n">fwd_cpu_state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">get_rng_state</span><span class="p">()</span>
        <span class="c1"># Don&#39;t eagerly initialize the cuda context by accident.</span>
        <span class="c1"># (If the user intends that the context is initialized later, within their</span>
        <span class="c1"># run_function, we SHOULD actually stash the cuda state here.  Unfortunately,</span>
        <span class="c1"># we have no way to anticipate this will happen before we run the function.</span>
        <span class="c1"># If they do so, we raise an error.)</span>
        <span class="n">had_device_in_fwd</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">device_module</span><span class="p">,</span> <span class="s2">&quot;_initialized&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">had_device_in_fwd</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">fwd_devices</span><span class="p">,</span> <span class="n">fwd_device_states</span> <span class="o">=</span> <span class="n">get_device_states</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">recompute_fn</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="c1"># This will be called later during recomputation. This wrapping enables</span>
        <span class="c1"># the necessary global state to be captured.</span>
        <span class="n">rng_devices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">preserve_rng_state</span> <span class="ow">and</span> <span class="n">had_device_in_fwd</span><span class="p">:</span>
            <span class="n">rng_devices</span> <span class="o">=</span> <span class="n">fwd_devices</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">fork_rng</span><span class="p">(</span>
            <span class="n">devices</span><span class="o">=</span><span class="n">rng_devices</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="n">preserve_rng_state</span><span class="p">,</span> <span class="n">device_type</span><span class="o">=</span><span class="n">device_type</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">preserve_rng_state</span><span class="p">:</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">set_rng_state</span><span class="p">(</span><span class="n">fwd_cpu_state</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">had_device_in_fwd</span><span class="p">:</span>
                    <span class="n">set_device_states</span><span class="p">(</span><span class="n">fwd_devices</span><span class="p">,</span> <span class="n">fwd_device_states</span><span class="p">,</span> <span class="n">device_type</span><span class="o">=</span><span class="n">device_type</span><span class="p">)</span>

            <span class="n">device_autocast_ctx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">(</span>
                <span class="n">device_type</span><span class="o">=</span><span class="n">device_type</span><span class="p">,</span> <span class="o">**</span><span class="n">device_autocast_kwargs</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">is_autocast_available</span><span class="p">(</span><span class="n">device_type</span><span class="p">)</span> <span class="k">else</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">nullcontext</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">device_autocast_ctx</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">(</span><span class="s2">&quot;cpu&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">cpu_autocast_kwargs</span><span class="p">),</span> <span class="n">recompute_context</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
                <span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">new_frame</span> <span class="o">=</span> <span class="n">_CheckpointFrame</span><span class="p">(</span>
        <span class="n">recompute_fn</span><span class="p">,</span>
        <span class="n">_enable_checkpoint_early_stop</span><span class="p">,</span>
        <span class="n">unpack_error_cb</span><span class="p">,</span>
        <span class="n">metadata_fn</span>
    <span class="p">)</span>
    <span class="n">dummy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">new_frame</span><span class="o">.</span><span class="n">input_saver</span> <span class="o">=</span> <span class="n">_NoopSaveInputs</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">dummy</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># When ambient grad_mode is False</span>
    <span class="k">if</span> <span class="n">new_frame</span><span class="o">.</span><span class="n">input_saver</span><span class="o">.</span><span class="n">grad_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">yield</span>
        <span class="k">return</span>

    <span class="k">with</span> <span class="n">_checkpoint_hook</span><span class="p">(</span><span class="n">new_frame</span><span class="p">),</span> <span class="n">forward_context</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="n">new_frame</span><span class="o">.</span><span class="n">forward_completed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">device_module</span><span class="p">,</span> <span class="s2">&quot;_initialized&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> \
       <span class="n">preserve_rng_state</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">had_device_in_fwd</span><span class="p">:</span>  <span class="c1"># type: ignore[possibly-undefined]</span>
        <span class="c1"># Device was not initialized before running the forward, so we didn&#39;t</span>
        <span class="c1"># stash the device state.</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="s2">&quot;PyTorch&#39;s device state was initialized in the forward pass &quot;</span>
            <span class="s2">&quot;of a Checkpoint, which is not allowed. Please open an issue &quot;</span>
            <span class="s2">&quot;if you need this feature.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span>
</pre></div>

                </article>
              
              
              
                <footer class="bd-footer-article">
                  <div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item">
<div class="feedback">
  
<div class="rating">
    Rate this Page
    <div class="stars">
        
        <span class="star" data-value="1">★</span>
        
        <span class="star" data-value="2">★</span>
        
        <span class="star" data-value="3">★</span>
        
        <span class="star" data-value="4">★</span>
        
        <span class="star" data-value="5">★</span>
        
    </div>
</div>

  <div class="feedback-send">
    <button class="feedback-btn" onclick="openGitHubIssue()">Send Feedback</button>
  </div>
</div>
</div>
  
</div>
                </footer>
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>


  <footer class="bd-footer">
    
    <div class="bd-footer__inner bd-page-width">
      
        <div class="footer-items__start">
          
            <div class="footer-item">

  <p class="copyright">
    
      © Copyright PyTorch Contributors.
      <br/>
    
  </p>
</div>
          
            <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.0.
    <br/>
  </p>
</div>
          
        </div>
      
    
    
      <div class="footer-items__end">
        
          <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
        
      </div>
    
   </div>
   

   <div class="container-fluid docs-tutorials-resources" id="docs-tutorials-resources">
      <div class="container">
        <div class="row">
          <div class="col-md-4 text-center">
            <h2>Docs</h2>
            <p>Access comprehensive developer documentation for PyTorch</p>
            <a class="with-right-arrow" href="">View Docs</a>
          </div>

          <div class="col-md-4 text-center">
            <h2>Tutorials</h2>
            <p>Get in-depth tutorials for beginners and advanced developers</p>
            <a class="with-right-arrow" href="">View Tutorials</a>
          </div>

          <div class="col-md-4 text-center">
            <h2>Resources</h2>
            <p>Find development resources and get your questions answered</p>
            <a class="with-right-arrow" href="">View Resources</a>
          </div>
        </div>
      </div>
  </div>

  <footer class="site-footer">
      <div class="container footer-container">
        <div class="footer-logo-wrapper">
          <a href="" class="footer-logo"></a>
        </div>

        <div class="footer-links-wrapper">
          <div class="footer-links-col">
            <ul>
              <li class="list-title"><a href="">PyTorch</a></li>
              <li><a href="">Get Started</a></li>
              <li><a href="">Features</a></li>
              <li><a href="">Ecosystem</a></li>
              <li><a href="">Blog</a></li>
              <li><a href="">Contributing</a></li>
            </ul>
          </div>

          <div class="footer-links-col">
            <ul>
              <li class="list-title"><a href="">Resources</a></li>
              <li><a href="">Tutorials</a></li>
              <li><a href="">Docs</a></li>
              <li><a href="" target="_blank">Discuss</a></li>
              <li><a href="" target="_blank">Github Issues</a></li>
              <li><a href="" target="_blank">Brand Guidelines</a></li>
            </ul>
          </div>

          <div class="footer-links-col">
            <ul>
              <li class="list-title">Stay up to date</li>
              <li><a href="" target="_blank">Facebook</a></li>
              <li><a href="" target="_blank">Twitter</a></li>
              <li><a href="" target="_blank">YouTube</a></li>
              <li><a href="" target="_blank">LinkedIn</a></li>
            </ul>
            </div>

          <div class="footer-links-col">
            <ul>
              <li class="list-title">PyTorch Podcasts</li>
              <li><a href="" target="_blank">Spotify</a></li>
              <li><a href="" target="_blank">Apple</a></li>
              <li><a href="" target="_blank">Google</a></li>
              <li><a href="" target="_blank">Amazon</a></li>
            </ul>
           </div>
          </div>

          <div class="privacy-policy">
            <ul>
              <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/terms/" target="_blank">Terms</a></li>
              <li class="privacy-policy-links">|</li>
              <li class="privacy-policy-links"><a href="https://www.linuxfoundation.org/privacy-policy/" target="_blank">Privacy</a></li>
            </ul>
          </div>
          <div class="copyright">
          <p>© Copyright The Linux Foundation. The PyTorch Foundation is a project of The Linux Foundation.
            For web site terms of use, trademark policy and other policies applicable to The PyTorch Foundation please see
            <a href="https://www.linuxfoundation.org/policies/">www.linuxfoundation.org/policies/</a>. The PyTorch Foundation supports the PyTorch open source
            project, which has been established as PyTorch Project a Series of LF Projects, LLC. For policies applicable to the PyTorch Project a Series of LF Projects, LLC,
            please see <a href="https://www.lfprojects.org/policies/">www.lfprojects.org/policies/</a>.</p>
        </div>
       </div>

  <div class="cookie-banner-wrapper">
  <div class="container">
    <p class="gdpr-notice">To analyze traffic and optimize your experience, we serve cookies on this site. By clicking or navigating, you agree to allow our usage of cookies. As the current maintainers of this site, Facebook’s Cookies Policy applies. Learn more, including about available controls: <a href="https://www.facebook.com/policies/cookies/">Cookies Policy</a>.</p>
    <img class="close-button" src="../../../_static/img/pytorch-x.svg">
  </div>
</div>
  </footer>


  </body>
</html>