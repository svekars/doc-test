
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Quantization &#8212; PyTorch main documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=949a1ff5" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/jit.css?v=8de1ea5d" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=3ccf5357" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom2.css?v=3539c01c" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=a8da1a53"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=940804e7"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'python-api/quantization';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="main (2.6.0 )" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Learn
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Get Started</span>
                  <p>Run PyTorch locally or get started quickly with one of the supported cloud platforms</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tutorials</span>
                  <p>Whats new in PyTorch tutorials</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Learn the Basics</span>
                  <p>Familiarize yourself with PyTorch concepts and modules</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Recipes</span>
                  <p>Bite-size, ready-to-deploy PyTorch code examples</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                  <p>Master PyTorch basics with our engaging YouTube tutorial series</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Ecosystem
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tools</span>
                  <p>Learn about the tools and frameworks in the PyTorch Ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="" target="_blank">
                  <span class=dropdown-title>Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contributor Awards - 2024</span>
                  <p>Award winners announced at this year's PyTorch Conference</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">About PyTorch Edge</span>
                  <p>Build innovative and privacy-aware AI experiences for edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch</span>
                  <p>End-to-end solution for enabling on-device inference capabilities across mobile and edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch Docs</span>
                </a>
              </div>
            </div>  
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch</span>
                  <p>Explore the documentation for comprehensive guidance on how to use PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Domains</span>
                  <p>Read the PyTorch Domains documentation to learn more about domain-specific libraries</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Blogs & News 
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Blog</span>
                  <p>Catch up on the latest technical news and happenings</p>
                </a>
                 <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Blog</span>
                  <p>Stories from the PyTorch ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Videos</span>
                  <p>Learn about the latest PyTorch tutorials, new, and more </p>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Newsletter</span>
                  <p>Stay up-to-date with the latest updates</p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                About
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn more about the PyTorch Foundation</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contact Us</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown">
              <a href="" data-cta="join">
                Become a Member
              </a>
            </div>
          </li>
          <li>
           <div class="main-menu-item">
             <a href="" class="github-icon">
             </a>
           </div>
          </li>
          <!--- TODO: This block adds the search icon to the nav bar. We will enable it later. 
          <li>
            <div class="main-menu-item">
             <a href="" class="search-icon">
             </a>
            </div>
          </li>
          --->
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Home</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="index.html">
    Python API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../notes/index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../lang-bindings/index.html">
    Language Bindings
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="index.html">
    Python API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../notes/index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../lang-bindings/index.html">
    Language Bindings
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Quantization</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-torch.ao.quantization">
<span id="quantization"></span><span id="quantization-doc"></span><h1>Quantization<a class="headerlink" href="#module-torch.ao.quantization" title="Link to this heading">#</a></h1>
<div class="admonition warning" id="module-torch.ao.quantization.fx">
<p class="admonition-title">Warning</p>
<p>Quantization is in beta and subject to change.</p>
</div>
<section id="introduction-to-quantization">
<h2>Introduction to Quantization<a class="headerlink" href="#introduction-to-quantization" title="Link to this heading">#</a></h2>
<p>Quantization refers to techniques for performing computations and storing
tensors at lower bitwidths than floating point precision. A quantized model
executes some or all of the operations on tensors with reduced precision rather than
full precision (floating point) values. This allows for a more compact model representation and
the use of high performance vectorized operations on many hardware platforms.
PyTorch supports INT8 quantization compared to typical FP32 models allowing for
a 4x reduction in the model size and a 4x reduction in memory bandwidth
requirements. Hardware support for INT8 computations is typically 2 to 4
times faster compared to FP32 compute. Quantization is primarily a technique to
speed up inference and only the forward pass is supported for quantized
operators.</p>
<p>PyTorch supports multiple approaches to quantizing a deep learning model. In
most cases the model is trained in FP32 and then the model is converted to
INT8. In addition, PyTorch also supports quantization aware training, which
models quantization errors in both the forward and backward passes using
fake-quantization modules. Note that the entire computation is carried out in
floating point. At the end of quantization aware training, PyTorch provides
conversion functions to convert the trained model into lower precision.</p>
<p>At lower level, PyTorch provides a way to represent quantized tensors and
perform operations with them. They can be used to directly construct models
that perform all or part of the computation in lower precision. Higher-level
APIs are provided that incorporate typical workflows of converting FP32 model
to lower precision with minimal accuracy loss.</p>
</section>
<section id="quantization-api-summary">
<h2>Quantization API Summary<a class="headerlink" href="#quantization-api-summary" title="Link to this heading">#</a></h2>
<p>PyTorch provides three different modes of quantization: Eager Mode Quantization, FX Graph Mode Quantization (maintenance) and PyTorch 2 Export Quantization.</p>
<p>Eager Mode Quantization is a beta feature. User needs to do fusion and specify where quantization and dequantization happens manually, also it only supports modules and not functionals.</p>
<p>FX Graph Mode Quantization is an automated quantization workflow in PyTorch, and currently it’s a prototype feature, it is in maintenance mode since we have PyTorch 2 Export Quantization. It improves upon Eager Mode Quantization by adding support for functionals and automating the quantization process, although people might need to refactor the model to make the model compatible with FX Graph Mode Quantization (symbolically traceable with <code class="docutils literal notranslate"><span class="pre">torch.fx</span></code>). Note that FX Graph Mode Quantization is not expected to work on arbitrary models since the model might not be symbolically traceable, we will integrate it into domain libraries like torchvision and users will be able to quantize models similar to the ones in supported domain libraries with FX Graph Mode Quantization. For arbitrary models we’ll provide general guidelines, but to actually make it work, users might need to be familiar with <code class="docutils literal notranslate"><span class="pre">torch.fx</span></code>, especially on how to make a model symbolically traceable.</p>
<p>PyTorch 2 Export Quantization is the new full graph mode quantization workflow, released as prototype feature in PyTorch 2.1. With PyTorch 2, we are moving to a better solution for full program capture (torch.export) since it can capture a higher percentage (88.8% on 14K models) of models compared to torch.fx.symbolic_trace (72.7% on 14K models), the program capture solution used by FX Graph Mode Quantization. torch.export still has limitations around some python constructs and requires user involvement to support dynamism in the exported model, but overall it is an improvement over the previous program capture solution. PyTorch 2 Export Quantization is built for models captured by torch.export, with flexibility and productivity of both modeling users and backend developers in mind. The main features are
(1). Programmable API for configuring how a model is quantized that can scale to many more use cases
(2). Simplified UX for modeling users and backend developers since they only need to interact with a single object (Quantizer) for expressing user’s intention about how to quantize a model and what the backend support.
(3). Optional reference quantized model representation that can represent quantized computation with integer operations that maps closer to actual quantized computations that happens in hardware.</p>
<p>New users of quantization are encouraged to try out PyTorch 2 Export Quantization first, if it does not work well, user can try eager mode quantization.</p>
<p>The following table compares the differences between Eager Mode Quantization, FX Graph Mode Quantization and PyTorch 2 Export Quantization:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td></td>
<td><p>Eager Mode
Quantization</p></td>
<td><p>FX Graph
Mode
Quantization</p></td>
<td><p>PyTorch 2 Export
Quantization</p></td>
</tr>
<tr class="row-even"><td><p>Release
Status</p></td>
<td><p>beta</p></td>
<td><p>prototype
(maintenance)</p></td>
<td><p>prototype</p></td>
</tr>
<tr class="row-odd"><td><p>Operator
Fusion</p></td>
<td><p>Manual</p></td>
<td><p>Automatic</p></td>
<td><p>Automatic</p></td>
</tr>
<tr class="row-even"><td><p>Quant/DeQuant
Placement</p></td>
<td><p>Manual</p></td>
<td><p>Automatic</p></td>
<td><p>Automatic</p></td>
</tr>
<tr class="row-odd"><td><p>Quantizing
Modules</p></td>
<td><p>Supported</p></td>
<td><p>Supported</p></td>
<td><p>Supported</p></td>
</tr>
<tr class="row-even"><td><p>Quantizing
Functionals/Torch
Ops</p></td>
<td><p>Manual</p></td>
<td><p>Automatic</p></td>
<td><p>Supported</p></td>
</tr>
<tr class="row-odd"><td><p>Support for
Customization</p></td>
<td><p>Limited Support</p></td>
<td><p>Fully
Supported</p></td>
<td><p>Fully Supported</p></td>
</tr>
<tr class="row-even"><td><p>Quantization Mode
Support</p></td>
<td><p>Post Training
Quantization:
Static, Dynamic,
Weight Only</p>
<p>Quantization Aware
Training:
Static</p>
</td>
<td><p>Post Training
Quantization:
Static, Dynamic,
Weight Only</p>
<p>Quantization Aware
Training:
Static</p>
</td>
<td><p>Defined by
Backend Specific
Quantizer</p></td>
</tr>
<tr class="row-odd"><td><p>Input/Output
Model Type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>
(May need some
refactors to make
the model
compatible with FX
Graph Mode
Quantization)</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">torch.fx.GraphModule</span></code>
(captured by
<code class="docutils literal notranslate"><span class="pre">torch.export</span></code></p></td>
</tr>
</tbody>
</table>
</div>
<p>There are three types of quantization supported:</p>
<ol class="arabic simple">
<li><p>dynamic quantization (weights quantized with activations read/stored in
floating point and quantized for compute)</p></li>
<li><p>static quantization (weights quantized, activations quantized, calibration
required post training)</p></li>
<li><p>static quantization aware training (weights quantized, activations quantized,
quantization numerics modeled during training)</p></li>
</ol>
<p>Please see our <a class="reference external" href="https://pytorch.org/blog/introduction-to-quantization-on-pytorch/">Introduction to Quantization on PyTorch</a> blog post
for a more comprehensive overview of the tradeoffs between these quantization
types.</p>
<p>Operator coverage varies between dynamic and static quantization and is captured in the table below.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td></td>
<td><p>Static
Quantization</p></td>
<td><p>Dynamic
Quantization</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">nn.Linear</div>
<div class="line">nn.Conv1d/2d/3d</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">Y</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">N</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">nn.LSTM</div>
<div class="line"><br /></div>
<div class="line">nn.GRU</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y (through</div>
<div class="line">custom modules)</div>
<div class="line">N</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line"><br /></div>
<div class="line">Y</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">nn.RNNCell</div>
<div class="line">nn.GRUCell</div>
<div class="line">nn.LSTMCell</div>
</div>
</td>
<td><div class="line-block">
<div class="line">N</div>
<div class="line">N</div>
<div class="line">N</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">Y</div>
<div class="line">Y</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>nn.EmbeddingBag</p></td>
<td><p>Y (activations
are in fp32)</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>nn.Embedding</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>nn.MultiheadAttention</p></td>
<td><p>Y (through
custom modules)</p></td>
<td><p>Not supported</p></td>
</tr>
<tr class="row-even"><td><p>Activations</p></td>
<td><p>Broadly supported</p></td>
<td><p>Un-changed,
computations
stay in fp32</p></td>
</tr>
</tbody>
</table>
</div>
<section id="eager-mode-quantization">
<h3>Eager Mode Quantization<a class="headerlink" href="#eager-mode-quantization" title="Link to this heading">#</a></h3>
<p>For a general introduction to the quantization flow, including different types of quantization, please take a look at <a class="reference internal" href="#general-quantization-flow">General Quantization Flow</a>.</p>
<section id="post-training-dynamic-quantization">
<h4>Post Training Dynamic Quantization<a class="headerlink" href="#post-training-dynamic-quantization" title="Link to this heading">#</a></h4>
<p>This is the simplest to apply form of quantization where the weights are
quantized ahead of time but the activations are dynamically quantized
during inference. This is used for situations where the model execution time
is dominated by loading weights from memory rather than computing the matrix
multiplications. This is true for LSTM and Transformer type models with
small batch size.</p>
<p>Diagram:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># original model</span>
<span class="c1"># all tensors and computations are in floating point</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                 <span class="o">/</span>
<span class="n">linear_weight_fp32</span>

<span class="c1"># dynamically quantized model</span>
<span class="c1"># linear and LSTM weights are in int8</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_int8_w_fp32_inp</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                     <span class="o">/</span>
   <span class="n">linear_weight_int8</span>
</pre></div>
</div>
<p>PTDQ API Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="c1"># define a floating point model</span>
<span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># create a model instance</span>
<span class="n">model_fp32</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>
<span class="c1"># create a quantized model instance</span>
<span class="n">model_int8</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">quantize_dynamic</span><span class="p">(</span>
    <span class="n">model_fp32</span><span class="p">,</span>  <span class="c1"># the original model</span>
    <span class="p">{</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">},</span>  <span class="c1"># a set of layers to dynamically quantize</span>
    <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">qint8</span><span class="p">)</span>  <span class="c1"># the target dtype for quantized weights</span>

<span class="c1"># run the model</span>
<span class="n">input_fp32</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model_int8</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
</pre></div>
</div>
<p>To learn more about dynamic quantization please see our <a class="reference external" href="https://pytorch.org/tutorials/recipes/recipes/dynamic_quantization.html">dynamic quantization tutorial</a>.</p>
</section>
<section id="post-training-static-quantization">
<h4>Post Training Static Quantization<a class="headerlink" href="#post-training-static-quantization" title="Link to this heading">#</a></h4>
<p>Post Training Static Quantization (PTQ static) quantizes the weights and activations of the model.  It
fuses activations into preceding layers where possible.  It requires
calibration with a representative dataset to determine optimal quantization
parameters for activations. Post Training Static Quantization is typically used when
both memory bandwidth and compute savings are important with CNNs being a
typical use case.</p>
<p>We may need to modify the model before applying post training static quantization. Please see <a class="reference internal" href="#model-preparation-for-eager-mode-static-quantization">Model Preparation for Eager Mode Static Quantization</a>.</p>
<p>Diagram:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># original model</span>
<span class="c1"># all tensors and computations are in floating point</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                    <span class="o">/</span>
    <span class="n">linear_weight_fp32</span>

<span class="c1"># statically quantized model</span>
<span class="c1"># weights and activations are in int8</span>
<span class="n">previous_layer_int8</span> <span class="o">--</span> <span class="n">linear_with_activation_int8</span> <span class="o">--</span> <span class="n">next_layer_int8</span>
                    <span class="o">/</span>
  <span class="n">linear_weight_int8</span>
</pre></div>
</div>
<p>PTSQ API Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="c1"># define a floating point model where some layers could be statically quantized</span>
<span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># QuantStub converts tensors from floating point to quantized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="c1"># DeQuantStub converts tensors from quantized to floating point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">DeQuantStub</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># manually specify where tensors will be converted from floating</span>
        <span class="c1"># point to quantized in the quantized model</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># manually specify where tensors will be converted from quantized</span>
        <span class="c1"># to floating point in the quantized model</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># create a model instance</span>
<span class="n">model_fp32</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>

<span class="c1"># model must be set to eval mode for static quantization logic to work</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="c1"># attach a global qconfig, which contains information about what kind</span>
<span class="c1"># of observers to attach. Use &#39;x86&#39; for server inference and &#39;qnnpack&#39;</span>
<span class="c1"># for mobile inference. Other quantization configurations such as selecting</span>
<span class="c1"># symmetric or asymmetric quantization and MinMax or L2Norm calibration techniques</span>
<span class="c1"># can be specified here.</span>
<span class="c1"># Note: the old &#39;fbgemm&#39; is still available but &#39;x86&#39; is the recommended default</span>
<span class="c1"># for server inference.</span>
<span class="c1"># model_fp32.qconfig = torch.ao.quantization.get_default_qconfig(&#39;fbgemm&#39;)</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">&#39;x86&#39;</span><span class="p">)</span>

<span class="c1"># Fuse the activations to preceding layers, where applicable.</span>
<span class="c1"># This needs to be done manually depending on the model architecture.</span>
<span class="c1"># Common fusions include `conv + relu` and `conv + batchnorm + relu`</span>
<span class="n">model_fp32_fused</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">fuse_modules</span><span class="p">(</span><span class="n">model_fp32</span><span class="p">,</span> <span class="p">[[</span><span class="s1">&#39;conv&#39;</span><span class="p">,</span> <span class="s1">&#39;relu&#39;</span><span class="p">]])</span>

<span class="c1"># Prepare the model for static quantization. This inserts observers in</span>
<span class="c1"># the model that will observe activation tensors during calibration.</span>
<span class="n">model_fp32_prepared</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span><span class="n">model_fp32_fused</span><span class="p">)</span>

<span class="c1"># calibrate the prepared model to determine quantization parameters for activations</span>
<span class="c1"># in a real world setting, the calibration would be done with a representative dataset</span>
<span class="n">input_fp32</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">model_fp32_prepared</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>

<span class="c1"># Convert the observed model to a quantized model. This does several things:</span>
<span class="c1"># quantizes the weights, computes and stores the scale and bias value to be</span>
<span class="c1"># used with each activation tensor, and replaces key operators with quantized</span>
<span class="c1"># implementations.</span>
<span class="n">model_int8</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">model_fp32_prepared</span><span class="p">)</span>

<span class="c1"># run the model, relevant calculations will happen in int8</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model_int8</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
</pre></div>
</div>
<p>To learn more about static quantization, please see the <a class="reference external" href="https://pytorch.org/tutorials/advanced/static_quantization_tutorial.html">static quantization tutorial</a>.</p>
</section>
<section id="quantization-aware-training-for-static-quantization">
<h4>Quantization Aware Training for Static Quantization<a class="headerlink" href="#quantization-aware-training-for-static-quantization" title="Link to this heading">#</a></h4>
<p>Quantization Aware Training (QAT) models the effects of quantization during training
allowing for higher accuracy compared to other quantization methods. We can do QAT for static, dynamic or weight only quantization.  During
training, all calculations are done in floating point, with fake_quant modules
modeling the effects of quantization by clamping and rounding to simulate the
effects of INT8.  After model conversion, weights and
activations are quantized, and activations are fused into the preceding layer
where possible.  It is commonly used with CNNs and yields a higher accuracy
compared to static quantization.</p>
<p>We may need to modify the model before applying post training static quantization. Please see <a class="reference internal" href="#model-preparation-for-eager-mode-static-quantization">Model Preparation for Eager Mode Static Quantization</a>.</p>
<p>Diagram:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># original model</span>
<span class="c1"># all tensors and computations are in floating point</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                      <span class="o">/</span>
    <span class="n">linear_weight_fp32</span>

<span class="c1"># model with fake_quants for modeling quantization numerics during training</span>
<span class="n">previous_layer_fp32</span> <span class="o">--</span> <span class="n">fq</span> <span class="o">--</span> <span class="n">linear_fp32</span> <span class="o">--</span> <span class="n">activation_fp32</span> <span class="o">--</span> <span class="n">fq</span> <span class="o">--</span> <span class="n">next_layer_fp32</span>
                           <span class="o">/</span>
   <span class="n">linear_weight_fp32</span> <span class="o">--</span> <span class="n">fq</span>

<span class="c1"># quantized model</span>
<span class="c1"># weights and activations are in int8</span>
<span class="n">previous_layer_int8</span> <span class="o">--</span> <span class="n">linear_with_activation_int8</span> <span class="o">--</span> <span class="n">next_layer_int8</span>
                     <span class="o">/</span>
   <span class="n">linear_weight_int8</span>
</pre></div>
</div>
<p>QAT API Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="c1"># define a floating point model where some layers could benefit from QAT</span>
<span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># QuantStub converts tensors from floating point to quantized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>
        <span class="c1"># DeQuantStub converts tensors from quantized to floating point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">DeQuantStub</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># create a model instance</span>
<span class="n">model_fp32</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>

<span class="c1"># model must be set to eval for fusion to work</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="c1"># attach a global qconfig, which contains information about what kind</span>
<span class="c1"># of observers to attach. Use &#39;x86&#39; for server inference and &#39;qnnpack&#39;</span>
<span class="c1"># for mobile inference. Other quantization configurations such as selecting</span>
<span class="c1"># symmetric or asymmetric quantization and MinMax or L2Norm calibration techniques</span>
<span class="c1"># can be specified here.</span>
<span class="c1"># Note: the old &#39;fbgemm&#39; is still available but &#39;x86&#39; is the recommended default</span>
<span class="c1"># for server inference.</span>
<span class="c1"># model_fp32.qconfig = torch.ao.quantization.get_default_qconfig(&#39;fbgemm&#39;)</span>
<span class="n">model_fp32</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">&#39;x86&#39;</span><span class="p">)</span>

<span class="c1"># fuse the activations to preceding layers, where applicable</span>
<span class="c1"># this needs to be done manually depending on the model architecture</span>
<span class="n">model_fp32_fused</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">fuse_modules</span><span class="p">(</span><span class="n">model_fp32</span><span class="p">,</span>
    <span class="p">[[</span><span class="s1">&#39;conv&#39;</span><span class="p">,</span> <span class="s1">&#39;bn&#39;</span><span class="p">,</span> <span class="s1">&#39;relu&#39;</span><span class="p">]])</span>

<span class="c1"># Prepare the model for QAT. This inserts observers and fake_quants in</span>
<span class="c1"># the model needs to be set to train for QAT logic to work</span>
<span class="c1"># the model that will observe weight and activation tensors during calibration.</span>
<span class="n">model_fp32_prepared</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">prepare_qat</span><span class="p">(</span><span class="n">model_fp32_fused</span><span class="o">.</span><span class="n">train</span><span class="p">())</span>

<span class="c1"># run the training loop (not shown)</span>
<span class="n">training_loop</span><span class="p">(</span><span class="n">model_fp32_prepared</span><span class="p">)</span>

<span class="c1"># Convert the observed model to a quantized model. This does several things:</span>
<span class="c1"># quantizes the weights, computes and stores the scale and bias value to be</span>
<span class="c1"># used with each activation tensor, fuses modules where appropriate,</span>
<span class="c1"># and replaces key operators with quantized implementations.</span>
<span class="n">model_fp32_prepared</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">model_int8</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">model_fp32_prepared</span><span class="p">)</span>

<span class="c1"># run the model, relevant calculations will happen in int8</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">model_int8</span><span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
</pre></div>
</div>
<p>To learn more about quantization aware training, please see the <a class="reference external" href="https://pytorch.org/tutorials/advanced/static_quantization_tutorial.html">QAT
tutorial</a>.</p>
</section>
<section id="model-preparation-for-eager-mode-static-quantization">
<h4>Model Preparation for Eager Mode Static Quantization<a class="headerlink" href="#model-preparation-for-eager-mode-static-quantization" title="Link to this heading">#</a></h4>
<p>It is necessary to currently make some modifications to the model definition
prior to Eager mode quantization. This is because currently quantization works on a module
by module basis. Specifically, for all quantization techniques, the user needs to:</p>
<ol class="arabic simple">
<li><p>Convert any operations that require output requantization (and thus have
additional parameters) from functionals to module form (for example,
using <code class="docutils literal notranslate"><span class="pre">torch.nn.ReLU</span></code> instead of <code class="docutils literal notranslate"><span class="pre">torch.nn.functional.relu</span></code>).</p></li>
<li><p>Specify which parts of the model need to be quantized either by assigning
<code class="docutils literal notranslate"><span class="pre">.qconfig</span></code> attributes on submodules or by specifying <code class="docutils literal notranslate"><span class="pre">qconfig_mapping</span></code>.
For example, setting <code class="docutils literal notranslate"><span class="pre">model.conv1.qconfig</span> <span class="pre">=</span> <span class="pre">None</span></code> means that the
<code class="docutils literal notranslate"><span class="pre">model.conv</span></code> layer will not be quantized, and setting
<code class="docutils literal notranslate"><span class="pre">model.linear1.qconfig</span> <span class="pre">=</span> <span class="pre">custom_qconfig</span></code> means that the quantization
settings for <code class="docutils literal notranslate"><span class="pre">model.linear1</span></code> will be using <code class="docutils literal notranslate"><span class="pre">custom_qconfig</span></code> instead
of the global qconfig.</p></li>
</ol>
<p>For static quantization techniques which quantize activations, the user needs
to do the following in addition:</p>
<ol class="arabic simple">
<li><p>Specify where activations are quantized and de-quantized. This is done using
<a class="reference internal" href="generated/torch.ao.quantization.QuantStub.html#torch.ao.quantization.QuantStub" title="torch.ao.quantization.QuantStub"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantStub</span></code></a> and
<a class="reference internal" href="generated/torch.ao.quantization.DeQuantStub.html#torch.ao.quantization.DeQuantStub" title="torch.ao.quantization.DeQuantStub"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeQuantStub</span></code></a> modules.</p></li>
<li><p>Use <a class="reference internal" href="generated/torch.ao.nn.quantized.FloatFunctional.html#torch.ao.nn.quantized.FloatFunctional" title="torch.ao.nn.quantized.FloatFunctional"><code class="xref py py-class docutils literal notranslate"><span class="pre">FloatFunctional</span></code></a> to wrap tensor operations
that require special handling for quantization into modules. Examples
are operations like <code class="docutils literal notranslate"><span class="pre">add</span></code> and <code class="docutils literal notranslate"><span class="pre">cat</span></code> which require special handling to
determine output quantization parameters.</p></li>
<li><p>Fuse modules: combine operations/modules into a single module to obtain
higher accuracy and performance. This is done using the
<a class="reference internal" href="generated/torch.ao.quantization.fuse_modules.fuse_modules.html#torch.ao.quantization.fuse_modules.fuse_modules" title="torch.ao.quantization.fuse_modules.fuse_modules"><code class="xref py py-func docutils literal notranslate"><span class="pre">fuse_modules()</span></code></a> API, which takes in lists of modules
to be fused. We currently support the following fusions:
[Conv, Relu], [Conv, BatchNorm], [Conv, BatchNorm, Relu], [Linear, Relu]</p></li>
</ol>
</section>
</section>
<section id="prototype-maintenance-mode-fx-graph-mode-quantization">
<h3>(Prototype - maintenance mode) FX Graph Mode Quantization<a class="headerlink" href="#prototype-maintenance-mode-fx-graph-mode-quantization" title="Link to this heading">#</a></h3>
<p>There are multiple quantization types in post training quantization (weight only, dynamic and static) and the configuration is done through <cite>qconfig_mapping</cite> (an argument of the <cite>prepare_fx</cite> function).</p>
<p>FXPTQ API Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.ao.quantization</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
  <span class="n">get_default_qconfig_mapping</span><span class="p">,</span>
  <span class="n">get_default_qat_qconfig_mapping</span><span class="p">,</span>
  <span class="n">QConfigMapping</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.ao.quantization.quantize_fx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">quantize_fx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>

<span class="n">model_fp</span> <span class="o">=</span> <span class="n">UserModel</span><span class="p">()</span>

<span class="c1">#</span>
<span class="c1"># post training dynamic/weight_only quantization</span>
<span class="c1">#</span>

<span class="c1"># we need to deepcopy if we still want to keep model_fp unchanged after quantization since quantization apis change the input model</span>
<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">model_to_quantize</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">qconfig_mapping</span> <span class="o">=</span> <span class="n">QConfigMapping</span><span class="p">()</span><span class="o">.</span><span class="n">set_global</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">default_dynamic_qconfig</span><span class="p">)</span>
<span class="c1"># a tuple of one or more example inputs are needed to trace the model</span>
<span class="n">example_inputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_fp32</span><span class="p">)</span>
<span class="c1"># prepare</span>
<span class="n">model_prepared</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">,</span> <span class="n">qconfig_mapping</span><span class="p">,</span> <span class="n">example_inputs</span><span class="p">)</span>
<span class="c1"># no calibration needed when we only have dynamic/weight_only quantization</span>
<span class="c1"># quantize</span>
<span class="n">model_quantized</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span><span class="n">model_prepared</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># post training static quantization</span>
<span class="c1">#</span>

<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">qconfig_mapping</span> <span class="o">=</span> <span class="n">get_default_qconfig_mapping</span><span class="p">(</span><span class="s2">&quot;qnnpack&quot;</span><span class="p">)</span>
<span class="n">model_to_quantize</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="c1"># prepare</span>
<span class="n">model_prepared</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">,</span> <span class="n">qconfig_mapping</span><span class="p">,</span> <span class="n">example_inputs</span><span class="p">)</span>
<span class="c1"># calibrate (not shown)</span>
<span class="c1"># quantize</span>
<span class="n">model_quantized</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span><span class="n">model_prepared</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># quantization aware training for static quantization</span>
<span class="c1">#</span>

<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">qconfig_mapping</span> <span class="o">=</span> <span class="n">get_default_qat_qconfig_mapping</span><span class="p">(</span><span class="s2">&quot;qnnpack&quot;</span><span class="p">)</span>
<span class="n">model_to_quantize</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
<span class="c1"># prepare</span>
<span class="n">model_prepared</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_qat_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">,</span> <span class="n">qconfig_mapping</span><span class="p">,</span> <span class="n">example_inputs</span><span class="p">)</span>
<span class="c1"># training loop (not shown)</span>
<span class="c1"># quantize</span>
<span class="n">model_quantized</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span><span class="n">model_prepared</span><span class="p">)</span>

<span class="c1">#</span>
<span class="c1"># fusion</span>
<span class="c1">#</span>
<span class="n">model_to_quantize</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">model_fp</span><span class="p">)</span>
<span class="n">model_fused</span> <span class="o">=</span> <span class="n">quantize_fx</span><span class="o">.</span><span class="n">fuse_fx</span><span class="p">(</span><span class="n">model_to_quantize</span><span class="p">)</span>
</pre></div>
</div>
<p>Please follow the tutorials below to learn more about FX Graph Mode Quantization:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_quant_guide.html">User Guide on Using FX Graph Mode Quantization</a></p></li>
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_ptq_static.html">FX Graph Mode Post Training Static Quantization</a></p></li>
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_ptq_dynamic.html">FX Graph Mode Post Training Dynamic Quantization</a></p></li>
</ul>
</section>
<section id="prototype-pytorch-2-export-quantization">
<h3>(Prototype) PyTorch 2 Export Quantization<a class="headerlink" href="#prototype-pytorch-2-export-quantization" title="Link to this heading">#</a></h3>
<p>API Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.ao.quantization.quantize_pt2e</span><span class="w"> </span><span class="kn">import</span> <span class="n">prepare_pt2e</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.export</span><span class="w"> </span><span class="kn">import</span> <span class="n">export_for_training</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.ao.quantization.quantizer</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">XNNPACKQuantizer</span><span class="p">,</span>
    <span class="n">get_symmetric_quantization_config</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
       <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># initialize a floating point model</span>
<span class="n">float_model</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>

<span class="c1"># define calibration function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calibrate</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data_loader</span><span class="p">):</span>
    <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">data_loader</span><span class="p">:</span>
            <span class="n">model</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>

<span class="c1"># Step 1. program capture</span>
<span class="c1"># NOTE: this API will be updated to torch.export API in the future, but the captured</span>
<span class="c1"># result should mostly stay the same</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">export_for_training</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">example_inputs</span><span class="p">)</span><span class="o">.</span><span class="n">module</span><span class="p">()</span>
<span class="c1"># we get a model with aten ops</span>

<span class="c1"># Step 2. quantization</span>
<span class="c1"># backend developer will write their own Quantizer and expose methods to allow</span>
<span class="c1"># users to express how they</span>
<span class="c1"># want the model to be quantized</span>
<span class="n">quantizer</span> <span class="o">=</span> <span class="n">XNNPACKQuantizer</span><span class="p">()</span><span class="o">.</span><span class="n">set_global</span><span class="p">(</span><span class="n">get_symmetric_quantization_config</span><span class="p">())</span>
<span class="c1"># or prepare_qat_pt2e for Quantization Aware Training</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">prepare_pt2e</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">quantizer</span><span class="p">)</span>

<span class="c1"># run calibration</span>
<span class="c1"># calibrate(m, sample_inference_data)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">convert_pt2e</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="c1"># Step 3. lowering</span>
<span class="c1"># lower to target backend</span>
</pre></div>
</div>
<p>Please follow these tutorials to get started on PyTorch 2 Export Quantization:</p>
<p>Modeling Users:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/pt2e_quant_ptq.html">PyTorch 2 Export Post Training Quantization</a></p></li>
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/pt2e_quant_x86_inductor.html">PyTorch 2 Export Post Training Quantization with X86 Backend through Inductor</a></p></li>
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/pt2e_quant_qat.html">PyTorch 2 Export Quantization Aware Training</a></p></li>
</ul>
<p>Backend Developers (please check out all Modeling Users docs as well):</p>
<ul class="simple">
<li><p><a class="reference external" href="https://pytorch.org/tutorials/prototype/pt2e_quantizer.html">How to Write a Quantizer for PyTorch 2 Export Quantization</a></p></li>
</ul>
</section>
</section>
<section id="quantization-stack">
<h2>Quantization Stack<a class="headerlink" href="#quantization-stack" title="Link to this heading">#</a></h2>
<p>Quantization is the process to convert a floating point model to a quantized model. So at high level the quantization stack can be split into two parts: 1). The building blocks or abstractions for a quantized model 2). The building blocks or abstractions for the quantization flow that converts a floating point model to a quantized model</p>
<section id="quantized-model">
<h3>Quantized Model<a class="headerlink" href="#quantized-model" title="Link to this heading">#</a></h3>
<section id="quantized-tensor">
<h4>Quantized Tensor<a class="headerlink" href="#quantized-tensor" title="Link to this heading">#</a></h4>
<p>In order to do quantization in PyTorch, we need to be able to represent
quantized data in Tensors. A Quantized Tensor allows for storing
quantized data (represented as int8/uint8/int32) along with quantization
parameters like scale and zero_point. Quantized Tensors allow for many
useful operations making quantized arithmetic easy, in addition to
allowing for serialization of data in a quantized format.</p>
<p>PyTorch supports both per tensor and per channel symmetric and asymmetric quantization. Per tensor means that all the values within the tensor are quantized the same way with the same quantization parameters. Per channel means that for each dimension, typically the channel dimension of a tensor, the values in the tensor are quantized with different quantization parameters. This allows for less error in converting tensors to quantized values since outlier values would only impact the channel it was in, instead of the entire Tensor.</p>
<p>The mapping is performed by converting the floating point tensors using</p>
<a class="reference internal image-reference" href="python-api/math-quantizer-equation.png"><img alt="python-api/math-quantizer-equation.png" src="python-api/math-quantizer-equation.png" style="width: 40%;" />
</a>
<p>Note that, we ensure that zero in floating point is represented with no error
after quantization, thereby ensuring that operations like padding do not cause
additional quantization error.</p>
<p>Here are a few key attributes for quantized Tensor:</p>
<ul class="simple">
<li><p>QScheme (torch.qscheme): a enum that specifies the way we quantize the Tensor</p>
<ul>
<li><p>torch.per_tensor_affine</p></li>
<li><p>torch.per_tensor_symmetric</p></li>
<li><p>torch.per_channel_affine</p></li>
<li><p>torch.per_channel_symmetric</p></li>
</ul>
</li>
<li><p>dtype (torch.dtype): data type of the quantized Tensor</p>
<ul>
<li><p>torch.quint8</p></li>
<li><p>torch.qint8</p></li>
<li><p>torch.qint32</p></li>
<li><p>torch.float16</p></li>
</ul>
</li>
<li><p>quantization parameters (varies based on QScheme): parameters for the chosen way of quantization</p>
<ul>
<li><p>torch.per_tensor_affine would have quantization parameters of</p>
<ul>
<li><p>scale (float)</p></li>
<li><p>zero_point (int)</p></li>
</ul>
</li>
<li><p>torch.per_channel_affine would have quantization parameters of</p>
<ul>
<li><p>per_channel_scales (list of float)</p></li>
<li><p>per_channel_zero_points (list of int)</p></li>
<li><p>axis (int)</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</section>
<section id="quantize-and-dequantize">
<h4>Quantize and Dequantize<a class="headerlink" href="#quantize-and-dequantize" title="Link to this heading">#</a></h4>
<p>The input and output of a model are floating point Tensors, but activations in the quantized model are quantized, so we need operators to convert between floating point and quantized Tensors.</p>
<ul class="simple">
<li><p>Quantize (float -&gt; quantized)</p>
<ul>
<li><p>torch.quantize_per_tensor(x, scale, zero_point, dtype)</p></li>
<li><p>torch.quantize_per_channel(x, scales, zero_points, axis, dtype)</p></li>
<li><p>torch.quantize_per_tensor_dynamic(x, dtype, reduce_range)</p></li>
<li><p>to(torch.float16)</p></li>
</ul>
</li>
<li><p>Dequantize (quantized -&gt; float)</p>
<ul>
<li><p>quantized_tensor.dequantize() - calling dequantize on a torch.float16 Tensor will convert the Tensor back to torch.float</p></li>
<li><p>torch.dequantize(x)</p></li>
</ul>
</li>
</ul>
</section>
<section id="quantized-operators-modules">
<h4>Quantized Operators/Modules<a class="headerlink" href="#quantized-operators-modules" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Quantized Operator are the operators that takes quantized Tensor as inputs, and outputs a quantized Tensor.</p></li>
<li><p>Quantized Modules are PyTorch Modules that performs quantized operations. They are typically defined for weighted operations like linear and conv.</p></li>
</ul>
</section>
<section id="quantized-engine">
<h4>Quantized Engine<a class="headerlink" href="#quantized-engine" title="Link to this heading">#</a></h4>
<p>When a quantized model is executed, the qengine (torch.backends.quantized.engine) specifies which backend is to be used for execution. It is important to ensure that the qengine is compatible with the quantized model in terms of value range of quantized activation and weights.</p>
</section>
</section>
<section id="quantization-flow">
<h3>Quantization Flow<a class="headerlink" href="#quantization-flow" title="Link to this heading">#</a></h3>
<section id="observer-and-fakequantize">
<h4>Observer and FakeQuantize<a class="headerlink" href="#observer-and-fakequantize" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Observer are PyTorch Modules used to:</p>
<ul>
<li><p>collect tensor statistics like min value and max value of the Tensor passing through the observer</p></li>
<li><p>and calculate quantization parameters based on the collected tensor statistics</p></li>
</ul>
</li>
<li><p>FakeQuantize are PyTorch Modules used to:</p>
<ul>
<li><p>simulate quantization (performing quantize/dequantize) for a Tensor in the network</p></li>
<li><p>it can calculate quantization parameters based on the collected statistics from observer, or it can learn the quantization parameters as well</p></li>
</ul>
</li>
</ul>
</section>
<section id="qconfig">
<h4>QConfig<a class="headerlink" href="#qconfig" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>QConfig is a namedtuple of Observer or FakeQuantize Module class that can are configurable with qscheme, dtype etc. it is used to configure how an operator should be observed</p>
<ul>
<li><p>Quantization configuration for an operator/module</p>
<ul>
<li><p>different types of Observer/FakeQuantize</p></li>
<li><p>dtype</p></li>
<li><p>qscheme</p></li>
<li><p>quant_min/quant_max: can be used to simulate lower precision Tensors</p></li>
</ul>
</li>
<li><p>Currently supports configuration for activation and weight</p></li>
<li><p>We insert input/weight/output observer based on the qconfig that is configured for a given operator or module</p></li>
</ul>
</li>
</ul>
</section>
<section id="general-quantization-flow">
<h4>General Quantization Flow<a class="headerlink" href="#general-quantization-flow" title="Link to this heading">#</a></h4>
<p>In general, the flow is the following</p>
<ul class="simple">
<li><p>prepare</p>
<ul>
<li><p>insert Observer/FakeQuantize modules based on user specified qconfig</p></li>
</ul>
</li>
<li><p>calibrate/train (depending on post training quantization or quantization aware training)</p>
<ul>
<li><p>allow Observers to collect statistics or FakeQuantize modules to learn the quantization parameters</p></li>
</ul>
</li>
<li><p>convert</p>
<ul>
<li><p>convert a calibrated/trained model to a quantized model</p></li>
</ul>
</li>
</ul>
<p>There are different modes of quantization, they can be classified in two ways:</p>
<p>In terms of where we apply the quantization flow, we have:</p>
<ol class="arabic simple">
<li><p>Post Training Quantization (apply quantization after training, quantization parameters are calculated based on sample calibration data)</p></li>
<li><p>Quantization Aware Training (simulate quantization during training so that the quantization parameters can be learned together with the model using training data)</p></li>
</ol>
<p>And in terms of how we quantize the operators, we can have:</p>
<ul class="simple">
<li><p>Weight Only Quantization (only weight is statically quantized)</p></li>
<li><p>Dynamic Quantization (weight is statically quantized, activation is dynamically quantized)</p></li>
<li><p>Static Quantization (both weight and activations are statically quantized)</p></li>
</ul>
<p>We can mix different ways of quantizing operators in the same quantization flow. For example, we can have post training quantization that has both statically and dynamically quantized operators.</p>
</section>
</section>
</section>
<section id="quantization-support-matrix">
<h2>Quantization Support Matrix<a class="headerlink" href="#quantization-support-matrix" title="Link to this heading">#</a></h2>
<section id="quantization-mode-support">
<h3>Quantization Mode Support<a class="headerlink" href="#quantization-mode-support" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td></td>
<td colspan="2"><p>Quantization
Mode</p></td>
<td><p>Dataset
Requirement</p></td>
<td><p>Works Best For</p></td>
<td><p>Accuracy</p></td>
<td><p>Notes</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>Post Training Quantization</p></td>
<td><p>Dynamic/Weight Only Quantization</p></td>
<td><p>activation
dynamically
quantized (fp16,
int8) or not
quantized, weight
statically quantized
(fp16, int8, in4)</p></td>
<td><p>None</p></td>
<td><p>LSTM, MLP,
Embedding,
Transformer</p></td>
<td><p>good</p></td>
<td><p>Easy to use,
close to static
quantization when
performance is
compute or memory
bound due to
weights</p></td>
</tr>
<tr class="row-odd"><td><p>Static Quantization</p></td>
<td><p>activation and
weights statically
quantized (int8)</p></td>
<td><p>calibration
dataset</p></td>
<td><p>CNN</p></td>
<td><p>good</p></td>
<td><p>Provides best
perf, may have
big impact on
accuracy, good
for hardwares
that only support
int8 computation</p></td>
</tr>
<tr class="row-even"><td rowspan="2"><p>Quantization Aware Training</p></td>
<td><p>Dynamic Quantization</p></td>
<td><p>activation and
weight are fake
quantized</p></td>
<td><p>fine-tuning
dataset</p></td>
<td><p>MLP, Embedding</p></td>
<td><p>best</p></td>
<td><p>Limited support
for now</p></td>
</tr>
<tr class="row-odd"><td><p>Static Quantization</p></td>
<td><p>activation and
weight are fake
quantized</p></td>
<td><p>fine-tuning
dataset</p></td>
<td><p>CNN, MLP,
Embedding</p></td>
<td><p>best</p></td>
<td><p>Typically used
when static
quantization
leads to bad
accuracy, and
used to close the
accuracy gap</p></td>
</tr>
</tbody>
</table>
</div>
<p>Please see our <a class="reference external" href="https://pytorch.org/blog/introduction-to-quantization-on-pytorch/">Introduction to Quantization on Pytorch</a> blog post
for a more comprehensive overview of the tradeoffs between these quantization
types.</p>
</section>
<section id="quantization-flow-support">
<h3>Quantization Flow Support<a class="headerlink" href="#quantization-flow-support" title="Link to this heading">#</a></h3>
<p>PyTorch provides two modes of quantization: Eager Mode Quantization and FX Graph Mode Quantization.</p>
<p>Eager Mode Quantization is a beta feature. User needs to do fusion and specify where quantization and dequantization happens manually, also it only supports modules and not functionals.</p>
<p>FX Graph Mode Quantization is an automated quantization framework in PyTorch, and currently it’s a prototype feature. It improves upon Eager Mode Quantization by adding support for functionals and automating the quantization process, although people might need to refactor the model to make the model compatible with FX Graph Mode Quantization (symbolically traceable with <code class="docutils literal notranslate"><span class="pre">torch.fx</span></code>). Note that FX Graph Mode Quantization is not expected to work on arbitrary models since the model might not be symbolically traceable, we will integrate it into domain libraries like torchvision and users will be able to quantize models similar to the ones in supported domain libraries with FX Graph Mode Quantization. For arbitrary models we’ll provide general guidelines, but to actually make it work, users might need to be familiar with <code class="docutils literal notranslate"><span class="pre">torch.fx</span></code>, especially on how to make a model symbolically traceable.</p>
<p>New users of quantization are encouraged to try out FX Graph Mode Quantization first, if it does not work, user may try to follow the guideline of <a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_quant_guide.html">using FX Graph Mode Quantization</a> or fall back to eager mode quantization.</p>
<p>The following table compares the differences between Eager Mode Quantization and FX Graph Mode Quantization:</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td></td>
<td><p>Eager Mode
Quantization</p></td>
<td><p>FX Graph
Mode
Quantization</p></td>
</tr>
<tr class="row-even"><td><p>Release
Status</p></td>
<td><p>beta</p></td>
<td><p>prototype</p></td>
</tr>
<tr class="row-odd"><td><p>Operator
Fusion</p></td>
<td><p>Manual</p></td>
<td><p>Automatic</p></td>
</tr>
<tr class="row-even"><td><p>Quant/DeQuant
Placement</p></td>
<td><p>Manual</p></td>
<td><p>Automatic</p></td>
</tr>
<tr class="row-odd"><td><p>Quantizing
Modules</p></td>
<td><p>Supported</p></td>
<td><p>Supported</p></td>
</tr>
<tr class="row-even"><td><p>Quantizing
Functionals/Torch
Ops</p></td>
<td><p>Manual</p></td>
<td><p>Automatic</p></td>
</tr>
<tr class="row-odd"><td><p>Support for
Customization</p></td>
<td><p>Limited Support</p></td>
<td><p>Fully
Supported</p></td>
</tr>
<tr class="row-even"><td><p>Quantization Mode
Support</p></td>
<td><p>Post Training
Quantization:
Static, Dynamic,
Weight Only</p>
<p>Quantization Aware
Training:
Static</p>
</td>
<td><p>Post Training
Quantization:
Static, Dynamic,
Weight Only</p>
<p>Quantization Aware
Training:
Static</p>
</td>
</tr>
<tr class="row-odd"><td><p>Input/Output
Model Type</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>
(May need some
refactors to make
the model
compatible with FX
Graph Mode
Quantization)</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="backend-hardware-support">
<h3>Backend/Hardware Support<a class="headerlink" href="#backend-hardware-support" title="Link to this heading">#</a></h3>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p>Hardware</p></td>
<td><p>Kernel Library</p></td>
<td><p>Eager Mode
Quantization</p></td>
<td><p>FX Graph
Mode
Quantization</p></td>
<td><p>Quantization
Mode Support</p></td>
</tr>
<tr class="row-even"><td><p>server CPU</p></td>
<td><p>fbgemm/onednn</p></td>
<td colspan="2" rowspan="2"><p>Supported</p></td>
<td rowspan="2"><p>All
Supported</p></td>
</tr>
<tr class="row-odd"><td><p>mobile CPU</p></td>
<td><p>qnnpack/xnnpack</p></td>
</tr>
<tr class="row-even"><td><p>server GPU</p></td>
<td><p>TensorRT (early
prototype)</p></td>
<td><p>Not support
this it
requires a
graph</p></td>
<td><p>Supported</p></td>
<td><p>Static
Quantization</p></td>
</tr>
</tbody>
</table>
</div>
<p>Today, PyTorch supports the following backends for running quantized operators efficiently:</p>
<ul class="simple">
<li><p>x86 CPUs with AVX2 support or higher (without AVX2 some operations have inefficient implementations), via <cite>x86</cite> optimized by <a class="reference external" href="https://github.com/pytorch/FBGEMM">fbgemm</a> and <a class="reference external" href="https://github.com/oneapi-src/oneDNN">onednn</a> (see the details at <a class="reference external" href="https://github.com/pytorch/pytorch/issues/83888">RFC</a>)</p></li>
<li><p>ARM CPUs (typically found in mobile/embedded devices), via <a class="reference external" href="https://github.com/pytorch/pytorch/tree/main/aten/src/ATen/native/quantized/cpu/qnnpack">qnnpack</a></p></li>
<li><p>(early prototype) support for NVidia GPU via <a class="reference external" href="https://developer.nvidia.com/tensorrt">TensorRT</a> through <cite>fx2trt</cite> (to be open sourced)</p></li>
</ul>
<section id="note-for-native-cpu-backends">
<h4>Note for native CPU backends<a class="headerlink" href="#note-for-native-cpu-backends" title="Link to this heading">#</a></h4>
<p>We expose both <cite>x86</cite> and <cite>qnnpack</cite> with the same native pytorch quantized operators, so we need additional flag to distinguish between them. The corresponding implementation of  <cite>x86</cite> and <cite>qnnpack</cite> is chosen automatically based on the PyTorch build mode, though users have the option to override this by setting <cite>torch.backends.quantization.engine</cite> to <cite>x86</cite> or <cite>qnnpack</cite>.</p>
<p>When preparing a quantized model, it is necessary to ensure that qconfig
and the engine used for quantized computations match the backend on which
the model will be executed. The qconfig controls the type of observers used
during the quantization passes. The qengine controls whether <cite>x86</cite> or <cite>qnnpack</cite>
specific packing function is used when packing weights for
linear and convolution functions and modules. For example:</p>
<p>Default settings for x86:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the qconfig for PTQ</span>
<span class="c1"># Note: the old &#39;fbgemm&#39; is still available but &#39;x86&#39; is the recommended default on x86 CPUs</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">&#39;x86&#39;</span><span class="p">)</span>
<span class="c1"># or, set the qconfig for QAT</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">&#39;x86&#39;</span><span class="p">)</span>
<span class="c1"># set the qengine to control weight packing</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">quantized</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">&#39;x86&#39;</span>
</pre></div>
</div>
<p>Default settings for qnnpack:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># set the qconfig for PTQ</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qconfig</span><span class="p">(</span><span class="s1">&#39;qnnpack&#39;</span><span class="p">)</span>
<span class="c1"># or, set the qconfig for QAT</span>
<span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">get_default_qat_qconfig</span><span class="p">(</span><span class="s1">&#39;qnnpack&#39;</span><span class="p">)</span>
<span class="c1"># set the qengine to control weight packing</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">quantized</span><span class="o">.</span><span class="n">engine</span> <span class="o">=</span> <span class="s1">&#39;qnnpack&#39;</span>
</pre></div>
</div>
</section>
</section>
<section id="operator-support">
<h3>Operator Support<a class="headerlink" href="#operator-support" title="Link to this heading">#</a></h3>
<p>Operator coverage varies between dynamic and static quantization and is captured in the table below.
Note that for FX Graph Mode Quantization, the corresponding functionals are also supported.</p>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td></td>
<td><p>Static
Quantization</p></td>
<td><p>Dynamic
Quantization</p></td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">nn.Linear</div>
<div class="line">nn.Conv1d/2d/3d</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">Y</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">N</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">nn.LSTM</div>
<div class="line">nn.GRU</div>
</div>
</td>
<td><div class="line-block">
<div class="line">N</div>
<div class="line">N</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">Y</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">nn.RNNCell</div>
<div class="line">nn.GRUCell</div>
<div class="line">nn.LSTMCell</div>
</div>
</td>
<td><div class="line-block">
<div class="line">N</div>
<div class="line">N</div>
<div class="line">N</div>
</div>
</td>
<td><div class="line-block">
<div class="line">Y</div>
<div class="line">Y</div>
<div class="line">Y</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>nn.EmbeddingBag</p></td>
<td><p>Y (activations
are in fp32)</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>nn.Embedding</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>nn.MultiheadAttention</p></td>
<td><p>Not Supported</p></td>
<td><p>Not supported</p></td>
</tr>
<tr class="row-even"><td><p>Activations</p></td>
<td><p>Broadly supported</p></td>
<td><p>Un-changed,
computations
stay in fp32</p></td>
</tr>
</tbody>
</table>
</div>
<p>Note: this will be updated with some information generated from native backend_config_dict soon.</p>
</section>
</section>
<section id="quantization-api-reference">
<h2>Quantization API Reference<a class="headerlink" href="#quantization-api-reference" title="Link to this heading">#</a></h2>
<p>The <a class="reference internal" href="quantization-support.html"><span class="doc">Quantization API Reference</span></a> contains documentation
of quantization APIs, such as quantization passes, quantized tensor operations,
and supported quantized modules and functions.</p>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="quantization-backend-configuration">
<h2>Quantization Backend Configuration<a class="headerlink" href="#quantization-backend-configuration" title="Link to this heading">#</a></h2>
<p>The <a class="reference internal" href="quantization-backend-configuration.html"><span class="doc">Quantization Backend Configuration</span></a> contains documentation
on how to configure the quantization workflows for various backends.</p>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="quantization-accuracy-debugging">
<h2>Quantization Accuracy Debugging<a class="headerlink" href="#quantization-accuracy-debugging" title="Link to this heading">#</a></h2>
<p>The <a class="reference internal" href="quantization-accuracy-debugging.html"><span class="doc">Quantization Accuracy Debugging</span></a> contains documentation
on how to debug quantization accuracy.</p>
<div class="toctree-wrapper compound">
</div>
</section>
<section id="quantization-customizations">
<h2>Quantization Customizations<a class="headerlink" href="#quantization-customizations" title="Link to this heading">#</a></h2>
<p>While default implementations of observers to select the scale factor and bias
based on observed tensor data are provided, developers can provide their own
quantization functions. Quantization can be applied selectively to different
parts of the model or configured differently for different parts of the model.</p>
<p>We also provide support for per channel quantization for <strong>conv1d()</strong>, <strong>conv2d()</strong>,
<strong>conv3d()</strong> and <strong>linear()</strong>.</p>
<p>Quantization workflows work by adding (e.g. adding observers as
<code class="docutils literal notranslate"><span class="pre">.observer</span></code> submodule) or replacing (e.g. converting <code class="docutils literal notranslate"><span class="pre">nn.Conv2d</span></code> to
<code class="docutils literal notranslate"><span class="pre">nn.quantized.Conv2d</span></code>) submodules in the model’s module hierarchy. It
means that the model stays a regular <code class="docutils literal notranslate"><span class="pre">nn.Module</span></code>-based instance throughout the
process and thus can work with the rest of PyTorch APIs.</p>
<section id="quantization-custom-module-api">
<h3>Quantization Custom Module API<a class="headerlink" href="#quantization-custom-module-api" title="Link to this heading">#</a></h3>
<p>Both Eager mode and FX graph mode quantization APIs provide a hook for the user
to specify module quantized in a custom way, with user defined logic for
observation and quantization. The user needs to specify:</p>
<ol class="arabic simple">
<li><p>The Python type of the source fp32 module (existing in the model)</p></li>
<li><p>The Python type of the observed module (provided by user). This module needs
to define a <cite>from_float</cite> function which defines how the observed module is
created from the original fp32 module.</p></li>
<li><p>The Python type of the quantized module (provided by user). This module needs
to define a <cite>from_observed</cite> function which defines how the quantized module is
created from the observed module.</p></li>
<li><p>A configuration describing (1), (2), (3) above, passed to the quantization APIs.</p></li>
</ol>
<p>The framework will then do the following:</p>
<ol class="arabic simple">
<li><p>during the <cite>prepare</cite> module swaps, it will convert every module of type
specified in (1) to the type specified in (2), using the <cite>from_float</cite> function of
the class in (2).</p></li>
<li><p>during the <cite>convert</cite> module swaps, it will convert every module of type
specified in (2) to the type specified in (3), using the <cite>from_observed</cite> function
of the class in (3).</p></li>
</ol>
<p>Currently, there is a requirement that <cite>ObservedCustomModule</cite> will have a single
Tensor output, and an observer will be added by the framework (not by the user)
on that output. The observer will be stored under the <cite>activation_post_process</cite> key
as an attribute of the custom module instance. Relaxing these restrictions may
be done at a future time.</p>
<p>Custom API Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.ao.nn.quantized</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nnq</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">torch.ao.quantization</span><span class="w"> </span><span class="kn">import</span> <span class="n">QConfigMapping</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch.ao.quantization.quantize_fx</span>

<span class="c1"># original fp32 module to replace</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CustomModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># custom observed module, provided by user</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ObservedCustomModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">linear</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_float</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">float_module</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">float_module</span><span class="p">,</span> <span class="s1">&#39;qconfig&#39;</span><span class="p">)</span>
        <span class="n">observed</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">float_module</span><span class="o">.</span><span class="n">linear</span><span class="p">)</span>
        <span class="n">observed</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">float_module</span><span class="o">.</span><span class="n">qconfig</span>
        <span class="k">return</span> <span class="n">observed</span>

<span class="c1"># custom quantized module, provided by user</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StaticQuantCustomModule</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">linear</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_observed</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">observed_module</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">observed_module</span><span class="p">,</span> <span class="s1">&#39;qconfig&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">observed_module</span><span class="p">,</span> <span class="s1">&#39;activation_post_process&#39;</span><span class="p">)</span>
        <span class="n">observed_module</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">activation_post_process</span> <span class="o">=</span> \
            <span class="n">observed_module</span><span class="o">.</span><span class="n">activation_post_process</span>
        <span class="n">quantized</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nnq</span><span class="o">.</span><span class="n">Linear</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="n">observed_module</span><span class="o">.</span><span class="n">linear</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">quantized</span>

<span class="c1">#</span>
<span class="c1"># example API call (Eager mode quantization)</span>
<span class="c1">#</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">CustomModule</span><span class="p">())</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepare_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;float_to_observed_custom_module_class&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">CustomModule</span><span class="p">:</span> <span class="n">ObservedCustomModule</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">convert_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;observed_to_quantized_custom_module_class&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">ObservedCustomModule</span><span class="p">:</span> <span class="n">StaticQuantCustomModule</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">m</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">default_qconfig</span>
<span class="n">mp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">prepare</span><span class="p">(</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">prepare_custom_config_dict</span><span class="o">=</span><span class="n">prepare_custom_config_dict</span><span class="p">)</span>
<span class="c1"># calibration (not shown)</span>
<span class="n">mq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
    <span class="n">mp</span><span class="p">,</span> <span class="n">convert_custom_config_dict</span><span class="o">=</span><span class="n">convert_custom_config_dict</span><span class="p">)</span>
<span class="c1">#</span>
<span class="c1"># example API call (FX graph mode quantization)</span>
<span class="c1">#</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">CustomModule</span><span class="p">())</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">qconfig_mapping</span> <span class="o">=</span> <span class="n">QConfigMapping</span><span class="p">()</span><span class="o">.</span><span class="n">set_global</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">default_qconfig</span><span class="p">)</span>
<span class="n">prepare_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;float_to_observed_custom_module_class&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;static&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">CustomModule</span><span class="p">:</span> <span class="n">ObservedCustomModule</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">convert_custom_config_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;observed_to_quantized_custom_module_class&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;static&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="n">ObservedCustomModule</span><span class="p">:</span> <span class="n">StaticQuantCustomModule</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">mp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">quantize_fx</span><span class="o">.</span><span class="n">prepare_fx</span><span class="p">(</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">qconfig_mapping</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">prepare_custom_config</span><span class="o">=</span><span class="n">prepare_custom_config_dict</span><span class="p">)</span>
<span class="c1"># calibration (not shown)</span>
<span class="n">mq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">quantize_fx</span><span class="o">.</span><span class="n">convert_fx</span><span class="p">(</span>
    <span class="n">mp</span><span class="p">,</span> <span class="n">convert_custom_config</span><span class="o">=</span><span class="n">convert_custom_config_dict</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="best-practices">
<h2>Best Practices<a class="headerlink" href="#best-practices" title="Link to this heading">#</a></h2>
<p>1. If you are using the <code class="docutils literal notranslate"><span class="pre">x86</span></code> backend, we need to use 7 bits instead of 8 bits. Make sure you reduce the range for the <code class="docutils literal notranslate"><span class="pre">quant\_min</span></code>, <code class="docutils literal notranslate"><span class="pre">quant\_max</span></code>, e.g.
if <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is <code class="docutils literal notranslate"><span class="pre">torch.quint8</span></code>, make sure to set a custom <code class="docutils literal notranslate"><span class="pre">quant_min</span></code> to be <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">quant_max</span></code> to be <code class="docutils literal notranslate"><span class="pre">127</span></code> (<code class="docutils literal notranslate"><span class="pre">255</span></code> / <code class="docutils literal notranslate"><span class="pre">2</span></code>)
if <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is <code class="docutils literal notranslate"><span class="pre">torch.qint8</span></code>, make sure to set a custom <code class="docutils literal notranslate"><span class="pre">quant_min</span></code> to be <code class="docutils literal notranslate"><span class="pre">-64</span></code> (<code class="docutils literal notranslate"><span class="pre">-128</span></code> / <code class="docutils literal notranslate"><span class="pre">2</span></code>) and <code class="docutils literal notranslate"><span class="pre">quant_max</span></code> to be <code class="docutils literal notranslate"><span class="pre">63</span></code> (<code class="docutils literal notranslate"><span class="pre">127</span></code> / <code class="docutils literal notranslate"><span class="pre">2</span></code>), we already set this correctly if
you call the <cite>torch.ao.quantization.get_default_qconfig(backend)</cite> or <cite>torch.ao.quantization.get_default_qat_qconfig(backend)</cite> function to get the default <code class="docutils literal notranslate"><span class="pre">qconfig</span></code> for
<code class="docutils literal notranslate"><span class="pre">x86</span></code> or <code class="docutils literal notranslate"><span class="pre">qnnpack</span></code> backend</p>
<p>2. If <code class="docutils literal notranslate"><span class="pre">onednn</span></code> backend is selected, 8 bits for activation will be used in the default qconfig mapping <code class="docutils literal notranslate"><span class="pre">torch.ao.quantization.get_default_qconfig_mapping('onednn')</span></code>
and default qconfig <code class="docutils literal notranslate"><span class="pre">torch.ao.quantization.get_default_qconfig('onednn')</span></code>. It is recommended to be used on CPUs with Vector Neural Network Instruction (VNNI)
support. Otherwise, setting <code class="docutils literal notranslate"><span class="pre">reduce_range</span></code> to True of the activation’s observer to get better accuracy on CPUs without VNNI support.</p>
</section>
<section id="frequently-asked-questions">
<h2>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Link to this heading">#</a></h2>
<ol class="arabic">
<li><p>How can I do quantized inference on GPU?:</p>
<p>We don’t have official GPU support yet, but this is an area of active development, you can find more information
<a class="reference external" href="https://github.com/pytorch/pytorch/issues/87395">here</a></p>
</li>
<li><p>Where can I get ONNX support for my quantized model?</p>
<p>If you get errors exporting the model (using APIs under <code class="docutils literal notranslate"><span class="pre">torch.onnx</span></code>), you may open an issue in the PyTorch repository. Prefix the issue title with <code class="docutils literal notranslate"><span class="pre">[ONNX]</span></code> and tag the issue as <code class="docutils literal notranslate"><span class="pre">module:</span> <span class="pre">onnx</span></code>.</p>
<p>If you encounter issues with ONNX Runtime, open an issue at <a class="reference external" href="https://github.com/microsoft/onnxruntime/issues/">GitHub - microsoft/onnxruntime</a>.</p>
</li>
<li><p>How can I use quantization with LSTM’s?:</p>
<p>LSTM is supported through our custom module api in both eager mode and fx graph mode quantization. Examples can be found at
Eager Mode: <a class="reference external" href="https://github.com/pytorch/pytorch/blob/9b88dcf248e717ca6c3f8c5e11f600825547a561/test/quantization/core/test_quantized_op.py#L2782">pytorch/test_quantized_op.py TestQuantizedOps.test_custom_module_lstm</a>
FX Graph Mode: <a class="reference external" href="https://github.com/pytorch/pytorch/blob/9b88dcf248e717ca6c3f8c5e11f600825547a561/test/quantization/fx/test_quantize_fx.py#L4116">pytorch/test_quantize_fx.py TestQuantizeFx.test_static_lstm</a></p>
</li>
</ol>
</section>
<section id="common-errors">
<h2>Common Errors<a class="headerlink" href="#common-errors" title="Link to this heading">#</a></h2>
<section id="passing-a-non-quantized-tensor-into-a-quantized-kernel">
<h3>Passing a non-quantized Tensor into a quantized kernel<a class="headerlink" href="#passing-a-non-quantized-tensor-into-a-quantized-kernel" title="Link to this heading">#</a></h3>
<p>If you see an error similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Could</span> <span class="ow">not</span> <span class="n">run</span> <span class="s1">&#39;quantized::some_operator&#39;</span> <span class="k">with</span> <span class="n">arguments</span> <span class="kn">from</span><span class="w"> </span><span class="nn">the</span> <span class="s1">&#39;CPU&#39;</span> <span class="n">backend</span><span class="o">...</span>
</pre></div>
</div>
<p>This means that you are trying to pass a non-quantized Tensor to a quantized
kernel. A common workaround is to use <code class="docutils literal notranslate"><span class="pre">torch.ao.quantization.QuantStub</span></code> to
quantize the tensor.  This needs to be done manually in Eager mode quantization.
An e2e example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># during the convert step, this will be replaced with a</span>
        <span class="c1"># `quantize_per_tensor` call</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
</section>
<section id="passing-a-quantized-tensor-into-a-non-quantized-kernel">
<h3>Passing a quantized Tensor into a non-quantized kernel<a class="headerlink" href="#passing-a-quantized-tensor-into-a-non-quantized-kernel" title="Link to this heading">#</a></h3>
<p>If you see an error similar to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">RuntimeError</span><span class="p">:</span> <span class="n">Could</span> <span class="ow">not</span> <span class="n">run</span> <span class="s1">&#39;aten::thnn_conv2d_forward&#39;</span> <span class="k">with</span> <span class="n">arguments</span> <span class="kn">from</span><span class="w"> </span><span class="nn">the</span> <span class="s1">&#39;QuantizedCPU&#39;</span> <span class="n">backend</span><span class="o">.</span>
</pre></div>
</div>
<p>This means that you are trying to pass a quantized Tensor to a non-quantized
kernel. A common workaround is to use <code class="docutils literal notranslate"><span class="pre">torch.ao.quantization.DeQuantStub</span></code> to
dequantize the tensor.  This needs to be done manually in Eager mode quantization.
An e2e example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">QuantStub</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># this module will not be quantized (see `qconfig = None` logic below)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ao</span><span class="o">.</span><span class="n">quantization</span><span class="o">.</span><span class="n">DeQuantStub</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># during the convert step, this will be replaced with a</span>
        <span class="c1"># `quantize_per_tensor` call</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># during the convert step, this will be replaced with a</span>
        <span class="c1"># `dequantize` call</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dequant</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span>
<span class="n">m</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="n">some_qconfig</span>
<span class="c1"># turn off quantization for conv2</span>
<span class="n">m</span><span class="o">.</span><span class="n">conv2</span><span class="o">.</span><span class="n">qconfig</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>
</div>
</section>
<section id="saving-and-loading-quantized-models">
<h3>Saving and Loading Quantized models<a class="headerlink" href="#saving-and-loading-quantized-models" title="Link to this heading">#</a></h3>
<p>When calling <code class="docutils literal notranslate"><span class="pre">torch.load</span></code> on a quantized model, if you see an error like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ne">AttributeError</span><span class="p">:</span> <span class="s1">&#39;LinearPackedParams&#39;</span> <span class="nb">object</span> <span class="n">has</span> <span class="n">no</span> <span class="n">attribute</span> <span class="s1">&#39;_modules&#39;</span>
</pre></div>
</div>
<p>This is because directly saving and loading a quantized model using <code class="docutils literal notranslate"><span class="pre">torch.save</span></code> and <code class="docutils literal notranslate"><span class="pre">torch.load</span></code>
is not supported. To save/load quantized models, the following ways can be used:</p>
<ol class="arabic simple">
<li><p>Saving/Loading the quantized model state_dict</p></li>
</ol>
<p>An example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">M</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linear</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepare_orig</span> <span class="o">=</span> <span class="n">prepare_fx</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">})</span>
<span class="n">prepare_orig</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">quantized_orig</span> <span class="o">=</span> <span class="n">convert_fx</span><span class="p">(</span><span class="n">prepare_orig</span><span class="p">)</span>

<span class="c1"># Save/load using state_dict</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">quantized_orig</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>

<span class="n">m2</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepared</span> <span class="o">=</span> <span class="n">prepare_fx</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">})</span>
<span class="n">quantized</span> <span class="o">=</span> <span class="n">convert_fx</span><span class="p">(</span><span class="n">prepared</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">quantized</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Saving/Loading scripted quantized models using <code class="docutils literal notranslate"><span class="pre">torch.jit.save</span></code> and <code class="docutils literal notranslate"><span class="pre">torch.jit.load</span></code></p></li>
</ol>
<p>An example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Note: using the same model M from previous example</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">M</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">prepare_orig</span> <span class="o">=</span> <span class="n">prepare_fx</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;&#39;</span> <span class="p">:</span> <span class="n">default_qconfig</span><span class="p">})</span>
<span class="n">prepare_orig</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">quantized_orig</span> <span class="o">=</span> <span class="n">convert_fx</span><span class="p">(</span><span class="n">prepare_orig</span><span class="p">)</span>

<span class="c1"># save/load using scripted model</span>
<span class="n">scripted</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">script</span><span class="p">(</span><span class="n">quantized_orig</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">scripted</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">scripted_quantized</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="symbolic-trace-error-when-using-fx-graph-mode-quantization">
<h3>Symbolic Trace Error when using FX Graph Mode Quantization<a class="headerlink" href="#symbolic-trace-error-when-using-fx-graph-mode-quantization" title="Link to this heading">#</a></h3>
<p>Symbolic traceability is a requirement for <a class="reference internal" href="#prototype-maintenance-mode-fx-graph-mode-quantization">(Prototype - maintenance mode) FX Graph Mode Quantization</a>, so if you pass a PyTorch Model that is not symbolically traceable to <cite>torch.ao.quantization.prepare_fx</cite> or <cite>torch.ao.quantization.prepare_qat_fx</cite>, we might see an error like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">fx</span><span class="o">.</span><span class="n">proxy</span><span class="o">.</span><span class="n">TraceError</span><span class="p">:</span> <span class="n">symbolically</span> <span class="n">traced</span> <span class="n">variables</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="n">inputs</span> <span class="n">to</span> <span class="n">control</span> <span class="n">flow</span>
</pre></div>
</div>
<p>Please take a look at <a class="reference external" href="https://pytorch.org/docs/2.0/fx.html#limitations-of-symbolic-tracing">Limitations of Symbolic Tracing</a> and use - <a class="reference external" href="https://pytorch.org/tutorials/prototype/fx_graph_mode_quant_guide.html">User Guide on Using FX Graph Mode Quantization</a> to workaround the problem.</p>
<span class="target" id="module-torch.quantization.utils"><span id="module-torch.quantization.stubs"></span><span id="module-torch.quantization.quantize_jit"></span><span id="module-torch.quantization.quantize_fx"></span><span id="module-torch.quantization.quantize"></span><span id="module-torch.quantization.quantization_mappings"></span><span id="module-torch.quantization.quant_type"></span><span id="module-torch.quantization.qconfig"></span><span id="module-torch.quantization.observer"></span><span id="module-torch.quantization.fx.utils"></span><span id="module-torch.quantization.fx.quantization_types"></span><span id="module-torch.quantization.fx.quantization_patterns"></span><span id="module-torch.quantization.fx.prepare"></span><span id="module-torch.quantization.fx.pattern_utils"></span><span id="module-torch.quantization.fx.match_utils"></span><span id="module-torch.quantization.fx.graph_module"></span><span id="module-torch.quantization.fx.fusion_patterns"></span><span id="module-torch.quantization.fx.fuse"></span><span id="module-torch.quantization.fx.convert"></span><span id="module-torch.quantization.fuser_method_mappings"></span><span id="module-torch.quantization.fuse_modules"></span><span id="module-torch.quantization.fake_quantize"></span><span id="module-torch.nn.quantized.modules.utils"></span><span id="module-torch.nn.quantized.modules.rnn"></span><span id="module-torch.nn.quantized.modules.normalization"></span><span id="module-torch.nn.quantized.modules.linear"></span><span id="module-torch.nn.quantized.modules.functional_modules"></span><span id="module-torch.nn.quantized.modules.embedding_ops"></span><span id="module-torch.nn.quantized.modules.dropout"></span><span id="module-torch.nn.quantized.modules.conv"></span><span id="module-torch.nn.quantized.modules.batchnorm"></span><span id="module-torch.nn.quantized.modules.activation"></span><span id="module-torch.nn.quantized.functional"></span><span id="module-torch.nn.quantized.dynamic.modules.rnn"></span><span id="module-torch.nn.quantized.dynamic.modules.linear"></span><span id="module-torch.nn.quantized.dynamic.modules.conv"></span><span id="module-torch.nn.quantizable.modules.rnn"></span><span id="module-torch.nn.quantizable.modules.activation"></span><span id="module-torch.nn.qat.modules.linear"></span><span id="module-torch.nn.qat.modules.embedding_ops"></span><span id="module-torch.nn.qat.modules.conv"></span><span id="module-torch.nn.qat.dynamic.modules.linear"></span><span id="module-torch.nn.intrinsic.quantized.modules.linear_relu"></span><span id="module-torch.nn.intrinsic.quantized.modules.conv_relu"></span><span id="module-torch.nn.intrinsic.quantized.modules.bn_relu"></span><span id="module-torch.nn.intrinsic.quantized.dynamic.modules.linear_relu"></span><span id="module-torch.nn.intrinsic.qat.modules.linear_relu"></span><span id="module-torch.nn.intrinsic.qat.modules.linear_fused"></span><span id="module-torch.nn.intrinsic.qat.modules.conv_fused"></span><span id="module-torch.nn.intrinsic.modules.fused"></span><span id="module-torch.ao.quantization.utils"></span><span id="module-torch.ao.quantization.stubs"></span><span id="module-torch.ao.quantization.quantizer.xnnpack_quantizer_utils"></span><span id="module-torch.ao.quantization.quantizer.xnnpack_quantizer"></span><span id="module-torch.ao.quantization.quantizer.xpu_inductor_quantizer"></span><span id="module-torch.ao.quantization.quantizer.x86_inductor_quantizer"></span><span id="module-torch.ao.quantization.quantizer.utils"></span><span id="module-torch.ao.quantization.quantizer.quantizer"></span><span id="module-torch.ao.quantization.quantizer.embedding_quantizer"></span><span id="module-torch.ao.quantization.quantizer.composable_quantizer"></span><span id="module-torch.ao.quantization.quantize_pt2e"></span><span id="module-torch.ao.quantization.quantize_jit"></span><span id="module-torch.ao.quantization.quantize_fx"></span><span id="module-torch.ao.quantization.quantization_mappings"></span><span id="module-torch.ao.quantization.quant_type"></span><span id="module-torch.ao.quantization.qconfig_mapping"></span><span id="module-torch.ao.quantization.qconfig"></span><span id="module-torch.ao.quantization.pt2e.utils"></span><span id="module-torch.ao.quantization.pt2e.representation.rewrite"></span><span id="module-torch.ao.quantization.pt2e.qat_utils"></span><span id="module-torch.ao.quantization.pt2e.prepare"></span><span id="module-torch.ao.quantization.pt2e.port_metadata_pass"></span><span id="module-torch.ao.quantization.pt2e.graph_utils"></span><span id="module-torch.ao.quantization.pt2e.export_utils"></span><span id="module-torch.ao.quantization.pt2e.duplicate_dq_pass"></span><span id="module-torch.ao.quantization.observer"></span><span id="module-torch.ao.quantization.fx.utils"></span><span id="module-torch.ao.quantization.fx.tracer"></span><span id="module-torch.ao.quantization.fx.quantize_handler"></span><span id="module-torch.ao.quantization.fx.qconfig_mapping_utils"></span><span id="module-torch.ao.quantization.fx.prepare"></span><span id="module-torch.ao.quantization.fx.pattern_utils"></span><span id="module-torch.ao.quantization.fx.match_utils"></span><span id="module-torch.ao.quantization.fx.lstm_utils"></span><span id="module-torch.ao.quantization.fx.lower_to_qnnpack"></span><span id="module-torch.ao.quantization.fx.lower_to_fbgemm"></span><span id="module-torch.ao.quantization.fx.graph_module"></span><span id="module-torch.ao.quantization.fx.fuse_handler"></span><span id="module-torch.ao.quantization.fx.fuse"></span><span id="module-torch.ao.quantization.fx.custom_config"></span><span id="module-torch.ao.quantization.fx.convert"></span><span id="module-torch.ao.quantization.fuse_modules"></span><span id="module-torch.ao.quantization.fuser_method_mappings"></span><span id="module-torch.ao.quantization.fake_quantize"></span><span id="module-torch.ao.quantization.backend_config.x86"></span><span id="module-torch.ao.quantization.backend_config.utils"></span><span id="module-torch.ao.quantization.backend_config.tensorrt"></span><span id="module-torch.ao.quantization.backend_config.qnnpack"></span><span id="module-torch.ao.quantization.backend_config.onednn"></span><span id="module-torch.ao.quantization.backend_config.observation_type"></span><span id="module-torch.ao.quantization.backend_config.native"></span><span id="module-torch.ao.quantization.backend_config.fbgemm"></span><span id="module-torch.ao.quantization.backend_config.executorch"></span><span id="module-torch.ao.quantization.backend_config.backend_config"></span><span id="module-torch.ao.pruning.sparsifier.weight_norm_sparsifier"></span><span id="module-torch.ao.pruning.sparsifier.utils"></span><span id="module-torch.ao.pruning.sparsifier.nearly_diagonal_sparsifier"></span><span id="module-torch.ao.pruning.sparsifier.base_sparsifier"></span><span id="module-torch.ao.pruning.scheduler.lambda_scheduler"></span><span id="module-torch.ao.pruning.scheduler.cubic_scheduler"></span><span id="module-torch.ao.pruning.scheduler.base_scheduler"></span><span id="module-torch.ao.ns.fx.weight_utils"></span><span id="module-torch.ao.ns.fx.utils"></span><span id="module-torch.ao.ns.fx.qconfig_multi_mapping"></span><span id="module-torch.ao.ns.fx.pattern_utils"></span><span id="module-torch.ao.ns.fx.ns_types"></span><span id="module-torch.ao.ns.fx.n_shadows_utils"></span><span id="module-torch.ao.ns.fx.mappings"></span><span id="module-torch.ao.ns.fx.graph_passes"></span><span id="module-torch.ao.ns.fx.graph_matcher"></span><span id="module-torch.ao.nn.sparse.quantized.utils"></span><span id="module-torch.ao.nn.sparse.quantized.linear"></span><span id="module-torch.ao.nn.sparse.quantized.dynamic.linear"></span><span id="module-torch.ao.nn.quantized.reference.modules.utils"></span><span id="module-torch.ao.nn.quantized.reference.modules.sparse"></span><span id="module-torch.ao.nn.quantized.reference.modules.rnn"></span><span id="module-torch.ao.nn.quantized.reference.modules.linear"></span><span id="module-torch.ao.nn.quantized.reference.modules.conv"></span><span id="module-torch.ao.nn.quantized.modules.utils"></span><span id="module-torch.ao.nn.quantized.modules.rnn"></span><span id="module-torch.ao.nn.quantized.modules.normalization"></span><span id="module-torch.ao.nn.quantized.modules.linear"></span><span id="module-torch.ao.nn.quantized.modules.functional_modules"></span><span id="module-torch.ao.nn.quantized.modules.embedding_ops"></span><span id="module-torch.ao.nn.quantized.modules.dropout"></span><span id="module-torch.ao.nn.quantized.modules.conv"></span><span id="module-torch.ao.nn.quantized.modules.batchnorm"></span><span id="module-torch.ao.nn.quantized.modules.activation"></span><span id="module-torch.ao.nn.quantized.dynamic.modules.rnn"></span><span id="module-torch.ao.nn.quantized.dynamic.modules.linear"></span><span id="module-torch.ao.nn.quantized.dynamic.modules.conv"></span><span id="module-torch.ao.nn.quantizable.modules.rnn"></span><span id="module-torch.ao.nn.quantizable.modules.activation"></span><span id="module-torch.ao.nn.qat.modules.linear"></span><span id="module-torch.ao.nn.qat.modules.embedding_ops"></span><span id="module-torch.ao.nn.qat.modules.conv"></span><span id="module-torch.ao.nn.qat.dynamic.modules.linear"></span><span id="module-torch.ao.nn.intrinsic.quantized.modules.linear_relu"></span><span id="module-torch.ao.nn.intrinsic.quantized.modules.conv_relu"></span><span id="module-torch.ao.nn.intrinsic.quantized.modules.conv_add"></span><span id="module-torch.ao.nn.intrinsic.quantized.modules.bn_relu"></span><span id="module-torch.ao.nn.intrinsic.quantized.dynamic.modules.linear_relu"></span><span id="module-torch.ao.nn.intrinsic.qat.modules.linear_relu"></span><span id="module-torch.ao.nn.intrinsic.qat.modules.linear_fused"></span><span id="module-torch.ao.nn.intrinsic.qat.modules.conv_fused"></span><span id="module-torch.ao.nn.intrinsic.modules.fused"></span><span id="module-torch.ao.pruning.sparsifier"></span><span id="module-torch.ao.pruning.scheduler"></span><span id="module-torch.ao.pruning"></span><span id="module-torch.ao.quantization.backend_config"></span><span id="module-torch.ao.ns.fx"></span><span id="module-torch.ao.ns"></span><span id="module-torch.ao.nn.sparse.quantized.dynamic"></span><span id="module-torch.ao.nn.sparse.quantized"></span><span id="module-torch.ao.nn.sparse"></span><span id="module-torch.ao.nn.quantized.reference.modules"></span><span id="module-torch.ao.nn.quantized.reference"></span><span id="module-torch.ao.nn.quantized"></span><span id="module-torch.ao.nn.quantizable.modules"></span><span id="module-torch.ao.nn.quantizable"></span><span id="module-torch.ao.nn"></span><span id="module-torch.ao"></span></span></section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#introduction-to-quantization">Introduction to Quantization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-api-summary">Quantization API Summary</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#eager-mode-quantization">Eager Mode Quantization</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#post-training-dynamic-quantization">Post Training Dynamic Quantization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#post-training-static-quantization">Post Training Static Quantization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-aware-training-for-static-quantization">Quantization Aware Training for Static Quantization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#model-preparation-for-eager-mode-static-quantization">Model Preparation for Eager Mode Static Quantization</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#prototype-maintenance-mode-fx-graph-mode-quantization">(Prototype - maintenance mode) FX Graph Mode Quantization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#prototype-pytorch-2-export-quantization">(Prototype) PyTorch 2 Export Quantization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-stack">Quantization Stack</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantized-model">Quantized Model</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#quantized-tensor">Quantized Tensor</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#quantize-and-dequantize">Quantize and Dequantize</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#quantized-operators-modules">Quantized Operators/Modules</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#quantized-engine">Quantized Engine</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-flow">Quantization Flow</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#observer-and-fakequantize">Observer and FakeQuantize</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#qconfig">QConfig</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#general-quantization-flow">General Quantization Flow</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-support-matrix">Quantization Support Matrix</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-mode-support">Quantization Mode Support</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-flow-support">Quantization Flow Support</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#backend-hardware-support">Backend/Hardware Support</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#note-for-native-cpu-backends">Note for native CPU backends</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#operator-support">Operator Support</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-api-reference">Quantization API Reference</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-backend-configuration">Quantization Backend Configuration</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-accuracy-debugging">Quantization Accuracy Debugging</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-customizations">Quantization Customizations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#quantization-custom-module-api">Quantization Custom Module API</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#best-practices">Best Practices</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#frequently-asked-questions">Frequently Asked Questions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#common-errors">Common Errors</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#passing-a-non-quantized-tensor-into-a-quantized-kernel">Passing a non-quantized Tensor into a quantized kernel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#passing-a-quantized-tensor-into-a-non-quantized-kernel">Passing a quantized Tensor into a non-quantized kernel</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#saving-and-loading-quantized-models">Saving and Loading Quantized models</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#symbolic-trace-error-when-using-fx-graph-mode-quantization">Symbolic Trace Error when using FX Graph Mode Quantization</a></li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/pytorch/pytorch/edit/main/docs/source/python-api/quantization.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

  <div class="sidebar-secondary-item">
    <div class="tocsection sourcelink">
      <a href="../_sources/python-api/quantization.rst.txt">
        <i class="fa-solid fa-file-lines"></i> Show Source
      </a>
    </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>


  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright PyTorch Contributors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>