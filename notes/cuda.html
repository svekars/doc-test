
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
<meta content="A guide to torch.cuda, a PyTorch module to run CUDA operations" name="description" />
<meta content="memory management, PYTORCH_CUDA_ALLOC_CONF, optimize PyTorch, CUDA" name="keywords" />

    <title>CUDA semantics &#8212; PyTorch main documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=949a1ff5" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css?v=91adb8b6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/css/jit.css?v=8de1ea5d" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=3ccf5357" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom2.css?v=a9f46c5e" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=a8da1a53"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=940804e7"></script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notes/cuda';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="HIP (ROCm) semantics" href="hip.html" />
    <link rel="prev" title="Modules" href="modules.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="main (2.6.0 )" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>

          <li class="main-menu-item">
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Learn
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Get Started</span>
                  <p>Run PyTorch locally or get started quickly with one of the supported cloud platforms</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tutorials</span>
                  <p>Whats new in PyTorch tutorials</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Learn the Basics</span>
                  <p>Familiarize yourself with PyTorch concepts and modules</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Recipes</span>
                  <p>Bite-size, ready-to-deploy PyTorch code examples</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Intro to PyTorch - YouTube Series</span>
                  <p>Master PyTorch basics with our engaging YouTube tutorial series</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Ecosystem
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Tools</span>
                  <p>Learn about the tools and frameworks in the PyTorch Ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Community</span>
                  <p>Join the PyTorch developer community to contribute, learn, and get your questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="" target="_blank">
                  <span class=dropdown-title>Forums</span>
                  <p>A place to discuss PyTorch code, issues, install, research</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class=dropdown-title>Developer Resources</span>
                  <p>Find resources and get questions answered</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contributor Awards - 2024</span>
                  <p>Award winners announced at this year's PyTorch Conference</p>
                </a>
              </div>
            </div>
          </li>

          <li>
          <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Edge
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">About PyTorch Edge</span>
                  <p>Build innovative and privacy-aware AI experiences for edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch</span>
                  <p>End-to-end solution for enabling on-device inference capabilities across mobile and edge devices</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">ExecuTorch Docs</span>
                </a>
              </div>
            </div>  
          </li>

          <li class="main-menu-item">
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Docs
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch</span>
                  <p>Explore the documentation for comprehensive guidance on how to use PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Domains</span>
                  <p>Read the PyTorch Domains documentation to learn more about domain-specific libraries</p>
                </a>
              </div>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                Blogs & News 
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Blog</span>
                  <p>Catch up on the latest technical news and happenings</p>
                </a>
                 <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Blog</span>
                  <p>Stories from the PyTorch ecosystem</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Videos</span>
                  <p>Learn about the latest PyTorch tutorials, new, and more </p>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Community Stories</span>
                  <p>Learn how our community solves real, everyday machine learning problems with PyTorch</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Events</span>
                  <p>Find events, webinars, and podcasts</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Newsletter</span>
                  <p>Stay up-to-date with the latest updates</p>
                </a>
            </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="with-down-arrow">
                About
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">PyTorch Foundation</span>
                  <p>Learn more about the PyTorch Foundation</p>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Governing Board</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Cloud Credit Program</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Technical Advisory Council</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Staff</span>
                </a>
                <a class="nav-dropdown-item" href="">
                  <span class="dropdown-title">Contact Us</span>
                </a>
              </div>
            </div>
          </li>

          <li class="main-menu-item">
            <div class="no-dropdown">
              <a href="" data-cta="join">
                Become a Member
              </a>
            </div>
          </li>
          <li>
           <div class="main-menu-item">
             <a href="" class="github-icon">
             </a>
           </div>
          </li>
          <!--- TODO: This block adds the search icon to the nav bar. We will enable it later. 
          <li>
            <div class="main-menu-item">
             <a href="" class="search-icon">
             </a>
            </div>
          </li>
          --->
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>
  </div>
</div>

  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">
<div class="version-switcher__container dropdown pst-js-only">
  <button id="pst-version-switcher-button-2"
    type="button"
    class="version-switcher__button btn btn-sm dropdown-toggle"
    data-bs-toggle="dropdown"
    aria-haspopup="listbox"
    aria-controls="pst-version-switcher-list-2"
    aria-label="Version switcher list"
  >
    Choose version  <!-- this text may get changed later by javascript -->
    <span class="caret"></span>
  </button>
  <div id="pst-version-switcher-list-2"
    class="version-switcher__menu dropdown-menu list-group-flush py-0"
    role="listbox" aria-labelledby="pst-version-switcher-button-2">
    <!-- dropdown will be populated by javascript on page load -->
  </div>
</div></div>
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../index.html">
  
  
  
  
  
  
    <p class="title logo__title">Home</p>
  
</a></div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../python-api/index.html">
    Python API
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../lang-bindings/index.html">
    Language Bindings
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../python-api/index.html">
    Python API
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="index.html">
    Developer Notes
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../community/index.html">
    Community
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../lang-bindings/index.html">
    Language Bindings
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://x.com/PyTorch" title="X" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-x-twitter fa-lg" aria-hidden="true"></i>
            <span class="sr-only">X</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pytorch/pytorch" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pypi.org/project/torch" title="PyPI" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-custom fa-pypi fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PyPI</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><p aria-level="2" class="caption" role="heading"><span class="caption-text">Core Concepts</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="autograd.html">Autograd mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="gradcheck.html">Gradcheck mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Device and Hardware Support</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">CUDA semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="hip.html">HIP (ROCm) semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="mps.html">MPS backend</a></li>
<li class="toctree-l1"><a class="reference internal" href="get_start_xpu.html">Getting Started on Intel GPU</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Distributed Training and Deployment</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ddp.html">Distributed Data Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="fsdp.html">FSDP Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="large_scale_deployments.html">Features for large-scale deployments</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Optimization and Performance</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="amp_examples.html">Automatic Mixed Precision examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpu_threading_torchscript_inference.html">CPU threading and TorchScript inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="multiprocessing.html">Multiprocessing best practices</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Extending PyTorch</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="extending.html">Extending PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="extending.func.html">Extending torch.func with autograd.Function</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom_operators.html">PyTorch Custom Operators Landing Page</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Numerical Considerations</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="broadcasting.html">Broadcasting semantics</a></li>
<li class="toctree-l1"><a class="reference internal" href="numerical_accuracy.html">Numerical accuracy</a></li>
<li class="toctree-l1"><a class="reference internal" href="randomness.html">Reproducibility</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Serialization and Storage</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="serialization.html">Serialization semantics</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">FAQs</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="windows.html">Windows FAQ</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="index.html" class="nav-link">Developer Notes</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">CUDA semantics</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="cuda-semantics">
<span id="id1"></span><h1>CUDA semantics<a class="headerlink" href="#cuda-semantics" title="Link to this heading">#</a></h1>
<p><a class="reference internal" href="../python-api/cuda.html#module-torch.cuda" title="torch.cuda"><code class="xref py py-mod docutils literal notranslate"><span class="pre">torch.cuda</span></code></a> is used to set up and run CUDA operations. It keeps track of
the currently selected GPU, and all CUDA tensors you allocate will by default be
created on that device. The selected device can be changed with a
<a class="reference internal" href="../python-api/generated/torch.cuda.device.html#torch.cuda.device" title="torch.cuda.device"><code class="xref any py py-class docutils literal notranslate"><span class="pre">torch.cuda.device</span></code></a> context manager.</p>
<p>However, once a tensor is allocated, you can do operations on it irrespective
of the selected device, and the results will be always placed on the same
device as the tensor.</p>
<p>Cross-GPU operations are not allowed by default, with the exception of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">copy_()</span></code> and other methods with copy-like functionality
such as <a class="reference internal" href="../python-api/generated/torch.Tensor.to.html#torch.Tensor.to" title="torch.Tensor.to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to()</span></code></a> and <a class="reference internal" href="../python-api/generated/torch.Tensor.cuda.html#torch.Tensor.cuda" title="torch.Tensor.cuda"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuda()</span></code></a>.
Unless you enable peer-to-peer memory access, any attempts to launch ops on
tensors spread across different devices will raise an error.</p>
<p>Below you can find a small example showcasing this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>     <span class="c1"># Default CUDA device</span>
<span class="n">cuda0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda:0&#39;</span><span class="p">)</span>
<span class="n">cuda2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda:2&#39;</span><span class="p">)</span>  <span class="c1"># GPU 2 (these are 0-indexed)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda0</span><span class="p">)</span>
<span class="c1"># x.device is device(type=&#39;cuda&#39;, index=0)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="c1"># y.device is device(type=&#39;cuda&#39;, index=0)</span>

<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># allocates a tensor on GPU 1</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>

    <span class="c1"># transfers a tensor from CPU to GPU 1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
    <span class="c1"># a.device and b.device are device(type=&#39;cuda&#39;, index=1)</span>

    <span class="c1"># You can also use ``Tensor.to`` to transfer a tensor:</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
    <span class="c1"># b.device and b2.device are device(type=&#39;cuda&#39;, index=1)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="c1"># c.device is device(type=&#39;cuda&#39;, index=1)</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="c1"># z.device is device(type=&#39;cuda&#39;, index=0)</span>

    <span class="c1"># even within a context, you can specify the device</span>
    <span class="c1"># (or give a GPU index to the .cuda call)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda2</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cuda2</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">(</span><span class="n">cuda2</span><span class="p">)</span>
    <span class="c1"># d.device, e.device, and f.device are all device(type=&#39;cuda&#39;, index=2)</span>
</pre></div>
</div>
<section id="tensorfloat-32-tf32-on-ampere-and-later-devices">
<span id="tf32-on-ampere"></span><h2>TensorFloat-32 (TF32) on Ampere (and later) devices<a class="headerlink" href="#tensorfloat-32-tf32-on-ampere-and-later-devices" title="Link to this heading">#</a></h2>
<p>Starting in PyTorch 1.7, there is a new flag called <cite>allow_tf32</cite>. This flag
defaults to True in PyTorch 1.7 to PyTorch 1.11, and False in PyTorch 1.12 and later.
This flag controls whether PyTorch is allowed to use the TensorFloat32 (TF32) tensor cores,
available on NVIDIA GPUs since Ampere, internally to compute matmul (matrix multiplies
and batched matrix multiplies) and convolutions.</p>
<p>TF32 tensor cores are designed to achieve better performance on matmul and convolutions on
<cite>torch.float32</cite> tensors by rounding input data to have 10 bits of mantissa, and accumulating
results with FP32 precision, maintaining FP32 dynamic range.</p>
<p>matmuls and convolutions are controlled separately, and their corresponding flags can be accessed at:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># The flag below controls whether to allow TF32 on matmul. This flag defaults to False</span>
<span class="c1"># in PyTorch 1.12 and later.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># The flag below controls whether to allow TF32 on cuDNN. This flag defaults to True.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
<p>The precision of matmuls can also be set more broadly (limited not just to CUDA) via <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_float_32_matmul_precision()</span></code>.
Note that besides matmuls and convolutions themselves, functions and nn modules that internally uses
matmuls or convolutions are also affected. These include <cite>nn.Linear</cite>, <cite>nn.Conv*</cite>, cdist, tensordot,
affine grid and grid sample, adaptive log softmax, GRU and LSTM.</p>
<p>To get an idea of the precision and speed, see the example code and benchmark data (on A100) below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a_full</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10240</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">b_full</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">10240</span><span class="p">,</span> <span class="mi">10240</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">ab_full</span> <span class="o">=</span> <span class="n">a_full</span> <span class="o">@</span> <span class="n">b_full</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">ab_full</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>  <span class="c1"># 80.7277</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">a_full</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">b_full</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>

<span class="c1"># Do matmul at TF32 mode.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">ab_tf32</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span>  <span class="c1"># takes 0.016s on GA100</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">ab_tf32</span> <span class="o">-</span> <span class="n">ab_full</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c1"># 0.1747</span>
<span class="n">relative_error</span> <span class="o">=</span> <span class="n">error</span> <span class="o">/</span> <span class="n">mean</span>  <span class="c1"># 0.0022</span>

<span class="c1"># Do matmul with TF32 disabled.</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">ab_fp32</span> <span class="o">=</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span>  <span class="c1"># takes 0.11s on GA100</span>
<span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">ab_fp32</span> <span class="o">-</span> <span class="n">ab_full</span><span class="p">)</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>  <span class="c1"># 0.0031</span>
<span class="n">relative_error</span> <span class="o">=</span> <span class="n">error</span> <span class="o">/</span> <span class="n">mean</span>  <span class="c1"># 0.000039</span>
</pre></div>
</div>
<p>From the above example, we can see that with TF32 enabled, the speed is ~7x faster on A100, and that
relative error compared to double precision is approximately 2 orders of magnitude larger. Note that
the exact ratio of TF32 to single precision speed depends on the hardware generation, as properties
such as the ratio of memory bandwidth to compute as well as the ratio of TF32 to FP32 matmul throughput
may vary from generation to generation or model to model.
If full FP32 precision is needed, users can disable TF32 by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cudnn</span><span class="o">.</span><span class="n">allow_tf32</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To toggle the TF32 flags off in C++, you can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowTF32CuBLAS</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowTF32CuDNN</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>For more information about TF32, see:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://blogs.nvidia.com/blog/2020/05/14/tensorfloat-32-precision-format/">TensorFloat-32</a></p></li>
<li><p><a class="reference external" href="https://devblogs.nvidia.com/cuda-11-features-revealed/">CUDA 11</a></p></li>
<li><p><a class="reference external" href="https://devblogs.nvidia.com/nvidia-ampere-architecture-in-depth/">Ampere architecture</a></p></li>
</ul>
</section>
<section id="reduced-precision-reduction-in-fp16-gemms">
<span id="fp16reducedprecision"></span><h2>Reduced Precision Reduction in FP16 GEMMs<a class="headerlink" href="#reduced-precision-reduction-in-fp16-gemms" title="Link to this heading">#</a></h2>
<p>fp16 GEMMs are potentially done with some intermediate reduced precision reductions (e.g., in fp16 rather than fp32). These selective reductions in precision can allow for higher performance on certain workloads (particularly those with a large <cite>k</cite> dimension) and GPU architectures at the cost of numerical precision and potential for overflow.</p>
<p>Some example benchmark data on V100:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="o">---------------------------</span> <span class="n">bench_gemm_transformer</span> <span class="o">--------------------------</span><span class="p">]</span>
      <span class="p">[</span>  <span class="n">m</span> <span class="p">,</span>  <span class="n">k</span>  <span class="p">,</span>  <span class="n">n</span>  <span class="p">]</span>    <span class="o">|</span>  <span class="n">allow_fp16_reduc</span><span class="o">=</span><span class="kc">True</span>  <span class="o">|</span>  <span class="n">allow_fp16_reduc</span><span class="o">=</span><span class="kc">False</span>
<span class="mi">1</span> <span class="n">threads</span><span class="p">:</span> <span class="o">--------------------------------------------------------------------</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4048</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1634.6</span>        <span class="o">|</span>           <span class="mf">1639.8</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4056</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1670.8</span>        <span class="o">|</span>           <span class="mf">1661.9</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4080</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1664.2</span>        <span class="o">|</span>           <span class="mf">1658.3</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1639.4</span>        <span class="o">|</span>           <span class="mf">1651.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4104</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1677.4</span>        <span class="o">|</span>           <span class="mf">1674.9</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4128</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1655.7</span>        <span class="o">|</span>           <span class="mf">1646.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">4144</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">1796.8</span>        <span class="o">|</span>           <span class="mf">2519.6</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5096</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2094.6</span>        <span class="o">|</span>           <span class="mf">3190.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5104</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2144.0</span>        <span class="o">|</span>           <span class="mf">2663.5</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5112</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2149.1</span>        <span class="o">|</span>           <span class="mf">2766.9</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">5120</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">2142.8</span>        <span class="o">|</span>           <span class="mf">2631.0</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">9728</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>    <span class="o">|</span>           <span class="mf">3875.1</span>        <span class="o">|</span>           <span class="mf">5779.8</span>
      <span class="p">[</span><span class="mi">4096</span><span class="p">,</span> <span class="mi">16384</span><span class="p">,</span> <span class="mi">4096</span><span class="p">]</span>   <span class="o">|</span>           <span class="mf">6182.9</span>        <span class="o">|</span>           <span class="mf">9656.5</span>
<span class="p">(</span><span class="n">times</span> <span class="ow">in</span> <span class="n">microseconds</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
<p>If full precision reductions are needed, users can disable reduced precision reductions in fp16 GEMMs with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_fp16_reduced_precision_reduction</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To toggle the reduced precision reduction flags in C++, one can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowFP16ReductionCuBLAS</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="reduced-precision-reduction-in-bf16-gemms">
<span id="bf16reducedprecision"></span><h2>Reduced Precision Reduction in BF16 GEMMs<a class="headerlink" href="#reduced-precision-reduction-in-bf16-gemms" title="Link to this heading">#</a></h2>
<p>A similar flag (as above) exists for BFloat16 GEMMs.
Note that this switch is set to <cite>True</cite> by default for BF16, if you observe
numerical instability in your workload, you may wish to set it to <cite>False</cite>.</p>
<p>If reduced precision reductions are not desired, users can disable reduced
precision reductions in bf16 GEMMs with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">backends</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">matmul</span><span class="o">.</span><span class="n">allow_bf16_reduced_precision_reduction</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>To toggle the reduced precision reduction flags in C++, one can do</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">at</span><span class="o">::</span><span class="n">globalContext</span><span class="p">().</span><span class="n">setAllowBF16ReductionCuBLAS</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="asynchronous-execution">
<h2>Asynchronous execution<a class="headerlink" href="#asynchronous-execution" title="Link to this heading">#</a></h2>
<p>By default, GPU operations are asynchronous.  When you call a function that
uses the GPU, the operations are <em>enqueued</em> to the particular device, but not
necessarily executed until later.  This allows us to execute more computations
in parallel, including operations on CPU or other GPUs.</p>
<p>In general, the effect of asynchronous computation is invisible to the caller,
because (1) each device executes operations in the order they are queued, and
(2) PyTorch automatically performs necessary synchronization when copying data
between CPU and GPU or between two GPUs.  Hence, computation will proceed as if
every operation was executed synchronously.</p>
<p>You can force synchronous computation by setting environment variable
<code class="docutils literal notranslate"><span class="pre">CUDA_LAUNCH_BLOCKING=1</span></code>.  This can be handy when an error occurs on the GPU.
(With asynchronous execution, such an error isnt reported until after the
operation is actually executed, so the stack trace does not show where it was
requested.)</p>
<p>A consequence of the asynchronous computation is that time measurements without
synchronizations are not accurate. To get precise measurements, one should either
call <a class="reference internal" href="../python-api/generated/torch.cuda.synchronize.html#torch.cuda.synchronize" title="torch.cuda.synchronize"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.synchronize()</span></code></a> before measuring, or use <a class="reference internal" href="../python-api/generated/torch.cuda.Event.html#torch.cuda.Event" title="torch.cuda.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.Event</span></code></a>
to record times as following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">start_event</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">enable_timing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">end_event</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Event</span><span class="p">(</span><span class="n">enable_timing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">start_event</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>

<span class="c1"># Run some things here</span>

<span class="n">end_event</span><span class="o">.</span><span class="n">record</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>  <span class="c1"># Wait for the events to be recorded!</span>
<span class="n">elapsed_time_ms</span> <span class="o">=</span> <span class="n">start_event</span><span class="o">.</span><span class="n">elapsed_time</span><span class="p">(</span><span class="n">end_event</span><span class="p">)</span>
</pre></div>
</div>
<p>As an exception, several functions such as <a class="reference internal" href="../python-api/generated/torch.Tensor.to.html#torch.Tensor.to" title="torch.Tensor.to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to()</span></code></a> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">copy_()</span></code> admit an explicit <code class="xref py py-attr docutils literal notranslate"><span class="pre">non_blocking</span></code> argument,
which lets the caller bypass synchronization when it is unnecessary.
Another exception is CUDA streams, explained below.</p>
<section id="cuda-streams">
<h3>CUDA streams<a class="headerlink" href="#cuda-streams" title="Link to this heading">#</a></h3>
<p>A <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#streams">CUDA stream</a> is a linear sequence of execution that belongs to a specific
device.  You normally do not need to create one explicitly: by default, each
device uses its own default stream.</p>
<p>Operations inside each stream are serialized in the order they are created,
but operations from different streams can execute concurrently in any
relative order, unless explicit synchronization functions (such as
<a class="reference internal" href="../python-api/generated/torch.cuda.synchronize.html#torch.cuda.synchronize" title="torch.cuda.synchronize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">synchronize()</span></code></a> or <code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_stream()</span></code>) are
used.  For example, the following code is incorrect:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>  <span class="c1"># Create a new stream.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># sum() may start execution before normal_() finishes!</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>When the current stream is the default stream, PyTorch automatically performs
necessary synchronization when data is moved around, as explained above.
However, when using non-default streams, it is the users responsibility to
ensure proper synchronization.  The fixed version of this example is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>  <span class="c1"># Create a new stream.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">default_stream</span><span class="p">(</span><span class="n">cuda</span><span class="p">))</span>  <span class="c1"># NEW!</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">record_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># NEW!</span>
</pre></div>
</div>
<p>There are two new additions.  The <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.cuda.Stream.wait_stream()</span></code> call
ensures that the <code class="docutils literal notranslate"><span class="pre">normal_()</span></code> execution has finished before we start running
<code class="docutils literal notranslate"><span class="pre">sum(A)</span></code> on a side stream.  The <a class="reference internal" href="../python-api/generated/torch.Tensor.record_stream.html#torch.Tensor.record_stream" title="torch.Tensor.record_stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.record_stream()</span></code></a> (see for
more details) ensures that we do not deallocate A before <code class="docutils literal notranslate"><span class="pre">sum(A)</span></code> has
completed.  You can also manually wait on the stream at some later point in
time with <code class="docutils literal notranslate"><span class="pre">torch.cuda.default_stream(cuda).wait_stream(s)</span></code> (note that it
is pointless to wait immediately, since that will prevent the stream execution
from running in parallel with other work on the default stream.)  See the
documentation for <a class="reference internal" href="../python-api/generated/torch.Tensor.record_stream.html#torch.Tensor.record_stream" title="torch.Tensor.record_stream"><code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.Tensor.record_stream()</span></code></a> on more details on when
to use one or another.</p>
<p>Note that this synchronization is necessary even when there is no
read dependency, e.g., as seen in this example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>  <span class="c1"># Create a new stream.</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">default_stream</span><span class="p">(</span><span class="n">cuda</span><span class="p">))</span>  <span class="c1"># STILL REQUIRED!</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">A</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">record_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>Despite the computation on <code class="docutils literal notranslate"><span class="pre">s</span></code> not reading the contents of <code class="docutils literal notranslate"><span class="pre">A</span></code> and no
other uses of <code class="docutils literal notranslate"><span class="pre">A</span></code>, it is still necessary to synchronize, because <code class="docutils literal notranslate"><span class="pre">A</span></code>
may correspond to memory reallocated by the CUDA caching allocator, with
pending operations from the old (deallocated) memory.</p>
</section>
<section id="stream-semantics-of-backward-passes">
<span id="bwd-cuda-stream-semantics"></span><h3>Stream semantics of backward passes<a class="headerlink" href="#stream-semantics-of-backward-passes" title="Link to this heading">#</a></h3>
<p>Each backward CUDA op runs on the same stream that was used for its corresponding forward op.
If your forward pass runs independent ops in parallel on different streams,
this helps the backward pass exploit that same parallelism.</p>
<p>The stream semantics of a backward call with respect to surrounding ops are the same
as for any other call. The backward pass inserts internal syncs to ensure this even when
backward ops run on multiple streams as described in the previous paragraph.
More concretely, when calling
<a class="reference internal" href="../python-api/generated/torch.autograd.backward.html#torch.autograd.backward" title="torch.autograd.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.backward</span></code></a>,
<a class="reference internal" href="../python-api/generated/torch.autograd.grad.html#torch.autograd.grad" title="torch.autograd.grad"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.grad</span></code></a>, or
<a class="reference internal" href="../python-api/generated/torch.Tensor.backward.html#torch.Tensor.backward" title="torch.Tensor.backward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor.backward</span></code></a>,
and optionally supplying CUDA tensor(s) as the  initial gradient(s) (e.g.,
<a class="reference internal" href="../python-api/generated/torch.autograd.backward.html#torch.autograd.backward" title="torch.autograd.backward"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.backward(...,</span> <span class="pre">grad_tensors=initial_grads)</span></code></a>,
<a class="reference internal" href="../python-api/generated/torch.autograd.grad.html#torch.autograd.grad" title="torch.autograd.grad"><code class="xref py py-func docutils literal notranslate"><span class="pre">autograd.grad(...,</span> <span class="pre">grad_outputs=initial_grads)</span></code></a>, or
<a class="reference internal" href="../python-api/generated/torch.Tensor.backward.html#torch.Tensor.backward" title="torch.Tensor.backward"><code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor.backward(...,</span> <span class="pre">gradient=initial_grad)</span></code></a>),
the acts of</p>
<ol class="arabic simple">
<li><p>optionally populating initial gradient(s),</p></li>
<li><p>invoking the backward pass, and</p></li>
<li><p>using the gradients</p></li>
</ol>
<p>have the same stream-semantics relationship as any group of ops:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>

<span class="c1"># Safe, grads are used in the same stream context as backward()</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">use</span> <span class="n">grads</span>

<span class="c1"># Unsafe</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">use</span> <span class="n">grads</span>

<span class="c1"># Safe, with synchronization</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">use</span> <span class="n">grads</span>

<span class="c1"># Safe, populating initial grad and invoking backward are in the same stream context</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">loss</span><span class="p">))</span>

<span class="c1"># Unsafe, populating initial_grad and invoking backward are in different stream contexts,</span>
<span class="c1"># without synchronization</span>
<span class="n">initial_grad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">initial_grad</span><span class="p">)</span>

<span class="c1"># Safe, with synchronization</span>
<span class="n">initial_grad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">initial_grad</span><span class="o">.</span><span class="n">record_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span><span class="n">gradient</span><span class="o">=</span><span class="n">initial_grad</span><span class="p">)</span>
</pre></div>
</div>
<section id="bc-note-using-grads-on-the-default-stream">
<h4>BC note: Using grads on the default stream<a class="headerlink" href="#bc-note-using-grads-on-the-default-stream" title="Link to this heading">#</a></h4>
<p>In prior versions of PyTorch (1.9 and earlier), the autograd engine always synced
the default stream with all backward ops, so the following pattern:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">use</span> <span class="n">grads</span>
</pre></div>
</div>
<p>was safe as long as <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">grads</span></code> happened on the default stream.
In present PyTorch, that pattern is no longer safe. If <code class="docutils literal notranslate"><span class="pre">backward()</span></code>
and <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">grads</span></code> are in different stream contexts, you must sync the streams:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">use</span> <span class="n">grads</span>
</pre></div>
</div>
<p>even if <code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">grads</span></code> is on the default stream.</p>
</section>
</section>
</section>
<section id="memory-management">
<span id="cuda-memory-management"></span><h2>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">#</a></h2>
<p>PyTorch uses a caching memory allocator to speed up memory allocations. This
allows fast memory deallocation without device synchronizations. However, the
unused memory managed by the allocator will still show as if used in
<code class="docutils literal notranslate"><span class="pre">nvidia-smi</span></code>. You can use <a class="reference internal" href="../python-api/generated/torch.cuda.memory_allocated.html#torch.cuda.memory_allocated" title="torch.cuda.memory_allocated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_allocated()</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.cuda.max_memory_allocated.html#torch.cuda.max_memory_allocated" title="torch.cuda.max_memory_allocated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max_memory_allocated()</span></code></a> to monitor memory occupied by
tensors, and use <a class="reference internal" href="../python-api/generated/torch.cuda.memory_reserved.html#torch.cuda.memory_reserved" title="torch.cuda.memory_reserved"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_reserved()</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.cuda.max_memory_reserved.html#torch.cuda.max_memory_reserved" title="torch.cuda.max_memory_reserved"><code class="xref py py-meth docutils literal notranslate"><span class="pre">max_memory_reserved()</span></code></a> to monitor the total amount of memory
managed by the caching allocator. Calling <a class="reference internal" href="../python-api/generated/torch.cuda.empty_cache.html#torch.cuda.empty_cache" title="torch.cuda.empty_cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">empty_cache()</span></code></a>
releases all <strong>unused</strong> cached memory from PyTorch so that those can be used
by other GPU applications. However, the occupied GPU memory by tensors will not
be freed so it can not increase the amount of GPU memory available for PyTorch.</p>
<p>To better understand how CUDA memory is being used over time,
<a class="reference internal" href="../python-api/torch_cuda_memory.html#torch-cuda-memory"><span class="std std-ref">Understanding CUDA Memory Usage</span></a> describes tools for capturing and visualizing traces of memory use.</p>
<p>For more advanced users, we offer more comprehensive memory benchmarking via
<a class="reference internal" href="../python-api/generated/torch.cuda.memory_stats.html#torch.cuda.memory_stats" title="torch.cuda.memory_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_stats()</span></code></a>. We also offer the capability to capture a
complete snapshot of the memory allocator state via
<a class="reference internal" href="../python-api/generated/torch.cuda.memory_snapshot.html#torch.cuda.memory_snapshot" title="torch.cuda.memory_snapshot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_snapshot()</span></code></a>, which can help you understand the
underlying allocation patterns produced by your code.</p>
<section id="optimizing-memory-usage-with-pytorch-cuda-alloc-conf">
<span id="cuda-memory-envvars"></span><h3>Optimizing memory usage  with <code class="docutils literal notranslate"><span class="pre">PYTORCH_CUDA_ALLOC_CONF</span></code><a class="headerlink" href="#optimizing-memory-usage-with-pytorch-cuda-alloc-conf" title="Link to this heading">#</a></h3>
<p>Use of a caching allocator can interfere with memory checking tools such as
<code class="docutils literal notranslate"><span class="pre">cuda-memcheck</span></code>.  To debug memory errors using <code class="docutils literal notranslate"><span class="pre">cuda-memcheck</span></code>, set
<code class="docutils literal notranslate"><span class="pre">PYTORCH_NO_CUDA_MEMORY_CACHING=1</span></code> in your environment to disable caching.</p>
<p>The behavior of the caching allocator can be controlled via the environment variable
<code class="docutils literal notranslate"><span class="pre">PYTORCH_CUDA_ALLOC_CONF</span></code>.
The format is <code class="docutils literal notranslate"><span class="pre">PYTORCH_CUDA_ALLOC_CONF=&lt;option&gt;:&lt;value&gt;,&lt;option2&gt;:&lt;value2&gt;...</span></code>
Available options:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">backend</span></code> allows selecting the underlying allocator implementation.
Currently, valid options are <code class="docutils literal notranslate"><span class="pre">native</span></code>, which uses PyTorchs native
implementation, and <code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code>, which uses
<a class="reference external" href="https://developer.nvidia.com/blog/using-cuda-stream-ordered-memory-allocator-part-1/">CUDAs built-in asynchronous allocator</a>.
<code class="docutils literal notranslate"><span class="pre">cudaMallocAsync</span></code> requires CUDA 11.4 or newer. The default is <code class="docutils literal notranslate"><span class="pre">native</span></code>.
<code class="docutils literal notranslate"><span class="pre">backend</span></code> applies to all devices used by the process, and cant be
specified on a per-device basis.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_split_size_mb</span></code> prevents the native allocator
from splitting blocks larger than this size (in MB). This can reduce
fragmentation and may allow some borderline workloads to complete without
running out of memory. Performance cost can range from zero to substantial
depending on allocation patterns.  Default value is unlimited, i.e. all blocks
can be split. The
<a class="reference internal" href="../python-api/generated/torch.cuda.memory_stats.html#torch.cuda.memory_stats" title="torch.cuda.memory_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_stats()</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.cuda.memory_summary.html#torch.cuda.memory_summary" title="torch.cuda.memory_summary"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_summary()</span></code></a> methods are useful for tuning.  This
option should be used as a last resort for a workload that is aborting
due to out of memory and showing a large amount of inactive split blocks.
<code class="docutils literal notranslate"><span class="pre">max_split_size_mb</span></code> is only meaningful with <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>.
With <code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>, <code class="docutils literal notranslate"><span class="pre">max_split_size_mb</span></code> is ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">roundup_power2_divisions</span></code> helps with rounding the requested allocation
size to nearest power-2 division and making better use of the blocks. In
the native CUDACachingAllocator, the sizes are rounded up in multiple
of blocks size of 512, so this works fine for smaller sizes. However, this
can be inefficient for large near-by allocations as each will go to different
size of blocks and re-use of those blocks are minimized. This might create
lots of unused blocks and will waste GPU memory capacity. This option enables
the rounding of allocation size to nearest power-2 division. For example, if
we need to round-up size of 1200 and if number of divisions is 4,
the size 1200 lies between 1024 and 2048 and if we do 4 divisions between
them, the values are 1024, 1280, 1536, and 1792. So, allocation size of 1200
will be rounded to 1280 as the nearest ceiling of power-2 division.
Specify a single value to apply for all allocation sizes or specify an
array of key value pairs to set power-2 division individually for each
power of two interval. For example to set 1 division for all allocations
under 256MB, 2 division for allocations between 256MB and 512MB, 4 divisions
for allocations between 512MB and 1GB and 8 divisions for any larger allocations,
set the knob value to: [256:1,512:2,1024:4,&gt;:8].
<code class="docutils literal notranslate"><span class="pre">roundup_power2_divisions</span></code> is only meaningful with <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>.
With <code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>, <code class="docutils literal notranslate"><span class="pre">roundup_power2_divisions</span></code> is ignored.</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">max_non_split_rounding_mb</span></code> will allow non-split blocks for better reuse, eg,</dt><dd><p>a 1024MB cached block can be re-used for a 512MB allocation request. In the default
case, we only allow up to 20MB of rounding of non-split blocks, so a 512MB block
can only be served with between 512-532 MB size block. If we set the value of this
option to 1024, it will alow 512-1536 MB size blocks to be used for a 512MB block
which increases reuse of larger blocks. This will also help in reducing the stalls
in avoiding expensive cudaMalloc calls.</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">garbage_collection_threshold</span></code> helps actively reclaiming unused GPU memory to
avoid triggering expensive sync-and-reclaim-all operation (release_cached_blocks),
which can be unfavorable to latency-critical GPU applications (e.g., servers).
Upon setting this threshold (e.g., 0.8), the allocator will start reclaiming
GPU memory blocks if the GPU memory capacity usage exceeds the threshold (i.e.,
80% of the total memory allocated to the GPU application). The algorithm prefers
to free old &amp; unused blocks first to avoid freeing blocks that are actively being
reused. The threshold value should be between greater than 0.0 and less than 1.0.
<code class="docutils literal notranslate"><span class="pre">garbage_collection_threshold</span></code> is only meaningful with <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>.
With <code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>, <code class="docutils literal notranslate"><span class="pre">garbage_collection_threshold</span></code> is ignored.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expandable_segments</span></code> (experimental, default: <cite>False</cite>) If set to <cite>True</cite>, this setting instructs
the allocator to create CUDA allocations that can later be expanded to better handle cases
where a job changing allocation sizes frequently, such as having a changing batch size.
Normally for large (&gt;2MB) allocations, the allocator calls cudaMalloc to get allocations
that are the same size as what the user requests. In the future, parts of these
allocations can be reused for other requests if they are free. This works well
when the program makes many requests of exactly the same size or of sizes that
even multiples of that size. Many deep learning models follow this behavior.
However, one common exception is when the batch size changes slightly from one
iteration to the next, e.g. in batched inference. When the program runs
initially with batch size <cite>N</cite>, it will make allocations appropriate for that size.
If in the future, it runs at size <cite>N - 1</cite>, the existing allocations will still be
big enough. However, if it runs at size <cite>N + 1</cite>, then it will have to make new
allocations that are slightly larger. Not all the tensors are the same size.
Some might be <cite>(N + 1)*A</cite> and others <cite>(N + 1)*A*B</cite> where <cite>A</cite> and <cite>B</cite> are some non-batch
dimensions in the model. Because the allocator reuses existing allocations when
they are big enough, some number of <cite>(N + 1)*A</cite> allocations will actually fit in
the already existing <cite>N*B*A</cite> segments, though not perfectly. As the model runs it
will partially fill up all of these segments leaving unusable free slices of
memory at the end of these segments. The allocator at some point will need to
<cite>cudaMalloc</cite> a new <cite>(N + 1)*A*B</cite> segment. If there is not enough memory, there is
now no way to recover the slices of memory that are free at the end of existing
segments. With models 50+ layers deep, this pattern might repeat 50+ times
creating many slivers.</p>
<p><cite>expandable_segments</cite> allows the allocator to create a segment initially and then
expand its size later when more memory is needed. Instead of making one segment
per allocation, it tries to make one segment (per stream) that grows as
necessary. Now when the <cite>N + 1</cite> case runs, the allocations will tile nicely into
the one large segment until it fills up. Then more memory is requested and
appended to the end of the segment. This process does not create as many slivers
of unusable memory, so it is more likely to succeed at finding this memory.</p>
<p><cite>pinned_use_cuda_host_register</cite> option is a boolean flag that determines whether to
use the CUDA APIs cudaHostRegister function for allocating pinned memory instead
of the default cudaHostAlloc. When set to True, the memory is allocated using regular
malloc and then pages are mapped to the memory before calling cudaHostRegister.
This pre-mapping of pages helps reduce the lock time during the execution
of cudaHostRegister.</p>
<p><cite>pinned_num_register_threads</cite> option is only valid when pinned_use_cuda_host_register
is set to True. By default, one thread is used to map the pages. This option allows
using more threads to parallelize the page mapping operations to reduce the overall
allocation time of pinned memory. A good value for this option is 8 based on
benchmarking results.</p>
<p><cite>pinned_use_background_threads</cite> option is a boolean flag to enable background thread
for processing events. This avoids any slow path associated with querying/processing of
events in the fast allocation path. This feature is disabled by default.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some stats reported by the
<a class="reference internal" href="../python-api/cuda.html#cuda-memory-management-api"><span class="std std-ref">CUDA memory management API</span></a>
are specific to <code class="docutils literal notranslate"><span class="pre">backend:native</span></code>, and are not meaningful with
<code class="docutils literal notranslate"><span class="pre">backend:cudaMallocAsync</span></code>.
See each functions docstring for details.</p>
</div>
</section>
</section>
<section id="using-custom-memory-allocators-for-cuda">
<span id="cuda-memory-custom-allocator"></span><h2>Using custom memory allocators for CUDA<a class="headerlink" href="#using-custom-memory-allocators-for-cuda" title="Link to this heading">#</a></h2>
<p>It is possible to define allocators as simple functions in C/C++ and compile
them as a shared library, the code below shows a basic allocator that just
traces all the memory operations.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sys/types.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cuda_runtime_api.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="c1">// Compile with g++ alloc.cc -o alloc.so -I/usr/local/cuda/include -shared -fPIC</span>
<span class="k">extern</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">my_malloc</span><span class="p">(</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">   </span><span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;alloc &quot;</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="n">size</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">my_free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">device</span><span class="p">,</span><span class="w"> </span><span class="n">cudaStream_t</span><span class="w"> </span><span class="n">stream</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;free &quot;</span><span class="o">&lt;&lt;</span><span class="n">ptr</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="o">&lt;&lt;</span><span class="n">stream</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">   </span><span class="n">cudaFree</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This can be used in python through the <a class="reference internal" href="../python-api/generated/torch.cuda.CUDAPluggableAllocator.html#torch.cuda.CUDAPluggableAllocator" title="torch.cuda.memory.CUDAPluggableAllocator"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.memory.CUDAPluggableAllocator</span></code></a>.
The user is responsible for supplying the path to the <cite>.so</cite> file and the name
of the alloc/free functions that match the signatures specified above.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="c1"># Load the allocator</span>
<span class="n">new_alloc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">CUDAPluggableAllocator</span><span class="p">(</span>
    <span class="s1">&#39;alloc.so&#39;</span><span class="p">,</span> <span class="s1">&#39;my_malloc&#39;</span><span class="p">,</span> <span class="s1">&#39;my_free&#39;</span><span class="p">)</span>
<span class="c1"># Swap the current allocator</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">change_current_allocator</span><span class="p">(</span><span class="n">new_alloc</span><span class="p">)</span>
<span class="c1"># This will allocate memory in the device using the new allocator</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="c1"># Do an initial memory allocator</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="c1"># Load the allocator</span>
<span class="n">new_alloc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">CUDAPluggableAllocator</span><span class="p">(</span>
    <span class="s1">&#39;alloc.so&#39;</span><span class="p">,</span> <span class="s1">&#39;my_malloc&#39;</span><span class="p">,</span> <span class="s1">&#39;my_free&#39;</span><span class="p">)</span>
<span class="c1"># This will error since the current allocator was already instantiated</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">change_current_allocator</span><span class="p">(</span><span class="n">new_alloc</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="cublas-workspaces">
<h2>cuBLAS workspaces<a class="headerlink" href="#cublas-workspaces" title="Link to this heading">#</a></h2>
<p>For each combination of cuBLAS handle and CUDA stream, a cuBLAS workspace will be allocated
if that handle and stream combination executes a cuBLAS kernel that requires a workspace.
In order to avoid repeatedly allocating workspaces, these workspaces are not deallocated unless
<code class="docutils literal notranslate"><span class="pre">torch._C._cuda_clearCublasWorkspaces()</span></code> is called. The workspace size per allocation can be
specified via the environment variable <code class="docutils literal notranslate"><span class="pre">CUBLAS_WORKSPACE_CONFIG</span></code> with the format <code class="docutils literal notranslate"><span class="pre">:[SIZE]:[COUNT]</span></code>.
As an example, the default workspace size per allocation is <code class="docutils literal notranslate"><span class="pre">CUBLAS_WORKSPACE_CONFIG=:4096:2:16:8</span></code>
which specifies a total size of <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">4096</span> <span class="pre">+</span> <span class="pre">8</span> <span class="pre">*</span> <span class="pre">16</span> <span class="pre">KiB</span></code>. To force cuBLAS to avoid using workspaces,
set <code class="docutils literal notranslate"><span class="pre">CUBLAS_WORKSPACE_CONFIG=:0:0</span></code>.</p>
</section>
<section id="cufft-plan-cache">
<span id="id2"></span><h2>cuFFT plan cache<a class="headerlink" href="#cufft-plan-cache" title="Link to this heading">#</a></h2>
<p>For each CUDA device, an LRU cache of cuFFT plans is used to speed up repeatedly
running FFT methods (e.g., <a class="reference internal" href="../python-api/generated/torch.fft.fft.html#torch.fft.fft" title="torch.fft.fft"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.fft.fft()</span></code></a>) on CUDA tensors of same geometry
with same configuration. Because some cuFFT plans may allocate GPU memory,
these caches have a maximum capacity.</p>
<p>You may control and query the properties of the cache of current device with
the following APIs:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache.max_size</span></code> gives the capacity of the
cache (default is 4096 on CUDA 10 and newer, and 1023 on older CUDA versions).
Setting this value directly modifies the capacity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache.size</span></code> gives the number of plans
currently residing in the cache.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache.clear()</span></code> clears the cache.</p></li>
</ul>
<p>To control and query plan caches of a non-default device, you can index the
<code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache</span></code> object with either a <a class="reference internal" href="../python-api/tensor_attributes.html#torch.device" title="torch.device"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code></a>
object or a device index, and access one of the above attributes. E.g., to set
the capacity of the cache for device <code class="docutils literal notranslate"><span class="pre">1</span></code>, one can write
<code class="docutils literal notranslate"><span class="pre">torch.backends.cuda.cufft_plan_cache[1].max_size</span> <span class="pre">=</span> <span class="pre">10</span></code>.</p>
</section>
<section id="just-in-time-compilation">
<span id="cuda-just-in-time-compilation"></span><h2>Just-in-Time Compilation<a class="headerlink" href="#just-in-time-compilation" title="Link to this heading">#</a></h2>
<p>PyTorch just-in-time compiles some operations, like torch.special.zeta, when
performed on CUDA tensors. This compilation can be time consuming
(up to a few seconds depending on your hardware and software)
and may occur multiple times for a single operator since many PyTorch operators actually
select from a variety of kernels, each of which must be compiled once, depending on their input.
This compilation occurs once per process, or just once if a kernel cache is used.</p>
<p>By default, PyTorch creates a kernel cache in $XDG_CACHE_HOME/torch/kernels if
XDG_CACHE_HOME is defined and $HOME/.cache/torch/kernels if its not (except on Windows,
where the kernel cache is not yet supported). The caching behavior can be directly
controlled with two environment variables. If USE_PYTORCH_KERNEL_CACHE is set to 0 then no
cache will be used, and if PYTORCH_KERNEL_CACHE_PATH is set then that path will be used
as a kernel cache instead of the default location.</p>
</section>
<section id="best-practices">
<h2>Best practices<a class="headerlink" href="#best-practices" title="Link to this heading">#</a></h2>
<section id="device-agnostic-code">
<h3>Device-agnostic code<a class="headerlink" href="#device-agnostic-code" title="Link to this heading">#</a></h3>
<p>Due to the structure of PyTorch, you may need to explicitly write
device-agnostic (CPU or GPU) code; an example may be creating a new tensor as
the initial hidden state of a recurrent neural network.</p>
<p>The first step is to determine whether the GPU should be used or not. A common
pattern is to use Pythons <code class="docutils literal notranslate"><span class="pre">argparse</span></code> module to read in user arguments, and
have a flag that can be used to disable CUDA, in combination with
<a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a>. In the following, <code class="docutils literal notranslate"><span class="pre">args.device</span></code> results in a
<a class="reference internal" href="../python-api/tensor_attributes.html#torch.device" title="torch.device"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code></a> object that can be used to move tensors to CPU or CUDA.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;PyTorch Example&#39;</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--disable-cuda&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span>
                    <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Disable CUDA&#39;</span><span class="p">)</span>
<span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">args</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">disable_cuda</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
    <span class="n">args</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">args</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When assessing the availability of CUDA in a given environment (<a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a>), PyTorchs default
behavior is to call the CUDA Runtime API method <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g18808e54893cfcaafefeab31a73cc55f">cudaGetDeviceCount</a>. Because this call in turn initializes the
CUDA Driver API (via <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__INITIALIZE.html#group__CUDA__INITIALIZE_1g0a2f1517e1bd8502c7194c3a8c134bc3">cuInit</a>) if it is not already initialized, subsequent forks of a process that has run
<a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> will fail with a CUDA initialization error.</p>
<p>One can set <code class="docutils literal notranslate"><span class="pre">PYTORCH_NVML_BASED_CUDA_CHECK=1</span></code> in your environment before importing PyTorch modules that execute
<a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> (or before executing it directly) in order to direct
<a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> to attempt an NVML-based assessment (<a class="reference external" href="https://docs.nvidia.com/deploy/nvml-api/group__nvmlDeviceQueries.html#group__nvmlDeviceQueries_1ga93623b195bff04bbe3490ca33c8a42d">nvmlDeviceGetCount_v2</a>). If the
NVML-based assessment is successful (i.e. NVML discovery/initialization does not fail),
<a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> calls will not poison subsequent forks.</p>
<p>If NVML discovery/initialization fails, <a class="reference internal" href="../python-api/generated/torch.cuda.is_available.html#torch.cuda.is_available" title="torch.cuda.is_available"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_available()</span></code></a> will fallback to the standard CUDA Runtime
API assessment and the aforementioned fork constraint will apply.</p>
<p>Note that the above NVML-based CUDA availability assessment provides a weaker guarantee than the default CUDA
Runtime API approach (which requires CUDA initialization to succeed). In some circumstances, the NVML-based check
may succeed while later CUDA initialization fails.</p>
</div>
<p>Now that we have <code class="docutils literal notranslate"><span class="pre">args.device</span></code>, we can use it to create a Tensor on the
desired device.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span> <span class="mi">42</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
</pre></div>
</div>
<p>This can be used in a number of cases to produce device agnostic code. Below
is an example when using a dataloader:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda:0&#39;</span><span class="p">)</span>  <span class="c1"># CUDA GPU 0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">train_loader</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cuda0</span><span class="p">)</span>
</pre></div>
</div>
<p>When working with multiple GPUs on a system, you can use the
<code class="docutils literal notranslate"><span class="pre">CUDA_VISIBLE_DEVICES</span></code> environment flag to manage which GPUs are available to
PyTorch. As mentioned above, to manually control which GPU a tensor is created
on, the best practice is to use a <a class="reference internal" href="../python-api/generated/torch.cuda.device.html#torch.cuda.device" title="torch.cuda.device"><code class="xref any py py-class docutils literal notranslate"><span class="pre">torch.cuda.device</span></code></a> context manager.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outside device is 0&quot;</span><span class="p">)</span>  <span class="c1"># On device 0 (default in most scenarios)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Inside device is 1&quot;</span><span class="p">)</span>  <span class="c1"># On device 1</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outside device is still 0&quot;</span><span class="p">)</span>  <span class="c1"># On device 0</span>
</pre></div>
</div>
<p>If you have a tensor and would like to create a new tensor of the same type on
the same device, then you can use a <code class="docutils literal notranslate"><span class="pre">torch.Tensor.new_*</span></code> method
(see <a class="reference internal" href="../python-api/tensors.html#torch.Tensor" title="torch.Tensor"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code></a>).
Whilst the previously mentioned <code class="docutils literal notranslate"><span class="pre">torch.*</span></code> factory functions
(<a class="reference internal" href="../python-api/torch.html#tensor-creation-ops"><span class="std std-ref">Creation Ops</span></a>) depend on the current GPU context and
the attributes arguments you pass in, <code class="docutils literal notranslate"><span class="pre">torch.Tensor.new_*</span></code> methods preserve
the device and other attributes of the tensor.</p>
<p>This is the recommended practice when creating modules in which new
tensors need to be created internally during the forward pass.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cuda</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">x_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">x_gpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda</span><span class="p">)</span>
<span class="n">x_cpu_long</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

<span class="n">y_cpu</span> <span class="o">=</span> <span class="n">x_cpu</span><span class="o">.</span><span class="n">new_full</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_cpu</span><span class="p">)</span>

    <span class="n">tensor</span><span class="p">([[</span> <span class="mf">0.3000</span><span class="p">,</span>  <span class="mf">0.3000</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.3000</span><span class="p">,</span>  <span class="mf">0.3000</span><span class="p">],</span>
            <span class="p">[</span> <span class="mf">0.3000</span><span class="p">,</span>  <span class="mf">0.3000</span><span class="p">]])</span>

<span class="n">y_gpu</span> <span class="o">=</span> <span class="n">x_gpu</span><span class="o">.</span><span class="n">new_full</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">fill_value</span><span class="o">=-</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_gpu</span><span class="p">)</span>

    <span class="n">tensor</span><span class="p">([[</span><span class="o">-</span><span class="mf">5.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0000</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">5.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0000</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">5.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">5.0000</span><span class="p">]],</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda:0&#39;</span><span class="p">)</span>

<span class="n">y_cpu_long</span> <span class="o">=</span> <span class="n">x_cpu_long</span><span class="o">.</span><span class="n">new_tensor</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y_cpu_long</span><span class="p">)</span>

    <span class="n">tensor</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">]])</span>
</pre></div>
</div>
<p>If you want to create a tensor of the same type and size of another tensor, and
fill it with either ones or zeros, <a class="reference internal" href="../python-api/generated/torch.ones_like.html#torch.ones_like" title="torch.ones_like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ones_like()</span></code></a> or
<a class="reference internal" href="../python-api/generated/torch.zeros_like.html#torch.zeros_like" title="torch.zeros_like"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zeros_like()</span></code></a> are provided as convenient helper functions (which
also preserve <a class="reference internal" href="../python-api/tensor_attributes.html#torch.device" title="torch.device"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.device</span></code></a> and <a class="reference internal" href="../python-api/tensor_attributes.html#torch.dtype" title="torch.dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.dtype</span></code></a> of a Tensor).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">x_gpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">y_cpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x_cpu</span><span class="p">)</span>
<span class="n">y_gpu</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_gpu</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="use-pinned-memory-buffers">
<span id="cuda-memory-pinning"></span><h3>Use pinned memory buffers<a class="headerlink" href="#use-pinned-memory-buffers" title="Link to this heading">#</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This is an advanced tip. If you overuse pinned memory, it can cause serious
problems when running low on RAM, and you should be aware that pinning is
often an expensive operation.</p>
</div>
<p>Host to GPU copies are much faster when they originate from pinned (page-locked)
memory. CPU tensors and storages expose a <a class="reference internal" href="../python-api/generated/torch.Tensor.pin_memory.html#torch.Tensor.pin_memory" title="torch.Tensor.pin_memory"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pin_memory()</span></code></a>
method, that returns a copy of the object, with data put in a pinned region.</p>
<p>Also, once you pin a tensor or storage, you can use asynchronous GPU copies.
Just pass an additional <code class="docutils literal notranslate"><span class="pre">non_blocking=True</span></code> argument to a
<a class="reference internal" href="../python-api/generated/torch.Tensor.to.html#torch.Tensor.to" title="torch.Tensor.to"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to()</span></code></a> or a <a class="reference internal" href="../python-api/generated/torch.Tensor.cuda.html#torch.Tensor.cuda" title="torch.Tensor.cuda"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cuda()</span></code></a> call. This can be used
to overlap data transfers with computation.</p>
<p>You can make the <a class="reference internal" href="../python-api/data.html#torch.utils.data.DataLoader" title="torch.utils.data.DataLoader"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code></a> return batches placed in
pinned memory by passing <code class="docutils literal notranslate"><span class="pre">pin_memory=True</span></code> to its constructor.</p>
</section>
<section id="use-nn-parallel-distributeddataparallel-instead-of-multiprocessing-or-nn-dataparallel">
<span id="cuda-nn-ddp-instead"></span><h3>Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel<a class="headerlink" href="#use-nn-parallel-distributeddataparallel-instead-of-multiprocessing-or-nn-dataparallel" title="Link to this heading">#</a></h3>
<p>Most use cases involving batched inputs and multiple GPUs should default to
using <a class="reference internal" href="../python-api/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a> to utilize more
than one GPU.</p>
<p>There are significant caveats to using CUDA models with
<a class="reference internal" href="../python-api/multiprocessing.html#module-torch.multiprocessing" title="torch.multiprocessing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">multiprocessing</span></code></a>; unless care is taken to meet the data handling
requirements exactly, it is likely that your program will have incorrect or
undefined behavior.</p>
<p>It is recommended to use <a class="reference internal" href="../python-api/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a>,
instead of <a class="reference internal" href="../python-api/generated/torch.nn.DataParallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataParallel</span></code></a> to do multi-GPU training, even if
there is only a single node.</p>
<p>The difference between <a class="reference internal" href="../python-api/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.nn.DataParallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataParallel</span></code></a> is: <a class="reference internal" href="../python-api/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a>
uses multiprocessing where a process is created for each GPU, while
<a class="reference internal" href="../python-api/generated/torch.nn.DataParallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataParallel</span></code></a> uses multithreading. By using multiprocessing,
each GPU has its dedicated process, this avoids the performance overhead caused
by GIL of Python interpreter.</p>
<p>If you use <a class="reference internal" href="../python-api/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code class="xref py py-class docutils literal notranslate"><span class="pre">DistributedDataParallel</span></code></a>, you could use
<cite>torch.distributed.launch</cite> utility to launch your program, see <a class="reference internal" href="../python-api/distributed.html#distributed-launch"><span class="std std-ref">Third-party backends</span></a>.</p>
</section>
</section>
<section id="cuda-graphs">
<span id="cuda-graph-semantics"></span><h2>CUDA Graphs<a class="headerlink" href="#cuda-graphs" title="Link to this heading">#</a></h2>
<p>A CUDA graph is a record of the work (mostly kernels and their arguments) that a
CUDA stream and its dependent streams perform.
For general principles and details on the underlying CUDA API, see
<a class="reference external" href="https://developer.nvidia.com/blog/cuda-graphs/">Getting Started with CUDA Graphs</a> and the
<a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-graphs">Graphs section</a> of the CUDA C Programming Guide.</p>
<p>PyTorch supports the construction of CUDA graphs using <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#creating-a-graph-using-stream-capture">stream capture</a>, which puts a
CUDA stream in <em>capture mode</em>. CUDA work issued to a capturing stream doesnt actually
run on the GPU. Instead, the work is recorded in a graph.</p>
<p>After capture, the graph can be <em>launched</em> to run the GPU work as many times as needed.
Each replay runs the same kernels with the same arguments. For pointer arguments this
means the same memory addresses are used.
By filling input memory with new data (e.g., from a new batch) before each replay,
you can rerun the same work on new data.</p>
<section id="why-cuda-graphs">
<h3>Why CUDA Graphs?<a class="headerlink" href="#why-cuda-graphs" title="Link to this heading">#</a></h3>
<p>Replaying a graph sacrifices the dynamic flexibility of typical eager execution in exchange for
<strong>greatly reduced CPU overhead</strong>. A graphs arguments and kernels are fixed, so a graph replay
skips all layers of argument setup and kernel dispatch, including Python, C++, and CUDA driver
overheads. Under the hood, a replay submits the entire graphs work to the GPU with
a single call to <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1accfe1da0c605a577c22d9751a09597">cudaGraphLaunch</a>.  Kernels in a replay also execute slightly faster
on the GPU, but eliding CPU overhead is the main benefit.</p>
<p>You should try CUDA graphs if all or part of your network is graph-safe (usually this means
static shapes and static control flow, but see the other <a class="reference internal" href="#capture-constraints"><span class="std std-ref">constraints</span></a>)
and you suspect its runtime is at least somewhat CPU-limited.</p>
</section>
<section id="pytorch-api">
<h3>PyTorch API<a class="headerlink" href="#pytorch-api" title="Link to this heading">#</a></h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This API is in beta and may change in future releases.</p>
</div>
<p>PyTorch exposes graphs via a raw <a class="reference internal" href="../python-api/generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph" title="torch.cuda.CUDAGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.CUDAGraph</span></code></a> class
and two convenience wrappers,
<a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables</span></code></a>.</p>
<p><a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a> is a simple, versatile context manager that
captures CUDA work in its context.
Before capture, warm up the workload to be captured by running
a few eager iterations. Warmup must occur on a side stream.
Because the graph reads from and writes to the same memory addresses in every
replay, you must maintain long-lived references to tensors that hold
input and output data during capture.
To run the graph on new input data, copy new data to the captures input tensor(s),
replay the graph, then read the new output from the captures output tensor(s).
Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>

<span class="c1"># Placeholder input used for capture</span>
<span class="n">static_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>

<span class="c1"># Warmup before capture</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">static_output</span> <span class="o">=</span> <span class="n">static_input</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># Captures the graph</span>
<span class="c1"># To allow capture, automatically sets a side stream as the current stream in the context</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">static_output</span> <span class="o">=</span> <span class="n">static_input</span> <span class="o">*</span> <span class="mi">2</span>

<span class="c1"># Fills the graph&#39;s input memory with new data to compute on</span>
<span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">))</span>
<span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
<span class="c1"># static_output holds the results</span>
<span class="nb">print</span><span class="p">(</span><span class="n">static_output</span><span class="p">)</span>  <span class="c1"># full of 3 * 2 = 6</span>

<span class="c1"># Fills the graph&#39;s input memory with more data to compute on</span>
<span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="mi">4</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">))</span>
<span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">static_output</span><span class="p">)</span>  <span class="c1"># full of 4 * 2 = 8</span>
</pre></div>
</div>
<p>See
<a class="reference internal" href="#whole-network-capture"><span class="std std-ref">Whole-network capture</span></a>,
<a class="reference internal" href="#graphs-with-amp"><span class="std std-ref">Usage with torch.cuda.amp</span></a>, and
<a class="reference internal" href="#multistream-capture"><span class="std std-ref">Usage with multiple streams</span></a>
for realistic and advanced patterns.</p>
<p><a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-class docutils literal notranslate"><span class="pre">make_graphed_callables</span></code></a> is more sophisticated.
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-class docutils literal notranslate"><span class="pre">make_graphed_callables</span></code></a> accepts Python functions and
<a class="reference internal" href="../python-api/generated/torch.nn.Module.html#torch.nn.Module" title="torch.nn.Module"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code></a>s. For each passed function or Module,
it creates separate graphs of the forward-pass and backward-pass work. See
<a class="reference internal" href="#partial-network-capture"><span class="std std-ref">Partial-network capture</span></a>.</p>
<section id="constraints">
<span id="capture-constraints"></span><h4>Constraints<a class="headerlink" href="#constraints" title="Link to this heading">#</a></h4>
<p>A set of ops is <em>capturable</em> if it doesnt violate any of the following constraints.</p>
<p>Constraints apply to all work in a
<a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a> context and all work in the forward and backward passes
of any callable you pass to <a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a>.</p>
<p>Violating any of these will likely cause a runtime error:</p>
<ul class="simple">
<li><p>Capture must occur on a non-default stream. (This is only a concern if you use the raw
<a class="reference internal" href="../python-api/generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph.capture_begin" title="torch.cuda.CUDAGraph.capture_begin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CUDAGraph.capture_begin</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph.capture_end" title="torch.cuda.CUDAGraph.capture_end"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CUDAGraph.capture_end</span></code></a> calls.
<a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">graph</span></code></a> and
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> set a side stream for you.)</p></li>
<li><p>Ops that synchronize the CPU with the GPU (e.g., <code class="docutils literal notranslate"><span class="pre">.item()</span></code> calls) are prohibited.</p></li>
<li><p>CUDA RNG operations are permitted, and when using multiple <a class="reference internal" href="../python-api/generated/torch.Generator.html#torch.Generator" title="torch.Generator"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Generator</span></code></a> instances within a graph,
they must be registered using <code class="xref py py-meth docutils literal notranslate"><span class="pre">CUDAGraph.register_generator_state</span></code> before graph capture.
Avoid using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.get_state</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.set_state</span></code> during capture;
instead, utilize <a class="reference internal" href="../python-api/generated/torch.Generator.html#torch.Generator.graphsafe_set_state" title="torch.Generator.graphsafe_set_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.graphsafe_set_state</span></code></a> and <a class="reference internal" href="../python-api/generated/torch.Generator.html#torch.Generator.graphsafe_get_state" title="torch.Generator.graphsafe_get_state"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Generator.graphsafe_get_state</span></code></a>
for managing generator states safely within the graph context. This ensures proper RNG operation and generator management within CUDA graphs.</p></li>
</ul>
<p>Violating any of these will likely cause silent numerical errors or undefined behavior:</p>
<ul class="simple">
<li><p>Within a process, only one capture may be underway at a time.</p></li>
<li><p>No non-captured CUDA work may run in this process (on any thread) while capture is underway.</p></li>
<li><p>CPU work is not captured. If the captured ops include CPU work, that work will be elided during replay.</p></li>
<li><p>Every replay reads from and writes to the same (virtual) memory addresses.</p></li>
<li><p>Dynamic control flow (based on CPU or GPU data) is prohibited.</p></li>
<li><p>Dynamic shapes are prohibited. The graph assumes every tensor in the captured op sequence
has the same size and layout in every replay.</p></li>
<li><p>Using multiple streams in a capture is allowed, but there are <a class="reference internal" href="#multistream-capture"><span class="std std-ref">restrictions</span></a>.</p></li>
</ul>
</section>
<section id="non-constraints">
<h4>Non-constraints<a class="headerlink" href="#non-constraints" title="Link to this heading">#</a></h4>
<ul class="simple">
<li><p>Once captured, the graph may be replayed on any stream.</p></li>
</ul>
</section>
</section>
<section id="whole-network-capture">
<span id="id3"></span><h3>Whole-network capture<a class="headerlink" href="#whole-network-capture" title="Link to this heading">#</a></h3>
<p>If your entire network is capturable, you can capture and replay an entire iteration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">D_out</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">1024</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">),</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">D_out</span><span class="p">),</span>
                            <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="mf">0.1</span><span class="p">))</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Placeholders used for capture</span>
<span class="n">static_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">static_target</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_out</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>

<span class="c1"># warmup</span>
<span class="c1"># Uses static_input and static_target here for convenience,</span>
<span class="c1"># but in a real setting, because the warmup includes optimizer.step()</span>
<span class="c1"># you must use a few batches of real data.</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># capture</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>
<span class="c1"># Sets grads to None before capture, so backward() will create</span>
<span class="c1"># .grad attributes with allocations from the graph&#39;s private pool</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="n">static_y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
    <span class="n">static_loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">static_y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
    <span class="n">static_loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>

<span class="n">real_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">real_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_target</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">real_inputs</span><span class="p">,</span> <span class="n">real_targets</span><span class="p">):</span>
    <span class="c1"># Fills the graph&#39;s input memory with new data to compute on</span>
    <span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">static_target</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="c1"># replay() includes forward, backward, and step.</span>
    <span class="c1"># You don&#39;t even need to call optimizer.zero_grad() between iterations</span>
    <span class="c1"># because the captured backward refills static .grad tensors in place.</span>
    <span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
    <span class="c1"># Params have been updated. static_y_pred, static_loss, and .grad</span>
    <span class="c1"># attributes hold values from computing on this iteration&#39;s data.</span>
</pre></div>
</div>
</section>
<section id="partial-network-capture">
<span id="id4"></span><h3>Partial-network capture<a class="headerlink" href="#partial-network-capture" title="Link to this heading">#</a></h3>
<p>If some of your network is unsafe to capture (e.g., due to dynamic control flow,
dynamic shapes, CPU syncs, or essential CPU-side logic), you can run the unsafe
part(s) eagerly and use <a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a> to graph only
the capture-safe part(s).</p>
<p>By default, callables returned by <a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a>
are autograd-aware, and can be used in the training loop as direct replacements
for the functions or <a class="reference internal" href="../python-api/generated/torch.nn.Module.html#torch.nn.Module" title="torch.nn.Module"><code class="xref py py-class docutils literal notranslate"><span class="pre">nn.Module</span></code></a>s you passed.</p>
<p><a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> internally creates
<a class="reference internal" href="../python-api/generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph" title="torch.cuda.CUDAGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">CUDAGraph</span></code></a> objects, runs warmup iterations, and maintains
static inputs and outputs as needed.  Therefore (unlike with
<a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a>) you dont need to handle those manually.</p>
<p>In the following example, data-dependent dynamic control flow means the
network isnt capturable end-to-end, but
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a>
lets us capture and run graph-safe sections as graphs regardless:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">D_out</span> <span class="o">=</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="mi">1024</span>

<span class="n">module1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">D_in</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="n">module2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">D_out</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
<span class="n">module3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">D_out</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">MSELoss</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">SGD</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="n">module1</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                                  <span class="n">module2</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span>
                                  <span class="n">module3</span><span class="o">.</span><span class="n">parameters</span><span class="p">()),</span>
                            <span class="n">lr</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># Sample inputs used for capture</span>
<span class="c1"># requires_grad state of sample inputs must match</span>
<span class="c1"># requires_grad state of real inputs each callable will see.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_in</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cuda&#39;</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">module1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">make_graphed_callables</span><span class="p">(</span><span class="n">module1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,))</span>
<span class="n">module2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">make_graphed_callables</span><span class="p">(</span><span class="n">module2</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,))</span>
<span class="n">module3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">make_graphed_callables</span><span class="p">(</span><span class="n">module3</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,))</span>

<span class="n">real_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">real_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">D_out</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">real_inputs</span><span class="p">,</span> <span class="n">real_targets</span><span class="p">):</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">module1</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>  <span class="c1"># forward ops run as a graph</span>

    <span class="k">if</span> <span class="n">tmp</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">module2</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># forward ops run as a graph</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">module3</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>  <span class="c1"># forward ops run as a graph</span>

    <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="c1"># module2&#39;s or module3&#39;s (whichever was chosen) backward ops,</span>
    <span class="c1"># as well as module1&#39;s backward ops, run as graphs</span>
    <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="usage-with-torch-cuda-amp">
<span id="graphs-with-amp"></span><h3>Usage with torch.cuda.amp<a class="headerlink" href="#usage-with-torch-cuda-amp" title="Link to this heading">#</a></h3>
<p>For typical optimizers, <code class="xref py py-meth docutils literal notranslate"><span class="pre">GradScaler.step</span></code> syncs
the CPU with the GPU, which is prohibited during capture. To avoid errors, either use
<a class="reference internal" href="#partial-network-capture"><span class="std std-ref">partial-network capture</span></a>, or (if forward, loss,
and backward are capture-safe) capture forward, loss, and backward but not the
optimizer step:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># warmup</span>
<span class="c1"># In a real setting, use a few batches of real data.</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">Stream</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">():</span>
            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
        <span class="n">scaler</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="c1"># capture</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>
<span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">(</span><span class="n">set_to_none</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">amp</span><span class="o">.</span><span class="n">autocast</span><span class="p">():</span>
        <span class="n">static_y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span>
        <span class="n">static_loss</span> <span class="o">=</span> <span class="n">loss_fn</span><span class="p">(</span><span class="n">static_y_pred</span><span class="p">,</span> <span class="n">static_target</span><span class="p">)</span>
    <span class="n">scaler</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">static_loss</span><span class="p">)</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="c1"># don&#39;t capture scaler.step(optimizer) or scaler.update()</span>

<span class="n">real_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_input</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="n">real_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">rand_like</span><span class="p">(</span><span class="n">static_target</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">data</span><span class="p">,</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">real_inputs</span><span class="p">,</span> <span class="n">real_targets</span><span class="p">):</span>
    <span class="n">static_input</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">static_target</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
    <span class="c1"># Runs scaler.step and scaler.update eagerly</span>
    <span class="n">scaler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">optimizer</span><span class="p">)</span>
    <span class="n">scaler</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="usage-with-multiple-streams">
<span id="multistream-capture"></span><h3>Usage with multiple streams<a class="headerlink" href="#usage-with-multiple-streams" title="Link to this heading">#</a></h3>
<p>Capture mode automatically propagates to any streams that sync with a capturing stream.
Within capture, you may expose parallelism by issuing calls to different streams,
but the overall stream dependency DAG must branch out from the
initial capturing stream after capture begins and rejoin the initial stream
before capture ends:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="c1"># at context manager entrance, torch.cuda.current_stream()</span>
    <span class="c1"># is the initial capturing stream</span>

    <span class="c1"># INCORRECT (does not branch out from or rejoin initial stream)</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">cuda_work</span><span class="p">()</span>

    <span class="c1"># CORRECT:</span>
    <span class="c1"># branches out from initial stream</span>
    <span class="n">s</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">())</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">cuda_work</span><span class="p">()</span>
    <span class="c1"># rejoins initial stream before capture ends</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">current_stream</span><span class="p">()</span><span class="o">.</span><span class="n">wait_stream</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid confusion for power users looking at replays in nsight systems or nvprof:
Unlike eager execution, the graph interprets a nontrivial stream DAG in capture
as a hint, not a command. During replay, the graph may reorganize independent ops
onto different streams or enqueue them in a different order (while respecting your
original DAGs overall dependencies).</p>
</div>
</section>
<section id="usage-with-distributeddataparallel">
<h3>Usage with DistributedDataParallel<a class="headerlink" href="#usage-with-distributeddataparallel" title="Link to this heading">#</a></h3>
<section id="nccl-2-9-6">
<h4>NCCL &lt; 2.9.6<a class="headerlink" href="#nccl-2-9-6" title="Link to this heading">#</a></h4>
<p>NCCL versions earlier than 2.9.6 dont allow collectives to be captured.
You must use <a class="reference internal" href="#partial-network-capture"><span class="std std-ref">partial-network capture</span></a>,
which defers allreduces to happen outside graphed sections of backward.</p>
<p>Call <a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> on graphable network sections
<em>before</em> wrapping the network with DDP.</p>
</section>
<section id="id5">
<h4>NCCL &gt;= 2.9.6<a class="headerlink" href="#id5" title="Link to this heading">#</a></h4>
<p>NCCL versions 2.9.6 or later allow collectives in the graph.
Approaches that capture an <a class="reference internal" href="#whole-network-capture"><span class="std std-ref">entire backward pass</span></a>
are a viable option, but need three setup steps.</p>
<ol class="arabic">
<li><p>Disable DDPs internal async error handling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;NCCL_ASYNC_ERROR_HANDLING&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span>
<span class="n">torch</span><span class="o">.</span><span class="n">distributed</span><span class="o">.</span><span class="n">init_process_group</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Before full-backward capture, DDP must be constructed in a side-stream context:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">DistributedDataParallel</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Your warmup must run at least 11 DDP-enabled eager iterations before capture.</p></li>
</ol>
</section>
</section>
<section id="graph-memory-management">
<span id="id6"></span><h3>Graph memory management<a class="headerlink" href="#graph-memory-management" title="Link to this heading">#</a></h3>
<p>A captured graph acts on the same virtual addresses every time it replays.
If PyTorch frees the memory, a later replay can hit an illegal memory access.
If PyTorch reassigns the memory to new tensors, the replay can corrupt the values
seen by those tensors.  Therefore, the virtual addresses used by the graph must be
reserved for the graph across replays. The PyTorch caching allocator achieves this
by detecting when capture is underway and satisfying the captures allocations
from a graph-private memory pool. The private pool stays alive until its
<a class="reference internal" href="../python-api/generated/torch.cuda.CUDAGraph.html#torch.cuda.CUDAGraph" title="torch.cuda.CUDAGraph"><code class="xref py py-class docutils literal notranslate"><span class="pre">CUDAGraph</span></code></a> object and all tensors created during capture
go out of scope.</p>
<p>Private pools are maintained automatically. By default, the allocator creates a
separate private pool for each capture. If you capture multiple graphs,
this conservative approach ensures graph replays never corrupt each others values,
but sometimes needlessly wastes memory.</p>
<section id="sharing-memory-across-captures">
<h4>Sharing memory across captures<a class="headerlink" href="#sharing-memory-across-captures" title="Link to this heading">#</a></h4>
<p>To economize the memory stashed in private pools, <a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a>
and <a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a> optionally allow different
captures to share the same private pool.
Its safe for a set of graphs to share a private pool if you know theyll always
be replayed in the same order they were captured,
and never be replayed concurrently.</p>
<p><a class="reference internal" href="../python-api/generated/torch.cuda.graph.html#torch.cuda.graph" title="torch.cuda.graph"><code class="xref py py-class docutils literal notranslate"><span class="pre">torch.cuda.graph</span></code></a>s <code class="docutils literal notranslate"><span class="pre">pool</span></code> argument is a hint to use a particular private pool,
and can be used to share memory across graphs as shown:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>
<span class="n">g2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">CUDAGraph</span><span class="p">()</span>

<span class="c1"># (create static inputs for g1 and g2, run warmups of their workloads...)</span>

<span class="c1"># Captures g1</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g1</span><span class="p">):</span>
    <span class="n">static_out_1</span> <span class="o">=</span> <span class="n">g1_workload</span><span class="p">(</span><span class="n">static_in_1</span><span class="p">)</span>

<span class="c1"># Captures g2, hinting that g2 may share a memory pool with g1</span>
<span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">graph</span><span class="p">(</span><span class="n">g2</span><span class="p">,</span> <span class="n">pool</span><span class="o">=</span><span class="n">g1</span><span class="o">.</span><span class="n">pool</span><span class="p">()):</span>
    <span class="n">static_out_2</span> <span class="o">=</span> <span class="n">g2_workload</span><span class="p">(</span><span class="n">static_in_2</span><span class="p">)</span>

<span class="n">static_in_1</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">real_data_1</span><span class="p">)</span>
<span class="n">static_in_2</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">real_data_2</span><span class="p">)</span>
<span class="n">g1</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
<span class="n">g2</span><span class="o">.</span><span class="n">replay</span><span class="p">()</span>
</pre></div>
</div>
<p>With <a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">torch.cuda.make_graphed_callables()</span></code></a>, if you want to graph several
callables and you know theyll always run in the same order (and never concurrently)
pass them as a tuple in the same order theyll run in the live workload, and
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> will capture their graphs using a shared
private pool.</p>
<p>If, in the live workload, your callables will run in an order that occasionally changes,
or if theyll run concurrently, passing them as a tuple to a single invocation of
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> is not allowed. Instead, you must call
<a class="reference internal" href="../python-api/generated/torch.cuda.make_graphed_callables.html#torch.cuda.make_graphed_callables" title="torch.cuda.make_graphed_callables"><code class="xref py py-func docutils literal notranslate"><span class="pre">make_graphed_callables()</span></code></a> separately for each one.</p>
</section>
</section>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="modules.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Modules</p>
      </div>
    </a>
    <a class="right-next"
       href="hip.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">HIP (ROCm) semantics</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc">
<div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tensorfloat-32-tf32-on-ampere-and-later-devices">TensorFloat-32 (TF32) on Ampere (and later) devices</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#reduced-precision-reduction-in-fp16-gemms">Reduced Precision Reduction in FP16 GEMMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#reduced-precision-reduction-in-bf16-gemms">Reduced Precision Reduction in BF16 GEMMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#asynchronous-execution">Asynchronous execution</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cuda-streams">CUDA streams</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#stream-semantics-of-backward-passes">Stream semantics of backward passes</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#bc-note-using-grads-on-the-default-stream">BC note: Using grads on the default stream</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#memory-management">Memory management</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#optimizing-memory-usage-with-pytorch-cuda-alloc-conf">Optimizing memory usage  with <code class="docutils literal notranslate"><span class="pre">PYTORCH_CUDA_ALLOC_CONF</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-custom-memory-allocators-for-cuda">Using custom memory allocators for CUDA</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cublas-workspaces">cuBLAS workspaces</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cufft-plan-cache">cuFFT plan cache</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#just-in-time-compilation">Just-in-Time Compilation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#best-practices">Best practices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#device-agnostic-code">Device-agnostic code</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-pinned-memory-buffers">Use pinned memory buffers</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#use-nn-parallel-distributeddataparallel-instead-of-multiprocessing-or-nn-dataparallel">Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cuda-graphs">CUDA Graphs</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#why-cuda-graphs">Why CUDA Graphs?</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pytorch-api">PyTorch API</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#constraints">Constraints</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#non-constraints">Non-constraints</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#whole-network-capture">Whole-network capture</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-network-capture">Partial-network capture</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-with-torch-cuda-amp">Usage with torch.cuda.amp</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-with-multiple-streams">Usage with multiple streams</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#usage-with-distributeddataparallel">Usage with DistributedDataParallel</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#nccl-2-9-6">NCCL &lt; 2.9.6</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">NCCL &gt;= 2.9.6</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-memory-management">Graph memory management</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#sharing-memory-across-captures">Sharing memory across captures</a></li>
</ul>
</li>
</ul>
</li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  
  <div class="tocsection editthispage">
    <a href="https://github.com/pytorch/pytorch/edit/main/docs/source/notes/cuda.rst">
      <i class="fa-solid fa-pencil"></i>
      
      
        
          Edit on GitHub
        
      
    </a>
  </div>
</div>

  <div class="sidebar-secondary-item">
    <div class="tocsection sourcelink">
      <a href="../_sources/notes/cuda.rst.txt">
        <i class="fa-solid fa-file-lines"></i> Show Source
      </a>
    </div>
</div>

</div>
<div class="sidebar-secondary-item">
 <h6>PyTorch Libraries</h6>
 <ul>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/audio/stable/">torchaudio</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/ao">torchao</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/executorch">ExecuTorch</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/torchrec">torchrec</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/serve/">torchserve</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/data">torchdata</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/data">torchvision</a></li>
 
  <li><a class="nav-link nav-external" href="https://pytorch.org/xla">PyTorch on XLA Devices</a></li>
 
 </ul>
</div>
</div>
</div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>


  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright PyTorch Contributors.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.0.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>